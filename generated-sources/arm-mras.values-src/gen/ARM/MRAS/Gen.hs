module ARM.MRAS.Gen where
import ARM.MRAS.Types

mras :: [Either AliasPage Page]
mras
  = [Right
       (Page "ADC" []
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/carry"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, O, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADC_32_addsub_carry" [("sf", BlockEq [O])]
                 "ADC  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "ADC_64_addsub_carry" [("sf", BlockEq [I])]
                 "ADC  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/carry"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/carry"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"]),
     Right
       (Page "ADCS" []
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/carry"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, O, I, O, O, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADCS_32_addsub_carry" [("sf", BlockEq [O])]
                 "ADCS  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "ADCS_64_addsub_carry" [("sf", BlockEq [I])]
                 "ADCS  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/carry"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/carry"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"]),
     Right
       (Page "ADD_addsub_ext" []
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, O, I, I]),
                  Block (Just "opt") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "imm3") (BlockEq [X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADD_32_addsub_ext" [("sf", BlockEq [O])]
                 "ADD  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"
                 [Symbol "<Wd|WSP>" "Rd" Nothing, Symbol "<Wn|WSP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTB" [[O, O, O]] Nothing,
                           TableRow "UXTH" [[O, O, I]] Nothing,
                           TableRow "LSL|UXTW" [[O, I, O]] Nothing,
                           TableRow "UXTX" [[O, I, I]] Nothing,
                           TableRow "SXTB" [[I, O, O]] Nothing,
                           TableRow "SXTH" [[I, O, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "imm3" Nothing],
               Encoding "ADD_64_addsub_ext" [("sf", BlockEq [I])]
                 "ADD  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
                 [Symbol "<Xd|SP>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<R>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "W" [[O, O, X]] Nothing,
                           TableRow "W" [[O, I, O]] Nothing, TableRow "X" [[X, I, I]] Nothing,
                           TableRow "W" [[I, O, X]] Nothing,
                           TableRow "W" [[I, I, O]] Nothing])),
                  Symbol "<m>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTB" [[O, O, O]] Nothing,
                           TableRow "UXTH" [[O, O, I]] Nothing,
                           TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL|UXTX" [[O, I, I]] Nothing,
                           TableRow "SXTB" [[I, O, O]] Nothing,
                           TableRow "SXTH" [[I, O, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "imm3" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "ADD_addsub_imm" ["MOV_ADD_addsub_imm"]
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/immediate"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, O, O, O, I]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADD_32_addsub_imm" [("sf", BlockEq [O])]
                 "ADD  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}"
                 [Symbol "<Wd|WSP>" "Rd" Nothing, Symbol "<Wn|WSP>" "Rn" Nothing,
                  Symbol "<imm>" "imm12" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL #0" [[O, O]] Nothing,
                           TableRow "LSL #12" [[O, I]] Nothing,
                           TableRow "RESERVED" [[I, X]] Nothing]))],
               Encoding "ADD_64_addsub_imm" [("sf", BlockEq [I])]
                 "ADD  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}"
                 [Symbol "<Xd|SP>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "imm12" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL #0" [[O, O]] Nothing,
                           TableRow "LSL #12" [[O, I]] Nothing,
                           TableRow "RESERVED" [[I, X]] Nothing]))]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/immediate"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/immediate"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "ADD_addsub_shift" []
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, O, I, I]),
                  Block (Just "shift") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADD_32_addsub_shift" [("sf", BlockEq [O])]
                 "ADD  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "ADD_64_addsub_shift" [("sf", BlockEq [I])]
                 "ADD  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"]),
     Right
       (Page "ADDS_addsub_ext" ["CMN_ADDS_addsub_ext"]
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, O, I, I]),
                  Block (Just "opt") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "imm3") (BlockEq [X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADDS_32S_addsub_ext" [("sf", BlockEq [O])]
                 "ADDS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn|WSP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTB" [[O, O, O]] Nothing,
                           TableRow "UXTH" [[O, O, I]] Nothing,
                           TableRow "LSL|UXTW" [[O, I, O]] Nothing,
                           TableRow "UXTX" [[O, I, I]] Nothing,
                           TableRow "SXTB" [[I, O, O]] Nothing,
                           TableRow "SXTH" [[I, O, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "imm3" Nothing],
               Encoding "ADDS_64S_addsub_ext" [("sf", BlockEq [I])]
                 "ADDS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<R>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "W" [[O, O, X]] Nothing,
                           TableRow "W" [[O, I, O]] Nothing, TableRow "X" [[X, I, I]] Nothing,
                           TableRow "W" [[I, O, X]] Nothing,
                           TableRow "W" [[I, I, O]] Nothing])),
                  Symbol "<m>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTB" [[O, O, O]] Nothing,
                           TableRow "UXTH" [[O, O, I]] Nothing,
                           TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL|UXTX" [[O, I, I]] Nothing,
                           TableRow "SXTB" [[I, O, O]] Nothing,
                           TableRow "SXTH" [[I, O, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "imm3" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "ADDS_addsub_imm" ["CMN_ADDS_addsub_imm"]
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/immediate"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [I, O, O, O, I]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADDS_32S_addsub_imm" [("sf", BlockEq [O])]
                 "ADDS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn|WSP>" "Rn" Nothing,
                  Symbol "<imm>" "imm12" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL #0" [[O, O]] Nothing,
                           TableRow "LSL #12" [[O, I]] Nothing,
                           TableRow "RESERVED" [[I, X]] Nothing]))],
               Encoding "ADDS_64S_addsub_imm" [("sf", BlockEq [I])]
                 "ADDS  <Xd>, <Xn|SP>, #<imm>{, <shift>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "imm12" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL #0" [[O, O]] Nothing,
                           TableRow "LSL #12" [[O, I]] Nothing,
                           TableRow "RESERVED" [[I, X]] Nothing]))]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/immediate"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/immediate"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "ADDS_addsub_shift" ["CMN_ADDS_addsub_shift"]
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, O, I, I]),
                  Block (Just "shift") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADDS_32_addsub_shift" [("sf", BlockEq [O])]
                 "ADDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "ADDS_64_addsub_shift" [("sf", BlockEq [I])]
                 "ADDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"]),
     Right
       (Page "ADR" []
          [(Class "ADR_only_pcreladdr" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/address/pc-rel"
                 [Block (Just "op") (BlockEq [O]),
                  Block (Just "immlo") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "immhi")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADR_only_pcreladdr" [] "ADR  <Xd>, <label>"
                 [Symbol "<Xd>" "Rd" Nothing,
                  Symbol "<label>" "immhi:immlo" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/address/pc-rel"
               (Just PsDecode)
               "integer d = UInt(Rd);\nboolean page = (op == '1');\nbits(64) imm;\n\nif page then\n    imm = SignExtend(immhi:immlo:Zeros(12), 64);\nelse\n    imm = SignExtend(immhi:immlo, 64);"])]
          [Ps "aarch64/instrs/integer/arithmetic/address/pc-rel"
             (Just PsExecute)
             "bits(64) base = PC[];\n\nif page then\n    base<11:0> = Zeros(12);\n\nX[d] = base + imm;"]),
     Right
       (Page "ADRP" []
          [(Class "ADRP_only_pcreladdr" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/address/pc-rel"
                 [Block (Just "op") (BlockEq [I]),
                  Block (Just "immlo") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "immhi")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADRP_only_pcreladdr" [] "ADRP  <Xd>, <label>"
                 [Symbol "<Xd>" "Rd" Nothing,
                  Symbol "<label>" "immhi:immlo" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/address/pc-rel"
               (Just PsDecode)
               "integer d = UInt(Rd);\nboolean page = (op == '1');\nbits(64) imm;\n\nif page then\n    imm = SignExtend(immhi:immlo:Zeros(12), 64);\nelse\n    imm = SignExtend(immhi:immlo, 64);"])]
          [Ps "aarch64/instrs/integer/arithmetic/address/pc-rel"
             (Just PsExecute)
             "bits(64) base = PC[];\n\nif page then\n    base<11:0> = Zeros(12);\n\nX[d] = base + imm;"]),
     Right
       (Page "AND_log_imm" []
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/logical/immediate"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, O, I, O, O]),
                  Block (Just "N") (BlockEq [X]),
                  Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AND_32_log_imm"
                 [("sf", BlockEq [O]), ("N", BlockEq [O])]
                 "AND  <Wd|WSP>, <Wn>, #<imm>"
                 [Symbol "<Wd|WSP>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<imm>" "immr:imms" Nothing],
               Encoding "AND_64_log_imm" [("sf", BlockEq [I])]
                 "AND  <Xd|SP>, <Xn>, #<imm>"
                 [Symbol "<Xd|SP>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<imm>" "N:immr:imms" Nothing]],
            [Ps "aarch64/instrs/integer/logical/immediate" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);"])]
          [Ps "aarch64/instrs/integer/logical/immediate" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "AND_log_shift" []
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, I, O, I, O]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "N") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AND_32_log_shift" [("sf", BlockEq [O])]
                 "AND  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "AND_64_log_shift" [("sf", BlockEq [I])]
                 "AND  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');"])]
          [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"]),
     Right
       (Page "ANDS_log_imm" ["TST_ANDS_log_imm"]
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/logical/immediate"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [I, I]),
                  Block Nothing (BlockEq [I, O, O, I, O, O]),
                  Block (Just "N") (BlockEq [X]),
                  Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ANDS_32S_log_imm"
                 [("sf", BlockEq [O]), ("N", BlockEq [O])]
                 "ANDS  <Wd>, <Wn>, #<imm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<imm>" "immr:imms" Nothing],
               Encoding "ANDS_64S_log_imm" [("sf", BlockEq [I])]
                 "ANDS  <Xd>, <Xn>, #<imm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<imm>" "N:immr:imms" Nothing]],
            [Ps "aarch64/instrs/integer/logical/immediate" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);"])]
          [Ps "aarch64/instrs/integer/logical/immediate" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "ANDS_log_shift" ["TST_ANDS_log_shift"]
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [I, I]),
                  Block Nothing (BlockEq [O, I, O, I, O]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "N") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ANDS_32_log_shift" [("sf", BlockEq [O])]
                 "ANDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "ANDS_64_log_shift" [("sf", BlockEq [I])]
                 "ANDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');"])]
          [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"]),
     Left
       (AliasPage "ASR_SBFM" "SBFM"
          (Class "signed_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, I, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "ASR_SBFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O]),
                 ("imms", BlockEq [O, I, I, I, I, I])]
                "ASR  <Wd>, <Wn>, #<shift>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<shift>" "immr" Nothing],
              Encoding "ASR_SBFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I]),
                 ("imms", BlockEq [I, I, I, I, I, I])]
                "ASR  <Xd>, <Xn>, #<shift>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<shift>" "immr" Nothing]])),
     Left
       (AliasPage "ASR_ASRV" "ASRV"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/shift/variable"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "opcode2<5:2>") (BlockEq [O, O, I, O]),
                 Block (Just "op2") (BlockEq [I, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "ASR_ASRV_32_dp_2src" [("sf", BlockEq [O])]
                "ASR  <Wd>, <Wn>, <Wm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<Wm>" "Rm" Nothing],
              Encoding "ASR_ASRV_64_dp_2src" [("sf", BlockEq [I])]
                "ASR  <Xd>, <Xn>, <Xm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<Xm>" "Rm" Nothing]])),
     Right
       (Page "ASRV" ["ASR_ASRV"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/shift/variable"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2<5:2>") (BlockEq [O, O, I, O]),
                  Block (Just "op2") (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ASRV_32_dp_2src" [("sf", BlockEq [O])]
                 "ASRV  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "ASRV_64_dp_2src" [("sf", BlockEq [I])]
                 "ASRV  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/shift/variable" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);"])]
          [Ps "aarch64/instrs/integer/shift/variable" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"]),
     Left
       (AliasPage "AT_SYS" "SYS"
          (Class "SYS_CR_system" Nothing
             (Diagram "aarch64/instrs/system/sysops"
                [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                 Block (Just "L") (BlockEq [O]),
                 Block (Just "op0") (BlockEq [O, I]),
                 Block (Just "op1") (BlockEq [X, X, X]),
                 Block (Just "CRn") (BlockEq [O, I, I, I]),
                 Block (Just "CRm") (BlockEq [I, O, O, X]),
                 Block (Just "op2") (BlockEq [X, X, X]),
                 Block (Just "Rt") (BlockEq [X, X, X, X, X])])
             [Encoding "AT_SYS_CR_system" [] "AT  <at_op>, <Xt>"
                [Symbol "<at_op>" "op1:CRm<0>:op2"
                   (Just
                      (Table ["op2", "CRm<0>", "op1"]
                         [TableRow "S1E1R" [[O, O, O], [O], [O, O, O]] Nothing,
                          TableRow "S1E1W" [[O, O, I], [O], [O, O, O]] Nothing,
                          TableRow "S1E0R" [[O, I, O], [O], [O, O, O]] Nothing,
                          TableRow "S1E0W" [[O, I, I], [O], [O, O, O]] Nothing,
                          TableRow "S1E1RP" [[O, O, O], [I], [O, O, O]]
                            (Just (ArchFeature "ARMv8.2-ATS1E1")),
                          TableRow "S1E1WP" [[O, O, I], [I], [O, O, O]]
                            (Just (ArchFeature "ARMv8.2-ATS1E1")),
                          TableRow "S1E2R" [[O, O, O], [O], [I, O, O]] Nothing,
                          TableRow "S1E2W" [[O, O, I], [O], [I, O, O]] Nothing,
                          TableRow "S12E1R" [[I, O, O], [O], [I, O, O]] Nothing,
                          TableRow "S12E1W" [[I, O, I], [O], [I, O, O]] Nothing,
                          TableRow "S12E0R" [[I, I, O], [O], [I, O, O]] Nothing,
                          TableRow "S12E0W" [[I, I, I], [O], [I, O, O]] Nothing,
                          TableRow "S1E3R" [[O, O, O], [O], [I, I, O]] Nothing,
                          TableRow "S1E3W" [[O, O, I], [O], [I, I, O]] Nothing])),
                 Symbol "<op1>" "op1" Nothing, Symbol "<Cm>" "CRm" Nothing,
                 Symbol "<op2>" "op2" Nothing, Symbol "<Xt>" "Rt" Nothing]])),
     Right
       (Page "AUTDA" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/autda/dp_1src"
                 [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, I]),
                  Block (Just "opcode[5]") (BlockEq [O]),
                  Block (Just "opcode[4]") (BlockEq [O]),
                  Block (Just "Z") (BlockEq [X]),
                  Block (Just "opcode[2:0]") (BlockEq [I, I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AUTDA_64P_dp_1src" [("Z", BlockEq [O])]
                 "AUTDA  <Xd>, <Xn|SP>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "AUTDZA_64Z_dp_1src"
                 [("Z", BlockEq [I]), ("Rn", BlockEq [I, I, I, I, I])]
                 "AUTDZA  <Xd>"
                 [Symbol "<Xd>" "Rd" Nothing]],
            [Ps "aarch64/instrs/integer/pac/autda/dp_1src" (Just PsDecode)
               "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UnallocatedEncoding();\n\nif Z == '0' then // AUTDA\n    if n == 31 then source_is_sp = TRUE;\nelse // AUTDZA\n    if n != 31 then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/integer/pac/autda/dp_1src" (Just PsExecute)
             "if source_is_sp then\n    X[d] = AuthDA(X[d], SP[]);\nelse\n    X[d] = AuthDA(X[d], X[n]);"]),
     Right
       (Page "AUTDB" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/autdb/dp_1src"
                 [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, I]),
                  Block (Just "opcode[5]") (BlockEq [O]),
                  Block (Just "opcode[4]") (BlockEq [O]),
                  Block (Just "Z") (BlockEq [X]),
                  Block (Just "opcode[2:0]") (BlockEq [I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AUTDB_64P_dp_1src" [("Z", BlockEq [O])]
                 "AUTDB  <Xd>, <Xn|SP>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "AUTDZB_64Z_dp_1src"
                 [("Z", BlockEq [I]), ("Rn", BlockEq [I, I, I, I, I])]
                 "AUTDZB  <Xd>"
                 [Symbol "<Xd>" "Rd" Nothing]],
            [Ps "aarch64/instrs/integer/pac/autdb/dp_1src" (Just PsDecode)
               "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UnallocatedEncoding();\n\nif Z == '0' then // AUTDB\n    if n == 31 then source_is_sp = TRUE;\nelse // AUTDZB\n    if n != 31 then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/integer/pac/autdb/dp_1src" (Just PsExecute)
             "if source_is_sp then\n    X[d] = AuthDB(X[d], SP[]);\nelse\n    X[d] = AuthDB(X[d], X[n]);"]),
     Right
       (Page "AUTIA" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/autia/dp_1src"
                 [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, I]),
                  Block (Just "opcode[5]") (BlockEq [O]),
                  Block (Just "opcode[4]") (BlockEq [O]),
                  Block (Just "Z") (BlockEq [X]),
                  Block (Just "opcode[2:0]") (BlockEq [I, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AUTIA_64P_dp_1src" [("Z", BlockEq [O])]
                 "AUTIA  <Xd>, <Xn|SP>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "AUTIZA_64Z_dp_1src"
                 [("Z", BlockEq [I]), ("Rn", BlockEq [I, I, I, I, I])]
                 "AUTIZA  <Xd>"
                 [Symbol "<Xd>" "Rd" Nothing]],
            [Ps "aarch64/instrs/integer/pac/autia/dp_1src" (Just PsDecode)
               "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UnallocatedEncoding();\n\nif Z == '0' then // AUTIA\n    if n == 31 then source_is_sp = TRUE;\nelse // AUTIZA\n    if n != 31 then UnallocatedEncoding();"]),
           (Class "system" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/autia/hint"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, X, I]),
                  Block (Just "op2") (BlockEq [I, O, X]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "AUTIA1716_HI_system"
                 [("CRm", BlockEq [O, O, O, I]), ("op2", BlockEq [I, O, O])]
                 "AUTIA1716"
                 [],
               Encoding "AUTIASP_HI_system"
                 [("CRm", BlockEq [O, O, I, I]), ("op2", BlockEq [I, O, I])]
                 "AUTIASP"
                 [],
               Encoding "AUTIAZ_HI_system"
                 [("CRm", BlockEq [O, O, I, I]), ("op2", BlockEq [I, O, O])]
                 "AUTIAZ"
                 []],
            [Ps "aarch64/instrs/integer/pac/autia/hint" (Just PsDecode)
               "integer d;\ninteger n;\nboolean source_is_sp = FALSE;\n\ncase CRm:op2 of\n    when '0011 100' // AUTIAZ\n        d = 30;\n        n = 31;\n    when '0011 101' // AUTIASP\n        d = 30;\n        source_is_sp = TRUE;\n    when '0001 100' // AUTIA1716\n        d = 17;\n        n = 16;\n    when '0001 000' SEE \"PACIA\";\n    when '0001 010' SEE \"PACIB\";\n    when '0001 110' SEE \"AUTIB\";\n    when '0011 00x' SEE \"PACIA\";\n    when '0011 01x' SEE \"PACIB\";\n    when '0011 11x' SEE \"AUTIB\";\n    when '0000 111' SEE \"XPACLRI\";\n    otherwise SEE \"HINT\";"])]
          [Ps "aarch64/instrs/integer/pac/autia/dp_1src" (Just PsExecute)
             "if HavePACExt() then\n    if source_is_sp then\n        X[d] = AuthIA(X[d], SP[]);\n    else\n        X[d] = AuthIA(X[d], X[n]);"]),
     Right
       (Page "AUTIB" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/autib/dp_1src"
                 [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, I]),
                  Block (Just "opcode[5]") (BlockEq [O]),
                  Block (Just "opcode[4]") (BlockEq [O]),
                  Block (Just "Z") (BlockEq [X]),
                  Block (Just "opcode[2:0]") (BlockEq [I, O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AUTIB_64P_dp_1src" [("Z", BlockEq [O])]
                 "AUTIB  <Xd>, <Xn|SP>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "AUTIZB_64Z_dp_1src"
                 [("Z", BlockEq [I]), ("Rn", BlockEq [I, I, I, I, I])]
                 "AUTIZB  <Xd>"
                 [Symbol "<Xd>" "Rd" Nothing]],
            [Ps "aarch64/instrs/integer/pac/autib/dp_1src" (Just PsDecode)
               "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UnallocatedEncoding();\n\nif Z == '0' then // AUTIB\n    if n == 31 then source_is_sp = TRUE;\nelse // AUTIZB\n    if n != 31 then UnallocatedEncoding();"]),
           (Class "system" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/autib/hint"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, X, I]),
                  Block (Just "op2") (BlockEq [I, I, X]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "AUTIB1716_HI_system"
                 [("CRm", BlockEq [O, O, O, I]), ("op2", BlockEq [I, I, O])]
                 "AUTIB1716"
                 [],
               Encoding "AUTIBSP_HI_system"
                 [("CRm", BlockEq [O, O, I, I]), ("op2", BlockEq [I, I, I])]
                 "AUTIBSP"
                 [],
               Encoding "AUTIBZ_HI_system"
                 [("CRm", BlockEq [O, O, I, I]), ("op2", BlockEq [I, I, O])]
                 "AUTIBZ"
                 []],
            [Ps "aarch64/instrs/integer/pac/autib/hint" (Just PsDecode)
               "integer d;\ninteger n;\nboolean source_is_sp = FALSE;\n\ncase CRm:op2 of\n    when '0011 110' // AUTIBZ\n        d = 30;\n        n = 31;\n    when '0011 111' // AUTIBSP\n        d = 30;\n        source_is_sp = TRUE;\n    when '0001 110' // AUTIB1716\n        d = 17;\n        n = 16;\n    when '0001 000' SEE \"PACIA\";\n    when '0001 010' SEE \"PACIB\";\n    when '0001 100' SEE \"AUTIA\";\n    when '0011 00x' SEE \"PACIA\";\n    when '0011 01x' SEE \"PACIB\";\n    when '0011 10x' SEE \"AUTIA\";\n    when '0000 111' SEE \"XPACLRI\";"])]
          [Ps "aarch64/instrs/integer/pac/autib/dp_1src" (Just PsExecute)
             "if HavePACExt() then\n    if source_is_sp then\n        X[d] = AuthIB(X[d], SP[]);\n    else\n        X[d] = AuthIB(X[d], X[n]);"]),
     Right
       (Page "B_uncond" []
          [(Class "B_only_branch_imm" Nothing
              (Diagram "aarch64/instrs/branch/unconditional/immediate"
                 [Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, I, O, I]),
                  Block (Just "imm26")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X,
                        X, X, X, X])])
              [Encoding "B_only_branch_imm" [] "B  <label>"
                 [Symbol "<label>" "imm26" Nothing]],
            [Ps "aarch64/instrs/branch/unconditional/immediate" (Just PsDecode)
               "BranchType branch_type = if op == '1' then BranchType_CALL else BranchType_JMP;\nbits(64) offset = SignExtend(imm26:'00', 64);"])]
          [Ps "aarch64/instrs/branch/unconditional/immediate"
             (Just PsExecute)
             "if branch_type == BranchType_CALL then X[30] = PC[] + 4;\n\nBranchTo(PC[] + offset, branch_type);"]),
     Right
       (Page "B_cond" []
          [(Class "B_only_condbranch" Nothing
              (Diagram "aarch64/instrs/branch/conditional/cond"
                 [Block Nothing (BlockEq [O, I, O, I, O, I, O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "imm19")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "cond") (BlockEq [X, X, X, X])])
              [Encoding "B_only_condbranch" [] "B.<cond>  <label>"
                 [Symbol "<cond>" "cond" Nothing,
                  Symbol "<label>" "imm19" Nothing]],
            [Ps "aarch64/instrs/branch/conditional/cond" (Just PsDecode)
               "bits(64) offset = SignExtend(imm19:'00', 64);\nbits(4) condition = cond;"])]
          [Ps "aarch64/instrs/branch/conditional/cond" (Just PsExecute)
             "if ConditionHolds(condition) then\n    BranchTo(PC[] + offset, BranchType_JMP);"]),
     Left
       (AliasPage "BFC_BFM" "BFM"
          (Class "nofill" (Just (ArchName "ARMv8.2"))
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "BFC_BFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "BFC  <Wd>, #<lsb>, #<width>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<lsb>" "" Nothing,
                 Symbol "<width>" "" Nothing],
              Encoding "BFC_BFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I])]
                "BFC  <Xd>, #<lsb>, #<width>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<lsb>" "" Nothing,
                 Symbol "<width>" "" Nothing]])),
     Left
       (AliasPage "BFI_BFM" "BFM"
          (Class "nofill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockNeq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "BFI_BFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "BFI  <Wd>, <Wn>, #<lsb>, #<width>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing],
              Encoding "BFI_BFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I])]
                "BFI  <Xd>, <Xn>, #<lsb>, #<width>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing]])),
     Right
       (Page "BFM" ["BFC_BFM", "BFI_BFM", "BFXIL_BFM"]
          [(Class "nofill" Nothing
              (Diagram "aarch64/instrs/integer/bitfield"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, O, O, I, I, O]),
                  Block (Just "N") (BlockEq [X]),
                  Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "BFM_32M_bitfield"
                 [("sf", BlockEq [O]), ("N", BlockEq [O])]
                 "BFM  <Wd>, <Wn>, #<immr>, #<imms>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<immr>" "immr" Nothing, Symbol "<imms>" "imms" Nothing],
               Encoding "BFM_64M_bitfield"
                 [("sf", BlockEq [I]), ("N", BlockEq [I])]
                 "BFM  <Xd>, <Xn>, #<immr>, #<imms>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<immr>" "immr" Nothing, Symbol "<imms>" "imms" Nothing]],
            [Ps "aarch64/instrs/integer/bitfield" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\n\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\n\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    // SBFM\n    when '01' inzero = FALSE; extend = FALSE;   // BFM\n    when '10' inzero = TRUE;  extend = FALSE;   // UBFM\n    when '11' UnallocatedEncoding();\n\nif sf == '1' && N != '1' then ReservedValue();\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();\n\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);"])]
          [Ps "aarch64/instrs/integer/bitfield" (Just PsExecute)
             "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\n\n// perform bitfield move on low bits\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\n\n// determine extension bits (sign, zero or dest register)\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\n\n// combine extension bits and result bits\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);"]),
     Left
       (AliasPage "BFXIL_BFM" "BFM"
          (Class "nofill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "BFXIL_BFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "BFXIL  <Wd>, <Wn>, #<lsb>, #<width>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing],
              Encoding "BFXIL_BFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I])]
                "BFXIL  <Xd>, <Xn>, #<lsb>, #<width>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing]])),
     Right
       (Page "BIC_log_shift" []
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, I, O, I, O]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "N") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "BIC_32_log_shift" [("sf", BlockEq [O])]
                 "BIC  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "BIC_64_log_shift" [("sf", BlockEq [I])]
                 "BIC  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');"])]
          [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"]),
     Right
       (Page "BICS" []
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [I, I]),
                  Block Nothing (BlockEq [O, I, O, I, O]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "N") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "BICS_32_log_shift" [("sf", BlockEq [O])]
                 "BICS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "BICS_64_log_shift" [("sf", BlockEq [I])]
                 "BICS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');"])]
          [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"]),
     Right
       (Page "BL" []
          [(Class "BL_only_branch_imm" Nothing
              (Diagram "aarch64/instrs/branch/unconditional/immediate"
                 [Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, I, O, I]),
                  Block (Just "imm26")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X,
                        X, X, X, X])])
              [Encoding "BL_only_branch_imm" [] "BL  <label>"
                 [Symbol "<label>" "imm26" Nothing]],
            [Ps "aarch64/instrs/branch/unconditional/immediate" (Just PsDecode)
               "BranchType branch_type = if op == '1' then BranchType_CALL else BranchType_JMP;\nbits(64) offset = SignExtend(imm26:'00', 64);"])]
          [Ps "aarch64/instrs/branch/unconditional/immediate"
             (Just PsExecute)
             "if branch_type == BranchType_CALL then X[30] = PC[] + 4;\n\nBranchTo(PC[] + offset, branch_type);"]),
     Right
       (Page "BLR" []
          [(Class "BLR_64_branch_reg" Nothing
              (Diagram "aarch64/instrs/branch/unconditional/register"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, I]),
                  Block (Just "Z") (BlockEq [O]),
                  Block (Just "opc[2:1]") (BlockEq [O]),
                  Block (Just "op") (BlockEq [O, I]),
                  Block (Just "op2") (BlockEq [I, I, I, I, I]),
                  Block (Just "op3[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "A") (BlockEq [O]), Block (Just "M") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rm") (BlockEq [O, O, O, O, O])])
              [Encoding "BLR_64_branch_reg" [] "BLR  <Xn>"
                 [Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/branch/unconditional/register" (Just PsDecode)
               "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\n\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\n\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;"])]
          [Ps "aarch64/instrs/branch/unconditional/register" (Just PsExecute)
             "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);"]),
     Right
       (Page "BLRA" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/branch/unconditional/register"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, I]),
                  Block (Just "Z") (BlockEq [X]),
                  Block (Just "opc[2:1]") (BlockEq [O]),
                  Block (Just "op") (BlockEq [O, I]),
                  Block (Just "op2") (BlockEq [I, I, I, I, I]),
                  Block (Just "op3[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "A") (BlockEq [I]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X])])
              [Encoding "BLRAAZ_64_branch_reg"
                 [("Z", BlockEq [O]), ("M", BlockEq [O]),
                  ("Rm", BlockEq [I, I, I, I, I])]
                 "BLRAAZ  <Xn>"
                 [Symbol "<Xn>" "Rn" Nothing],
               Encoding "BLRAA_64P_branch_reg"
                 [("Z", BlockEq [I]), ("M", BlockEq [O])]
                 "BLRAA  <Xn>, <Xm|SP>"
                 [Symbol "<Xn>" "Rn" Nothing, Symbol "<Xm|SP>" "Rm" Nothing],
               Encoding "BLRABZ_64_branch_reg"
                 [("Z", BlockEq [O]), ("M", BlockEq [I]),
                  ("Rm", BlockEq [I, I, I, I, I])]
                 "BLRABZ  <Xn>"
                 [Symbol "<Xn>" "Rn" Nothing],
               Encoding "BLRAB_64P_branch_reg"
                 [("Z", BlockEq [I]), ("M", BlockEq [I])]
                 "BLRAB  <Xn>, <Xm|SP>"
                 [Symbol "<Xn>" "Rn" Nothing, Symbol "<Xm|SP>" "Rm" Nothing]],
            [Ps "aarch64/instrs/branch/unconditional/register" (Just PsDecode)
               "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\n\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\n\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;"])]
          [Ps "aarch64/instrs/branch/unconditional/register" (Just PsExecute)
             "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);"]),
     Right
       (Page "BR" []
          [(Class "BR_64_branch_reg" Nothing
              (Diagram "aarch64/instrs/branch/unconditional/register"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, I]),
                  Block (Just "Z") (BlockEq [O]),
                  Block (Just "opc[2:1]") (BlockEq [O]),
                  Block (Just "op") (BlockEq [O, O]),
                  Block (Just "op2") (BlockEq [I, I, I, I, I]),
                  Block (Just "op3[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "A") (BlockEq [O]), Block (Just "M") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rm") (BlockEq [O, O, O, O, O])])
              [Encoding "BR_64_branch_reg" [] "BR  <Xn>"
                 [Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/branch/unconditional/register" (Just PsDecode)
               "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\n\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\n\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;"])]
          [Ps "aarch64/instrs/branch/unconditional/register" (Just PsExecute)
             "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);"]),
     Right
       (Page "BRA" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/branch/unconditional/register"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, I]),
                  Block (Just "Z") (BlockEq [X]),
                  Block (Just "opc[2:1]") (BlockEq [O]),
                  Block (Just "op") (BlockEq [O, O]),
                  Block (Just "op2") (BlockEq [I, I, I, I, I]),
                  Block (Just "op3[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "A") (BlockEq [I]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X])])
              [Encoding "BRAAZ_64_branch_reg"
                 [("Z", BlockEq [O]), ("M", BlockEq [O]),
                  ("Rm", BlockEq [I, I, I, I, I])]
                 "BRAAZ  <Xn>"
                 [Symbol "<Xn>" "Rn" Nothing],
               Encoding "BRAA_64P_branch_reg"
                 [("Z", BlockEq [I]), ("M", BlockEq [O])]
                 "BRAA  <Xn>, <Xm|SP>"
                 [Symbol "<Xn>" "Rn" Nothing, Symbol "<Xm|SP>" "Rm" Nothing],
               Encoding "BRABZ_64_branch_reg"
                 [("Z", BlockEq [O]), ("M", BlockEq [I]),
                  ("Rm", BlockEq [I, I, I, I, I])]
                 "BRABZ  <Xn>"
                 [Symbol "<Xn>" "Rn" Nothing],
               Encoding "BRAB_64P_branch_reg"
                 [("Z", BlockEq [I]), ("M", BlockEq [I])]
                 "BRAB  <Xn>, <Xm|SP>"
                 [Symbol "<Xn>" "Rn" Nothing, Symbol "<Xm|SP>" "Rm" Nothing]],
            [Ps "aarch64/instrs/branch/unconditional/register" (Just PsDecode)
               "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\n\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\n\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;"])]
          [Ps "aarch64/instrs/branch/unconditional/register" (Just PsExecute)
             "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);"]),
     Right
       (Page "BRK" []
          [(Class "BRK_EX_exception" Nothing
              (Diagram "aarch64/instrs/system/exceptions/debug/breakpoint"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "opc") (BlockEq [O, O, I]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "op2") (BlockEq [O, O, O]),
                  Block (Just "LL") (BlockEq [O, O])])
              [Encoding "BRK_EX_exception" [] "BRK  #<imm>"
                 [Symbol "<imm>" "imm16" Nothing]],
            [Ps "aarch64/instrs/system/exceptions/debug/breakpoint"
               (Just PsDecode)
               "bits(16) comment = imm16;"])]
          [Ps "aarch64/instrs/system/exceptions/debug/breakpoint"
             (Just PsExecute)
             "AArch64.SoftwareBreakpoint(comment);"]),
     Right
       (Page "CAS" []
          [(Class "base_register" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/cas/single"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [X]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [X]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "CAS_C32_ldstexcl"
                 [("size", BlockEq [I, O]), ("L", BlockEq [O]), ("o0", BlockEq [O])]
                 "CAS  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASA_C32_ldstexcl"
                 [("size", BlockEq [I, O]), ("L", BlockEq [I]), ("o0", BlockEq [O])]
                 "CASA  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASAL_C32_ldstexcl"
                 [("size", BlockEq [I, O]), ("L", BlockEq [I]), ("o0", BlockEq [I])]
                 "CASAL  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASL_C32_ldstexcl"
                 [("size", BlockEq [I, O]), ("L", BlockEq [O]), ("o0", BlockEq [I])]
                 "CASL  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CAS_C64_ldstexcl"
                 [("size", BlockEq [I, I]), ("L", BlockEq [O]), ("o0", BlockEq [O])]
                 "CAS  <Xs>, <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASA_C64_ldstexcl"
                 [("size", BlockEq [I, I]), ("L", BlockEq [I]), ("o0", BlockEq [O])]
                 "CASA  <Xs>, <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASAL_C64_ldstexcl"
                 [("size", BlockEq [I, I]), ("L", BlockEq [I]), ("o0", BlockEq [I])]
                 "CASAL  <Xs>, <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASL_C64_ldstexcl"
                 [("size", BlockEq [I, I]), ("L", BlockEq [O]), ("o0", BlockEq [I])]
                 "CASL  <Xs>, <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/cas/single" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;"])]
          [Ps "aarch64/instrs/memory/atomicops/cas/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\n\ncomparevalue = X[s];\nnewvalue = X[t];\nif n == 31 then \n    CheckSPAlignment(); \n    address = SP[];\nelse \n    address = X[n];\ndata = Mem[address, datasize DIV 8, ldacctype];\nif data == comparevalue then  \n    // All observers in the shareability domain observe the\n    // following load and store atomically.\n    Mem[address, datasize DIV 8, stacctype] = newvalue;\n\nX[s] = ZeroExtend(data, regsize);"]),
     Right
       (Page "CASB" []
          [(Class "base_register" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/cas/single"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [X]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [X]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "CASAB_C32_ldstexcl"
                 [("L", BlockEq [I]), ("o0", BlockEq [O])]
                 "CASAB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASALB_C32_ldstexcl"
                 [("L", BlockEq [I]), ("o0", BlockEq [I])]
                 "CASALB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASB_C32_ldstexcl"
                 [("L", BlockEq [O]), ("o0", BlockEq [O])]
                 "CASB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASLB_C32_ldstexcl"
                 [("L", BlockEq [O]), ("o0", BlockEq [I])]
                 "CASLB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/cas/single" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;"])]
          [Ps "aarch64/instrs/memory/atomicops/cas/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\n\ncomparevalue = X[s];\nnewvalue = X[t];\nif n == 31 then \n    CheckSPAlignment(); \n    address = SP[];\nelse \n    address = X[n];\ndata = Mem[address, datasize DIV 8, ldacctype];\nif data == comparevalue then  \n    // All observers in the shareability domain observe the\n    // following load and store atomically.\n    Mem[address, datasize DIV 8, stacctype] = newvalue;\n\nX[s] = ZeroExtend(data, regsize);"]),
     Right
       (Page "CASH" []
          [(Class "base_register" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/cas/single"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [X]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [X]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "CASAH_C32_ldstexcl"
                 [("L", BlockEq [I]), ("o0", BlockEq [O])]
                 "CASAH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASALH_C32_ldstexcl"
                 [("L", BlockEq [I]), ("o0", BlockEq [I])]
                 "CASALH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASH_C32_ldstexcl"
                 [("L", BlockEq [O]), ("o0", BlockEq [O])]
                 "CASH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASLH_C32_ldstexcl"
                 [("L", BlockEq [O]), ("o0", BlockEq [I])]
                 "CASLH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/cas/single" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;"])]
          [Ps "aarch64/instrs/memory/atomicops/cas/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\n\ncomparevalue = X[s];\nnewvalue = X[t];\nif n == 31 then \n    CheckSPAlignment(); \n    address = SP[];\nelse \n    address = X[n];\ndata = Mem[address, datasize DIV 8, ldacctype];\nif data == comparevalue then  \n    // All observers in the shareability domain observe the\n    // following load and store atomically.\n    Mem[address, datasize DIV 8, stacctype] = newvalue;\n\nX[s] = ZeroExtend(data, regsize);"]),
     Right
       (Page "CASP" []
          [(Class "base_register" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/cas/pair"
                 [Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [X]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [X]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "CASP_CP32_ldstexcl"
                 [("sz", BlockEq [O]), ("L", BlockEq [O]), ("o0", BlockEq [O])]
                 "CASP  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<W(s+1)>" "" Nothing,
                  Symbol "<Wt>" "Rt" Nothing, Symbol "<W(t+1)>" "" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASPA_CP32_ldstexcl"
                 [("sz", BlockEq [O]), ("L", BlockEq [I]), ("o0", BlockEq [O])]
                 "CASPA  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<W(s+1)>" "" Nothing,
                  Symbol "<Wt>" "Rt" Nothing, Symbol "<W(t+1)>" "" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASPAL_CP32_ldstexcl"
                 [("sz", BlockEq [O]), ("L", BlockEq [I]), ("o0", BlockEq [I])]
                 "CASPAL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<W(s+1)>" "" Nothing,
                  Symbol "<Wt>" "Rt" Nothing, Symbol "<W(t+1)>" "" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASPL_CP32_ldstexcl"
                 [("sz", BlockEq [O]), ("L", BlockEq [O]), ("o0", BlockEq [I])]
                 "CASPL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<W(s+1)>" "" Nothing,
                  Symbol "<Wt>" "Rt" Nothing, Symbol "<W(t+1)>" "" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASP_CP64_ldstexcl"
                 [("sz", BlockEq [I]), ("L", BlockEq [O]), ("o0", BlockEq [O])]
                 "CASP  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<X(s+1)>" "" Nothing,
                  Symbol "<Xt>" "Rt" Nothing, Symbol "<X(t+1)>" "" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASPA_CP64_ldstexcl"
                 [("sz", BlockEq [I]), ("L", BlockEq [I]), ("o0", BlockEq [O])]
                 "CASPA  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<X(s+1)>" "" Nothing,
                  Symbol "<Xt>" "Rt" Nothing, Symbol "<X(t+1)>" "" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASPAL_CP64_ldstexcl"
                 [("sz", BlockEq [I]), ("L", BlockEq [I]), ("o0", BlockEq [I])]
                 "CASPAL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<X(s+1)>" "" Nothing,
                  Symbol "<Xt>" "Rt" Nothing, Symbol "<X(t+1)>" "" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "CASPL_CP64_ldstexcl"
                 [("sz", BlockEq [I]), ("L", BlockEq [O]), ("o0", BlockEq [I])]
                 "CASPL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<X(s+1)>" "" Nothing,
                  Symbol "<Xt>" "Rt" Nothing, Symbol "<X(t+1)>" "" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/cas/pair" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\nif Rs<0> == '1' then UnallocatedEncoding();\nif Rt<0> == '1' then UnallocatedEncoding();\n\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\n\ninteger datasize = 32 << UInt(sz);\ninteger regsize = datasize;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;"])]
          [Ps "aarch64/instrs/memory/atomicops/cas/pair" (Just PsExecute)
             "bits(64) address;\nbits(2*datasize) comparevalue;\nbits(2*datasize) newvalue;\nbits(2*datasize) data;\n\nbits(datasize) s1 = X[s];\nbits(datasize) s2 = X[s+1];\nbits(datasize) t1 = X[t];\nbits(datasize) t2 = X[t+1];\ncomparevalue = if BigEndian() then s1:s2 else s2:s1;\nnewvalue     = if BigEndian() then t1:t2 else t2:t1;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, (2 * datasize) DIV 8, ldacctype];\nif data == comparevalue then\n    // All observers in the shareability domain observe the\n    // following load and store atomically.\n    Mem[address, (2 * datasize) DIV 8, stacctype] = newvalue;\n\nif BigEndian() then\n    X[s]   = ZeroExtend(data<2*datasize-1:datasize>, regsize);\n    X[s+1] = ZeroExtend(data<datasize-1:0>, regsize);\nelse\n    X[s]   = ZeroExtend(data<datasize-1:0>, regsize);\n    X[s+1] = ZeroExtend(data<2*datasize-1:datasize>, regsize);"]),
     Right
       (Page "CBNZ" []
          [(Class "br19" Nothing
              (Diagram "aarch64/instrs/branch/conditional/compare"
                 [Block (Just "sf") (BlockEq [X]),
                  Block Nothing (BlockEq [O, I, I, O, I, O]),
                  Block (Just "op") (BlockEq [I]),
                  Block (Just "imm19")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "CBNZ_32_compbranch" [("sf", BlockEq [O])]
                 "CBNZ  <Wt>, <label>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<label>" "imm19" Nothing],
               Encoding "CBNZ_64_compbranch" [("sf", BlockEq [I])]
                 "CBNZ  <Xt>, <label>"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<label>" "imm19" Nothing]],
            [Ps "aarch64/instrs/branch/conditional/compare" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean iszero = (op == '0');\nbits(64) offset = SignExtend(imm19:'00', 64);"])]
          [Ps "aarch64/instrs/branch/conditional/compare" (Just PsExecute)
             "bits(datasize) operand1 = X[t];\n\nif IsZero(operand1) == iszero then\n    BranchTo(PC[] + offset, BranchType_JMP);"]),
     Right
       (Page "CBZ" []
          [(Class "br19" Nothing
              (Diagram "aarch64/instrs/branch/conditional/compare"
                 [Block (Just "sf") (BlockEq [X]),
                  Block Nothing (BlockEq [O, I, I, O, I, O]),
                  Block (Just "op") (BlockEq [O]),
                  Block (Just "imm19")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "CBZ_32_compbranch" [("sf", BlockEq [O])]
                 "CBZ  <Wt>, <label>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<label>" "imm19" Nothing],
               Encoding "CBZ_64_compbranch" [("sf", BlockEq [I])]
                 "CBZ  <Xt>, <label>"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<label>" "imm19" Nothing]],
            [Ps "aarch64/instrs/branch/conditional/compare" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean iszero = (op == '0');\nbits(64) offset = SignExtend(imm19:'00', 64);"])]
          [Ps "aarch64/instrs/branch/conditional/compare" (Just PsExecute)
             "bits(datasize) operand1 = X[t];\n\nif IsZero(operand1) == iszero then\n    BranchTo(PC[] + offset, BranchType_JMP);"]),
     Right
       (Page "CCMN_imm" []
          [(Class "imm5u" Nothing
              (Diagram "aarch64/instrs/integer/conditional/compare/immediate"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, O, I, O, O, I, O]),
                  Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "o2") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "nzcv") (BlockEq [X, X, X, X])])
              [Encoding "CCMN_32_condcmp_imm" [("sf", BlockEq [O])]
                 "CCMN  <Wn>, #<imm>, #<nzcv>, <cond>"
                 [Symbol "<Wn>" "Rn" Nothing, Symbol "<imm>" "imm5" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "CCMN_64_condcmp_imm" [("sf", BlockEq [I])]
                 "CCMN  <Xn>, #<imm>, #<nzcv>, <cond>"
                 [Symbol "<Xn>" "Rn" Nothing, Symbol "<imm>" "imm5" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/integer/conditional/compare/immediate"
               (Just PsDecode)
               "integer n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\nbits(datasize) imm = ZeroExtend(imm5, datasize);"])]
          [Ps "aarch64/instrs/integer/conditional/compare/immediate"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"]),
     Right
       (Page "CCMN_reg" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/conditional/compare/register"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, O, I, O, O, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "nzcv") (BlockEq [X, X, X, X])])
              [Encoding "CCMN_32_condcmp_reg" [("sf", BlockEq [O])]
                 "CCMN  <Wn>, <Wm>, #<nzcv>, <cond>"
                 [Symbol "<Wn>" "Rn" Nothing, Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "CCMN_64_condcmp_reg" [("sf", BlockEq [I])]
                 "CCMN  <Xn>, <Xm>, #<nzcv>, <cond>"
                 [Symbol "<Xn>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/integer/conditional/compare/register"
               (Just PsDecode)
               "integer n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;"])]
          [Ps "aarch64/instrs/integer/conditional/compare/register"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"]),
     Right
       (Page "CCMP_imm" []
          [(Class "imm5u" Nothing
              (Diagram "aarch64/instrs/integer/conditional/compare/immediate"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, O, I, O, O, I, O]),
                  Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "o2") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "nzcv") (BlockEq [X, X, X, X])])
              [Encoding "CCMP_32_condcmp_imm" [("sf", BlockEq [O])]
                 "CCMP  <Wn>, #<imm>, #<nzcv>, <cond>"
                 [Symbol "<Wn>" "Rn" Nothing, Symbol "<imm>" "imm5" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "CCMP_64_condcmp_imm" [("sf", BlockEq [I])]
                 "CCMP  <Xn>, #<imm>, #<nzcv>, <cond>"
                 [Symbol "<Xn>" "Rn" Nothing, Symbol "<imm>" "imm5" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/integer/conditional/compare/immediate"
               (Just PsDecode)
               "integer n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\nbits(datasize) imm = ZeroExtend(imm5, datasize);"])]
          [Ps "aarch64/instrs/integer/conditional/compare/immediate"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"]),
     Right
       (Page "CCMP_reg" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/conditional/compare/register"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, O, I, O, O, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "nzcv") (BlockEq [X, X, X, X])])
              [Encoding "CCMP_32_condcmp_reg" [("sf", BlockEq [O])]
                 "CCMP  <Wn>, <Wm>, #<nzcv>, <cond>"
                 [Symbol "<Wn>" "Rn" Nothing, Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "CCMP_64_condcmp_reg" [("sf", BlockEq [I])]
                 "CCMP  <Xn>, <Xm>, #<nzcv>, <cond>"
                 [Symbol "<Xn>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/integer/conditional/compare/register"
               (Just PsDecode)
               "integer n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;"])]
          [Ps "aarch64/instrs/integer/conditional/compare/register"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbit carry_in = '0';\n\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nPSTATE.<N,Z,C,V> = flags;"]),
     Left
       (AliasPage "CINC_CSINC" "CSINC"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/conditional/select"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                 Block (Just "Rm") (BlockNeq [I, I, I, I, I]),
                 Block (Just "cond") (BlockNeq [I, I, I, X]),
                 Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                 Block (Just "Rn") (BlockNeq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "CINC_CSINC_32_condsel" [("sf", BlockEq [O])]
                "CINC  <Wd>, <Wn>, <cond>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rm:Rn" Nothing,
                 Symbol "<cond>" "cond" Nothing],
              Encoding "CINC_CSINC_64_condsel" [("sf", BlockEq [I])]
                "CINC  <Xd>, <Xn>, <cond>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rm:Rn" Nothing,
                 Symbol "<cond>" "cond" Nothing]])),
     Left
       (AliasPage "CINV_CSINV" "CSINV"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/conditional/select"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                 Block (Just "Rm") (BlockNeq [I, I, I, I, I]),
                 Block (Just "cond") (BlockNeq [I, I, I, X]),
                 Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                 Block (Just "Rn") (BlockNeq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "CINV_CSINV_32_condsel" [("sf", BlockEq [O])]
                "CINV  <Wd>, <Wn>, <cond>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rm:Rn" Nothing,
                 Symbol "<cond>" "cond" Nothing],
              Encoding "CINV_CSINV_64_condsel" [("sf", BlockEq [I])]
                "CINV  <Xd>, <Xn>, <cond>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rm:Rn" Nothing,
                 Symbol "<cond>" "cond" Nothing]])),
     Right
       (Page "CLREX" []
          [(Class "CLREX_BN_system" Nothing
              (Diagram "aarch64/instrs/system/monitors"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, I]),
                  Block (Just "CRm") (BlockEq [X, X, X, X]),
                  Block (Just "op2") (BlockEq [O, I, O]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "CLREX_BN_system" [] "CLREX  {#<imm>}"
                 [Symbol "<imm>" "CRm" Nothing]],
            [Ps "aarch64/instrs/system/monitors" (Just PsDecode)
               "// CRm field is ignored"])]
          [Ps "aarch64/instrs/system/monitors" (Just PsExecute)
             "ClearExclusiveLocal(ProcessorID());"]),
     Right
       (Page "CLS_int" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/cnt"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode[5:1]") (BlockEq [O, O, O, I, O]),
                  Block (Just "op") (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CLS_32_dp_1src" [("sf", BlockEq [O])] "CLS  <Wd>, <Wn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "CLS_64_dp_1src" [("sf", BlockEq [I])] "CLS  <Xd>, <Xn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/cnt" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nCountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;"])]
          [Ps "aarch64/instrs/integer/arithmetic/cnt" (Just PsExecute)
             "integer result;\nbits(datasize) operand1 = X[n];\n\nif opcode == CountOp_CLZ then\n    result = CountLeadingZeroBits(operand1);\nelse\n    result = CountLeadingSignBits(operand1);\n\nX[d] = result<datasize-1:0>;"]),
     Right
       (Page "CLZ_int" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/cnt"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode[5:1]") (BlockEq [O, O, O, I, O]),
                  Block (Just "op") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CLZ_32_dp_1src" [("sf", BlockEq [O])] "CLZ  <Wd>, <Wn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "CLZ_64_dp_1src" [("sf", BlockEq [I])] "CLZ  <Xd>, <Xn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/cnt" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nCountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;"])]
          [Ps "aarch64/instrs/integer/arithmetic/cnt" (Just PsExecute)
             "integer result;\nbits(datasize) operand1 = X[n];\n\nif opcode == CountOp_CLZ then\n    result = CountLeadingZeroBits(operand1);\nelse\n    result = CountLeadingSignBits(operand1);\n\nX[d] = result<datasize-1:0>;"]),
     Left
       (AliasPage "CMN_ADDS_addsub_ext" "ADDS_addsub_ext"
          (Class "s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                 Block (Just "S") (BlockEq [I]),
                 Block Nothing (BlockEq [O, I, O, I, I]),
                 Block (Just "opt") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "option") (BlockEq [X, X, X]),
                 Block (Just "imm3") (BlockEq [X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [I, I, I, I, I])])
             [Encoding "CMN_ADDS_32S_addsub_ext" [("sf", BlockEq [O])]
                "CMN  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"
                [Symbol "<Wn|WSP>" "Rn" Nothing, Symbol "<Wm>" "Rm" Nothing,
                 Symbol "<extend>" "option"
                   (Just
                      (Table ["option"]
                         [TableRow "UXTB" [[O, O, O]] Nothing,
                          TableRow "UXTH" [[O, O, I]] Nothing,
                          TableRow "LSL|UXTW" [[O, I, O]] Nothing,
                          TableRow "UXTX" [[O, I, I]] Nothing,
                          TableRow "SXTB" [[I, O, O]] Nothing,
                          TableRow "SXTH" [[I, O, I]] Nothing,
                          TableRow "SXTW" [[I, I, O]] Nothing,
                          TableRow "SXTX" [[I, I, I]] Nothing])),
                 Symbol "<amount>" "imm3" Nothing],
              Encoding "CMN_ADDS_64S_addsub_ext" [("sf", BlockEq [I])]
                "CMN  <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
                [Symbol "<Xn|SP>" "Rn" Nothing,
                 Symbol "<R>" "option"
                   (Just
                      (Table ["option"]
                         [TableRow "W" [[O, O, X]] Nothing,
                          TableRow "W" [[O, I, O]] Nothing, TableRow "X" [[X, I, I]] Nothing,
                          TableRow "W" [[I, O, X]] Nothing,
                          TableRow "W" [[I, I, O]] Nothing])),
                 Symbol "<m>" "Rm" Nothing,
                 Symbol "<extend>" "option"
                   (Just
                      (Table ["option"]
                         [TableRow "UXTB" [[O, O, O]] Nothing,
                          TableRow "UXTH" [[O, O, I]] Nothing,
                          TableRow "UXTW" [[O, I, O]] Nothing,
                          TableRow "LSL|UXTX" [[O, I, I]] Nothing,
                          TableRow "SXTB" [[I, O, O]] Nothing,
                          TableRow "SXTH" [[I, O, I]] Nothing,
                          TableRow "SXTW" [[I, I, O]] Nothing,
                          TableRow "SXTX" [[I, I, I]] Nothing])),
                 Symbol "<amount>" "imm3" Nothing]])),
     Left
       (AliasPage "CMN_ADDS_addsub_imm" "ADDS_addsub_imm"
          (Class "s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/immediate"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                 Block (Just "S") (BlockEq [I]),
                 Block Nothing (BlockEq [I, O, O, O, I]),
                 Block (Just "shift") (BlockEq [X, X]),
                 Block (Just "imm12")
                   (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [I, I, I, I, I])])
             [Encoding "CMN_ADDS_32S_addsub_imm" [("sf", BlockEq [O])]
                "CMN  <Wn|WSP>, #<imm>{, <shift>}"
                [Symbol "<Wn|WSP>" "Rn" Nothing, Symbol "<imm>" "imm12" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL #0" [[O, O]] Nothing,
                          TableRow "LSL #12" [[O, I]] Nothing,
                          TableRow "RESERVED" [[I, X]] Nothing]))],
              Encoding "CMN_ADDS_64S_addsub_imm" [("sf", BlockEq [I])]
                "CMN  <Xn|SP>, #<imm>{, <shift>}"
                [Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm12" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL #0" [[O, O]] Nothing,
                          TableRow "LSL #12" [[O, I]] Nothing,
                          TableRow "RESERVED" [[I, X]] Nothing]))]])),
     Left
       (AliasPage "CMN_ADDS_addsub_shift" "ADDS_addsub_shift"
          (Class "s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                 Block (Just "S") (BlockEq [I]),
                 Block Nothing (BlockEq [O, I, O, I, I]),
                 Block (Just "shift") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [I, I, I, I, I])])
             [Encoding "CMN_ADDS_32_addsub_shift" [("sf", BlockEq [O])]
                "CMN  <Wn>, <Wm>{, <shift> #<amount>}"
                [Symbol "<Wn>" "Rn" Nothing, Symbol "<Wm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "RESERVED" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing],
              Encoding "CMN_ADDS_64_addsub_shift" [("sf", BlockEq [I])]
                "CMN  <Xn>, <Xm>{, <shift> #<amount>}"
                [Symbol "<Xn>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "RESERVED" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing]])),
     Left
       (AliasPage "CMP_SUBS_addsub_ext" "SUBS_addsub_ext"
          (Class "s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                 Block (Just "S") (BlockEq [I]),
                 Block Nothing (BlockEq [O, I, O, I, I]),
                 Block (Just "opt") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "option") (BlockEq [X, X, X]),
                 Block (Just "imm3") (BlockEq [X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [I, I, I, I, I])])
             [Encoding "CMP_SUBS_32S_addsub_ext" [("sf", BlockEq [O])]
                "CMP  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"
                [Symbol "<Wn|WSP>" "Rn" Nothing, Symbol "<Wm>" "Rm" Nothing,
                 Symbol "<extend>" "option"
                   (Just
                      (Table ["option"]
                         [TableRow "UXTB" [[O, O, O]] Nothing,
                          TableRow "UXTH" [[O, O, I]] Nothing,
                          TableRow "LSL|UXTW" [[O, I, O]] Nothing,
                          TableRow "UXTX" [[O, I, I]] Nothing,
                          TableRow "SXTB" [[I, O, O]] Nothing,
                          TableRow "SXTH" [[I, O, I]] Nothing,
                          TableRow "SXTW" [[I, I, O]] Nothing,
                          TableRow "SXTX" [[I, I, I]] Nothing])),
                 Symbol "<amount>" "imm3" Nothing],
              Encoding "CMP_SUBS_64S_addsub_ext" [("sf", BlockEq [I])]
                "CMP  <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
                [Symbol "<Xn|SP>" "Rn" Nothing,
                 Symbol "<R>" "option"
                   (Just
                      (Table ["option"]
                         [TableRow "W" [[O, O, X]] Nothing,
                          TableRow "W" [[O, I, O]] Nothing, TableRow "X" [[X, I, I]] Nothing,
                          TableRow "W" [[I, O, X]] Nothing,
                          TableRow "W" [[I, I, O]] Nothing])),
                 Symbol "<m>" "Rm" Nothing,
                 Symbol "<extend>" "option"
                   (Just
                      (Table ["option"]
                         [TableRow "UXTB" [[O, O, O]] Nothing,
                          TableRow "UXTH" [[O, O, I]] Nothing,
                          TableRow "UXTW" [[O, I, O]] Nothing,
                          TableRow "LSL|UXTX" [[O, I, I]] Nothing,
                          TableRow "SXTB" [[I, O, O]] Nothing,
                          TableRow "SXTH" [[I, O, I]] Nothing,
                          TableRow "SXTW" [[I, I, O]] Nothing,
                          TableRow "SXTX" [[I, I, I]] Nothing])),
                 Symbol "<amount>" "imm3" Nothing]])),
     Left
       (AliasPage "CMP_SUBS_addsub_imm" "SUBS_addsub_imm"
          (Class "s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/immediate"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                 Block (Just "S") (BlockEq [I]),
                 Block Nothing (BlockEq [I, O, O, O, I]),
                 Block (Just "shift") (BlockEq [X, X]),
                 Block (Just "imm12")
                   (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [I, I, I, I, I])])
             [Encoding "CMP_SUBS_32S_addsub_imm" [("sf", BlockEq [O])]
                "CMP  <Wn|WSP>, #<imm>{, <shift>}"
                [Symbol "<Wn|WSP>" "Rn" Nothing, Symbol "<imm>" "imm12" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL #0" [[O, O]] Nothing,
                          TableRow "LSL #12" [[O, I]] Nothing,
                          TableRow "RESERVED" [[I, X]] Nothing]))],
              Encoding "CMP_SUBS_64S_addsub_imm" [("sf", BlockEq [I])]
                "CMP  <Xn|SP>, #<imm>{, <shift>}"
                [Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm12" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL #0" [[O, O]] Nothing,
                          TableRow "LSL #12" [[O, I]] Nothing,
                          TableRow "RESERVED" [[I, X]] Nothing]))]])),
     Left
       (AliasPage "CMP_SUBS_addsub_shift" "SUBS_addsub_shift"
          (Class "s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                 Block (Just "S") (BlockEq [I]),
                 Block Nothing (BlockEq [O, I, O, I, I]),
                 Block (Just "shift") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [I, I, I, I, I])])
             [Encoding "CMP_SUBS_32_addsub_shift" [("sf", BlockEq [O])]
                "CMP  <Wn>, <Wm>{, <shift> #<amount>}"
                [Symbol "<Wn>" "Rn" Nothing, Symbol "<Wm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "RESERVED" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing],
              Encoding "CMP_SUBS_64_addsub_shift" [("sf", BlockEq [I])]
                "CMP  <Xn>, <Xm>{, <shift> #<amount>}"
                [Symbol "<Xn>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "RESERVED" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing]])),
     Left
       (AliasPage "CNEG_CSNEG" "CSNEG"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/conditional/select"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "cond") (BlockNeq [I, I, I, X]),
                 Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "CNEG_CSNEG_32_condsel" [("sf", BlockEq [O])]
                "CNEG  <Wd>, <Wn>, <cond>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rm:Rn" Nothing,
                 Symbol "<cond>" "cond" Nothing],
              Encoding "CNEG_CSNEG_64_condsel" [("sf", BlockEq [I])]
                "CNEG  <Xd>, <Xn>, <cond>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rm:Rn" Nothing,
                 Symbol "<cond>" "cond" Nothing]])),
     Right
       (Page "CRC32" []
          [(Class "crc" Nothing
              (Diagram "aarch64/instrs/integer/crc"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2<5:3>") (BlockEq [O, I, O]),
                  Block (Just "C") (BlockEq [O]), Block (Just "sz") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CRC32B_32C_dp_2src"
                 [("sf", BlockEq [O]), ("sz", BlockEq [O, O])]
                 "CRC32B  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "CRC32H_32C_dp_2src"
                 [("sf", BlockEq [O]), ("sz", BlockEq [O, I])]
                 "CRC32H  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "CRC32W_32C_dp_2src"
                 [("sf", BlockEq [O]), ("sz", BlockEq [I, O])]
                 "CRC32W  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "CRC32X_64C_dp_2src"
                 [("sf", BlockEq [I]), ("sz", BlockEq [I, I])]
                 "CRC32X  <Wd>, <Wn>, <Xm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/crc" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sf == '1' && sz != '11' then UnallocatedEncoding();\nif sf == '0' && sz == '11' then UnallocatedEncoding();\ninteger size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64\nboolean crc32c = (C == '1');"])]
          [Ps "aarch64/instrs/integer/crc" (Just PsExecute)
             "if !HaveCRCExt() then\n    UnallocatedEncoding();\n\nbits(32)      acc     = X[n];   // accumulator\nbits(size)    val     = X[m];   // input value\nbits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\n\nbits(32+size) tempacc = BitReverse(acc) : Zeros(size);\nbits(size+32) tempval = BitReverse(val) : Zeros(32);\n\n// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation\nX[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));"]),
     Right
       (Page "CRC32C" []
          [(Class "crc" Nothing
              (Diagram "aarch64/instrs/integer/crc"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2<5:3>") (BlockEq [O, I, O]),
                  Block (Just "C") (BlockEq [I]), Block (Just "sz") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CRC32CB_32C_dp_2src"
                 [("sf", BlockEq [O]), ("sz", BlockEq [O, O])]
                 "CRC32CB  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "CRC32CH_32C_dp_2src"
                 [("sf", BlockEq [O]), ("sz", BlockEq [O, I])]
                 "CRC32CH  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "CRC32CW_32C_dp_2src"
                 [("sf", BlockEq [O]), ("sz", BlockEq [I, O])]
                 "CRC32CW  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "CRC32CX_64C_dp_2src"
                 [("sf", BlockEq [I]), ("sz", BlockEq [I, I])]
                 "CRC32CX  <Wd>, <Wn>, <Xm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/crc" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sf == '1' && sz != '11' then UnallocatedEncoding();\nif sf == '0' && sz == '11' then UnallocatedEncoding();\ninteger size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64\nboolean crc32c = (C == '1');"])]
          [Ps "aarch64/instrs/integer/crc" (Just PsExecute)
             "if !HaveCRCExt() then\n    UnallocatedEncoding();\n\nbits(32)      acc     = X[n];   // accumulator\nbits(size)    val     = X[m];   // input value\nbits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\n\nbits(32+size) tempacc = BitReverse(acc) : Zeros(size);\nbits(size+32) tempval = BitReverse(val) : Zeros(32);\n\n// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation\nX[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));"]),
     Right
       (Page "CSEL" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/conditional/select"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CSEL_32_condsel" [("sf", BlockEq [O])]
                 "CSEL  <Wd>, <Wn>, <Wm>, <cond>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "CSEL_64_condsel" [("sf", BlockEq [I])]
                 "CSEL  <Xd>, <Xn>, <Xm>, <cond>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/integer/conditional/select" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');"])]
          [Ps "aarch64/instrs/integer/conditional/select" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"]),
     Left
       (AliasPage "CSET_CSINC" "CSINC"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/conditional/select"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                 Block (Just "Rm") (BlockEq [I, I, I, I, I]),
                 Block (Just "cond") (BlockNeq [I, I, I, X]),
                 Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                 Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "CSET_CSINC_32_condsel" [("sf", BlockEq [O])]
                "CSET  <Wd>, <cond>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<cond>" "cond" Nothing],
              Encoding "CSET_CSINC_64_condsel" [("sf", BlockEq [I])]
                "CSET  <Xd>, <cond>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<cond>" "cond" Nothing]])),
     Left
       (AliasPage "CSETM_CSINV" "CSINV"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/conditional/select"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                 Block (Just "Rm") (BlockEq [I, I, I, I, I]),
                 Block (Just "cond") (BlockNeq [I, I, I, X]),
                 Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                 Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "CSETM_CSINV_32_condsel" [("sf", BlockEq [O])]
                "CSETM  <Wd>, <cond>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<cond>" "cond" Nothing],
              Encoding "CSETM_CSINV_64_condsel" [("sf", BlockEq [I])]
                "CSETM  <Xd>, <cond>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<cond>" "cond" Nothing]])),
     Right
       (Page "CSINC" ["CINC_CSINC", "CSET_CSINC"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/conditional/select"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CSINC_32_condsel" [("sf", BlockEq [O])]
                 "CSINC  <Wd>, <Wn>, <Wm>, <cond>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "CSINC_64_condsel" [("sf", BlockEq [I])]
                 "CSINC  <Xd>, <Xn>, <Xm>, <cond>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/integer/conditional/select" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');"])]
          [Ps "aarch64/instrs/integer/conditional/select" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"]),
     Right
       (Page "CSINV" ["CINV_CSINV", "CSETM_CSINV"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/conditional/select"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CSINV_32_condsel" [("sf", BlockEq [O])]
                 "CSINV  <Wd>, <Wn>, <Wm>, <cond>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "CSINV_64_condsel" [("sf", BlockEq [I])]
                 "CSINV  <Xd>, <Xn>, <Xm>, <cond>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/integer/conditional/select" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');"])]
          [Ps "aarch64/instrs/integer/conditional/select" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"]),
     Right
       (Page "CSNEG" ["CNEG_CSNEG"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/conditional/select"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CSNEG_32_condsel" [("sf", BlockEq [O])]
                 "CSNEG  <Wd>, <Wn>, <Wm>, <cond>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "CSNEG_64_condsel" [("sf", BlockEq [I])]
                 "CSNEG  <Xd>, <Xn>, <Xm>, <cond>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/integer/conditional/select" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');"])]
          [Ps "aarch64/instrs/integer/conditional/select" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\n\nX[d] = result;"]),
     Left
       (AliasPage "DC_SYS" "SYS"
          (Class "SYS_CR_system" Nothing
             (Diagram "aarch64/instrs/system/sysops"
                [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                 Block (Just "L") (BlockEq [O]),
                 Block (Just "op0") (BlockEq [O, I]),
                 Block (Just "op1") (BlockEq [X, X, X]),
                 Block (Just "CRn") (BlockEq [O, I, I, I]),
                 Block (Just "CRm") (BlockEq [X, X, X, X]),
                 Block (Just "op2") (BlockEq [X, X, X]),
                 Block (Just "Rt") (BlockEq [X, X, X, X, X])])
             [Encoding "DC_SYS_CR_system" [] "DC  <dc_op>, <Xt>"
                [Symbol "<dc_op>" "op1:CRm:op2"
                   (Just
                      (Table ["op2", "CRm", "op1"]
                         [TableRow "IVAC" [[O, O, I], [O, I, I, O], [O, O, O]] Nothing,
                          TableRow "ISW" [[O, I, O], [O, I, I, O], [O, O, O]] Nothing,
                          TableRow "CSW" [[O, I, O], [I, O, I, O], [O, O, O]] Nothing,
                          TableRow "CISW" [[O, I, O], [I, I, I, O], [O, O, O]] Nothing,
                          TableRow "ZVA" [[O, O, I], [O, I, O, O], [O, I, I]] Nothing,
                          TableRow "CVAC" [[O, O, I], [I, O, I, O], [O, I, I]] Nothing,
                          TableRow "CVAU" [[O, O, I], [I, O, I, I], [O, I, I]] Nothing,
                          TableRow "CVAP" [[O, O, I], [I, I, O, O], [O, I, I]]
                            (Just (ArchFeature "ARMv8.2-DCPoP")),
                          TableRow "CIVAC" [[O, O, I], [I, I, I, O], [O, I, I]] Nothing])),
                 Symbol "<op1>" "op1" Nothing, Symbol "<Cm>" "CRm" Nothing,
                 Symbol "<op2>" "op2" Nothing, Symbol "<Xt>" "Rt" Nothing]])),
     Right
       (Page "DCPS1" []
          [(Class "DCPS1_DC_exception" Nothing
              (Diagram "aarch64/instrs/system/exceptions/debug/exception"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "opc") (BlockEq [I, O, I]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "op2") (BlockEq [O, O, O]),
                  Block (Just "LL") (BlockEq [O, I])])
              [Encoding "DCPS1_DC_exception" [] "DCPS1  {#<imm>}"
                 [Symbol "<imm>" "imm16" Nothing]],
            [Ps "aarch64/instrs/system/exceptions/debug/exception"
               (Just PsDecode)
               "bits(2) target_level = LL;\nif LL == '00' then UnallocatedEncoding();\nif !Halted() then AArch64.UndefinedFault();"])]
          [Ps "aarch64/instrs/system/exceptions/debug/exception"
             (Just PsExecute)
             "DCPSInstruction(target_level);"]),
     Right
       (Page "DCPS2" []
          [(Class "DCPS2_DC_exception" Nothing
              (Diagram "aarch64/instrs/system/exceptions/debug/exception"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "opc") (BlockEq [I, O, I]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "op2") (BlockEq [O, O, O]),
                  Block (Just "LL") (BlockEq [I, O])])
              [Encoding "DCPS2_DC_exception" [] "DCPS2  {#<imm>}"
                 [Symbol "<imm>" "imm16" Nothing]],
            [Ps "aarch64/instrs/system/exceptions/debug/exception"
               (Just PsDecode)
               "bits(2) target_level = LL;\nif LL == '00' then UnallocatedEncoding();\nif !Halted() then AArch64.UndefinedFault();"])]
          [Ps "aarch64/instrs/system/exceptions/debug/exception"
             (Just PsExecute)
             "DCPSInstruction(target_level);"]),
     Right
       (Page "DCPS3" []
          [(Class "DCPS3_DC_exception" Nothing
              (Diagram "aarch64/instrs/system/exceptions/debug/exception"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "opc") (BlockEq [I, O, I]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "op2") (BlockEq [O, O, O]),
                  Block (Just "LL") (BlockEq [I, I])])
              [Encoding "DCPS3_DC_exception" [] "DCPS3  {#<imm>}"
                 [Symbol "<imm>" "imm16" Nothing]],
            [Ps "aarch64/instrs/system/exceptions/debug/exception"
               (Just PsDecode)
               "bits(2) target_level = LL;\nif LL == '00' then UnallocatedEncoding();\nif !Halted() then AArch64.UndefinedFault();"])]
          [Ps "aarch64/instrs/system/exceptions/debug/exception"
             (Just PsExecute)
             "DCPSInstruction(target_level);"]),
     Right
       (Page "DMB" []
          [(Class "DMB_BO_system" Nothing
              (Diagram "aarch64/instrs/system/barriers"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, I]),
                  Block (Just "CRm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "opc") (BlockEq [O, I]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "DMB_BO_system" [] "DMB  <option>|#<imm>"
                 [Symbol "<option>" "" Nothing, Symbol "<imm>" "CRm" Nothing]],
            [Ps "aarch64/instrs/system/barriers" (Just PsDecode)
               "MemBarrierOp op;\nMBReqDomain domain;\nMBReqTypes types;\n\ncase opc of\n    when '00' op = MemBarrierOp_DSB;\n    when '01' op = MemBarrierOp_DMB;\n    when '10' op = MemBarrierOp_ISB;\n    otherwise UnallocatedEncoding();\n\ncase CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable;\n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\n\ncase CRm<1:0> of\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;\n    otherwise\n        types = MBReqTypes_All;\n        domain = MBReqDomain_FullSystem;"])]
          [Ps "aarch64/instrs/system/barriers" (Just PsExecute)
             "case op of\n    when MemBarrierOp_DSB\n        DataSynchronizationBarrier(domain, types);\n    when MemBarrierOp_DMB\n        DataMemoryBarrier(domain, types);\n    when MemBarrierOp_ISB\n        InstructionSynchronizationBarrier();"]),
     Right
       (Page "DRPS" []
          [(Class "DRPS_64E_branch_reg" Nothing
              (Diagram "aarch64/instrs/branch/unconditional/dret"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, I]),
                  Block (Just "opc") (BlockEq [O, I, O, I]),
                  Block (Just "op2") (BlockEq [I, I, I, I, I]),
                  Block (Just "op3") (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I]),
                  Block (Just "op4") (BlockEq [O, O, O, O, O])])
              [Encoding "DRPS_64E_branch_reg" [] "DRPS" []],
            [Ps "aarch64/instrs/branch/unconditional/dret" (Just PsDecode)
               "if !Halted() || PSTATE.EL == EL0 then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/branch/unconditional/dret" (Just PsExecute)
             "DRPSInstruction();"]),
     Right
       (Page "DSB" []
          [(Class "DSB_BO_system" Nothing
              (Diagram "aarch64/instrs/system/barriers"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, I]),
                  Block (Just "CRm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "opc") (BlockEq [O, O]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "DSB_BO_system" [] "DSB  <option>|#<imm>"
                 [Symbol "<option>" "" Nothing, Symbol "<imm>" "CRm" Nothing]],
            [Ps "aarch64/instrs/system/barriers" (Just PsDecode)
               "MemBarrierOp op;\nMBReqDomain domain;\nMBReqTypes types;\n\ncase opc of\n    when '00' op = MemBarrierOp_DSB;\n    when '01' op = MemBarrierOp_DMB;\n    when '10' op = MemBarrierOp_ISB;\n    otherwise UnallocatedEncoding();\n\ncase CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable;\n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\n\ncase CRm<1:0> of\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;\n    otherwise\n        types = MBReqTypes_All;\n        domain = MBReqDomain_FullSystem;"])]
          [Ps "aarch64/instrs/system/barriers" (Just PsExecute)
             "case op of\n    when MemBarrierOp_DSB\n        DataSynchronizationBarrier(domain, types);\n    when MemBarrierOp_DMB\n        DataMemoryBarrier(domain, types);\n    when MemBarrierOp_ISB\n        InstructionSynchronizationBarrier();"]),
     Right
       (Page "EON" []
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [I, O]),
                  Block Nothing (BlockEq [O, I, O, I, O]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "N") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "EON_32_log_shift" [("sf", BlockEq [O])]
                 "EON  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "EON_64_log_shift" [("sf", BlockEq [I])]
                 "EON  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');"])]
          [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"]),
     Right
       (Page "EOR_log_imm" []
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/logical/immediate"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, O, O, I, O, O]),
                  Block (Just "N") (BlockEq [X]),
                  Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "EOR_32_log_imm"
                 [("sf", BlockEq [O]), ("N", BlockEq [O])]
                 "EOR  <Wd|WSP>, <Wn>, #<imm>"
                 [Symbol "<Wd|WSP>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<imm>" "immr:imms" Nothing],
               Encoding "EOR_64_log_imm" [("sf", BlockEq [I])]
                 "EOR  <Xd|SP>, <Xn>, #<imm>"
                 [Symbol "<Xd|SP>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<imm>" "N:immr:imms" Nothing]],
            [Ps "aarch64/instrs/integer/logical/immediate" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);"])]
          [Ps "aarch64/instrs/integer/logical/immediate" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "EOR_log_shift" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [I, O]),
                  Block Nothing (BlockEq [O, I, O, I, O]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "N") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "EOR_32_log_shift" [("sf", BlockEq [O])]
                 "EOR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "EOR_64_log_shift" [("sf", BlockEq [I])]
                 "EOR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');"])]
          [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"]),
     Right
       (Page "ERET" []
          [(Class "ERET_64E_branch_reg" Nothing
              (Diagram "aarch64/instrs/branch/unconditional/eret"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, I]),
                  Block (Just "opc[3]") (BlockEq [O]),
                  Block (Just "opc[2:0]") (BlockEq [I, O, O]),
                  Block (Just "op2") (BlockEq [I, I, I, I, I]),
                  Block (Just "op3[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "A") (BlockEq [O]), Block (Just "M") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                  Block (Just "op4") (BlockEq [O, O, O, O, O])])
              [Encoding "ERET_64E_branch_reg" [] "ERET" []],
            [Ps "aarch64/instrs/branch/unconditional/eret" (Just PsDecode)
               "if PSTATE.EL == EL0 then UnallocatedEncoding();\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\n\nif !pac && op4 != '00000' then\n    UnallocatedEncoding();\nelsif pac && (!HavePACExt() || op4 != '11111') then\n    UnallocatedEncoding();\n\nif Rn != '11111' then \n    UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/branch/unconditional/eret" (Just PsExecute)
             "AArch64.CheckForERetTrap(pac, use_key_a);\nbits(64) target = ELR[];\n\nif pac then\n    if use_key_a then\n        target = AuthIA(ELR[], SP[]);\n    else\n        target = AuthIB(ELR[], SP[]);\n\nAArch64.ExceptionReturn(target, SPSR[]);"]),
     Right
       (Page "ERETA" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/branch/unconditional/eret"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, I]),
                  Block (Just "opc[3]") (BlockEq [O]),
                  Block (Just "opc[2:0]") (BlockEq [I, O, O]),
                  Block (Just "op2") (BlockEq [I, I, I, I, I]),
                  Block (Just "op3[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "A") (BlockEq [I]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                  Block (Just "op4") (BlockEq [I, I, I, I, I])])
              [Encoding "ERETAA_64E_branch_reg" [("M", BlockEq [O])] "ERETAA" [],
               Encoding "ERETAB_64E_branch_reg" [("M", BlockEq [I])] "ERETAB" []],
            [Ps "aarch64/instrs/branch/unconditional/eret" (Just PsDecode)
               "if PSTATE.EL == EL0 then UnallocatedEncoding();\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\n\nif !pac && op4 != '00000' then\n    UnallocatedEncoding();\nelsif pac && (!HavePACExt() || op4 != '11111') then\n    UnallocatedEncoding();\n\nif Rn != '11111' then \n    UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/branch/unconditional/eret" (Just PsExecute)
             "AArch64.CheckForERetTrap(pac, use_key_a);\nbits(64) target = ELR[];\n\nif pac then\n    if use_key_a then\n        target = AuthIA(ELR[], SP[]);\n    else\n        target = AuthIB(ELR[], SP[]);\n\nAArch64.ExceptionReturn(target, SPSR[]);"]),
     Right
       (Page "ESB" []
          [(Class "ESB_HI_system" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/system/hints"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, I, O]),
                  Block (Just "op2") (BlockEq [O, O, O]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "ESB_HI_system" [] "ESB" []],
            [Ps "aarch64/instrs/system/hints" (Just PsDecode)
               "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 111'\n        SEE \"XPACLRI\";\n    when '0001 xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0011 xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                // Instruction executes as NOP"])]
          [Ps "aarch64/instrs/system/hints" (Just PsExecute)
             "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"]),
     Right
       (Page "EXTR" ["ROR_EXTR"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/ins-ext/extract/immediate"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "op21") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, O, I, I, I]),
                  Block (Just "N") (BlockEq [X]), Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "EXTR_32_extract"
                 [("sf", BlockEq [O]), ("N", BlockEq [O]),
                  ("imms", BlockEq [O, X, X, X, X, X])]
                 "EXTR  <Wd>, <Wn>, <Wm>, #<lsb>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<lsb>" "imms" Nothing],
               Encoding "EXTR_64_extract"
                 [("sf", BlockEq [I]), ("N", BlockEq [I])]
                 "EXTR  <Xd>, <Xn>, <Xm>, #<lsb>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<lsb>" "imms" Nothing]],
            [Ps "aarch64/instrs/integer/ins-ext/extract/immediate"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\ninteger lsb;\n\nif N != sf then UnallocatedEncoding();\nif sf == '0' && imms<5> == '1' then ReservedValue();\nlsb = UInt(imms);"])]
          [Ps "aarch64/instrs/integer/ins-ext/extract/immediate"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(2*datasize) concat = operand1:operand2;\n\nresult = concat<lsb+datasize-1:lsb>;\n\nX[d] = result;"]),
     Right
       (Page "HINT" []
          [(Class "system" Nothing
              (Diagram "aarch64/instrs/system/hints"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [X, X, X, X]),
                  Block (Just "op2") (BlockEq [X, X, X]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "HINT_1"
                 [("CRm", BlockEq [O, O, O, O]), ("op2", BlockEq [I, I, X])]
                 "HINT  #<imm>"
                 [Symbol "<imm>" "CRm:op2" Nothing],
               Encoding "HINT_2" [("CRm", BlockNeq [O, O, X, O])] "HINT  #<imm>"
                 [Symbol "<imm>" "CRm:op2" Nothing],
               Encoding "HINT_3"
                 [("CRm", BlockEq [O, O, I, O]), ("op2", BlockNeq [O, O, X])]
                 "HINT  #<imm>"
                 [Symbol "<imm>" "CRm:op2" Nothing]],
            [Ps "aarch64/instrs/system/hints" (Just PsDecode)
               "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 111'\n        SEE \"XPACLRI\";\n    when '0001 xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0011 xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                // Instruction executes as NOP"])]
          [Ps "aarch64/instrs/system/hints" (Just PsExecute)
             "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"]),
     Right
       (Page "HLT" []
          [(Class "HLT_EX_exception" Nothing
              (Diagram "aarch64/instrs/system/exceptions/debug/halt"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "opc") (BlockEq [O, I, O]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "op2") (BlockEq [O, O, O]),
                  Block (Just "LL") (BlockEq [O, O])])
              [Encoding "HLT_EX_exception" [] "HLT  #<imm>"
                 [Symbol "<imm>" "imm16" Nothing]],
            [Ps "aarch64/instrs/system/exceptions/debug/halt" (Just PsDecode)
               "if EDSCR.HDE == '0' || !HaltingAllowed() then UndefinedFault();"])]
          [Ps "aarch64/instrs/system/exceptions/debug/halt" (Just PsExecute)
             "Halt(DebugHalt_HaltInstruction);"]),
     Right
       (Page "HVC" []
          [(Class "HVC_EX_exception" Nothing
              (Diagram "aarch64/instrs/system/exceptions/runtime/hvc"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "opc") (BlockEq [O, O, O]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "op2") (BlockEq [O, O, O]),
                  Block (Just "LL") (BlockEq [I, O])])
              [Encoding "HVC_EX_exception" [] "HVC  #<imm>"
                 [Symbol "<imm>" "imm16" Nothing]],
            [Ps "aarch64/instrs/system/exceptions/runtime/hvc" (Just PsDecode)
               "bits(16) imm = imm16;"])]
          [Ps "aarch64/instrs/system/exceptions/runtime/hvc" (Just PsExecute)
             "if !HaveEL(EL2) || PSTATE.EL == EL0 || (PSTATE.EL == EL1 && IsSecure()) then\n    UnallocatedEncoding();\n\nhvc_enable = if HaveEL(EL3) then SCR_EL3.HCE else NOT(HCR_EL2.HCD);\nif hvc_enable == '0' then\n    AArch64.UndefinedFault();\nelse\n    AArch64.CallHypervisor(imm);"]),
     Left
       (AliasPage "IC_SYS" "SYS"
          (Class "SYS_CR_system" Nothing
             (Diagram "aarch64/instrs/system/sysops"
                [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                 Block (Just "L") (BlockEq [O]),
                 Block (Just "op0") (BlockEq [O, I]),
                 Block (Just "op1") (BlockEq [X, X, X]),
                 Block (Just "CRn") (BlockEq [O, I, I, I]),
                 Block (Just "CRm") (BlockEq [X, X, X, X]),
                 Block (Just "op2") (BlockEq [X, X, X]),
                 Block (Just "Rt") (BlockEq [X, X, X, X, X])])
             [Encoding "IC_SYS_CR_system" [] "IC  <ic_op>{, <Xt>}"
                [Symbol "<ic_op>" "op1:CRm:op2"
                   (Just
                      (Table ["op2", "CRm", "op1"]
                         [TableRow "IALLUIS" [[O, O, O], [O, O, O, I], [O, O, O]] Nothing,
                          TableRow "IALLU" [[O, O, O], [O, I, O, I], [O, O, O]] Nothing,
                          TableRow "IVAU" [[O, O, I], [O, I, O, I], [O, I, I]] Nothing])),
                 Symbol "<op1>" "op1" Nothing, Symbol "<Cm>" "CRm" Nothing,
                 Symbol "<op2>" "op2" Nothing, Symbol "<Xt>" "Rt" Nothing]])),
     Right
       (Page "ISB" []
          [(Class "ISB_BI_system" Nothing
              (Diagram "aarch64/instrs/system/barriers"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, I]),
                  Block (Just "CRm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "opc") (BlockEq [I, O]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "ISB_BI_system" [] "ISB  {<option>|#<imm>}"
                 [Symbol "<option>" "" Nothing, Symbol "<imm>" "CRm" Nothing]],
            [Ps "aarch64/instrs/system/barriers" (Just PsDecode)
               "MemBarrierOp op;\nMBReqDomain domain;\nMBReqTypes types;\n\ncase opc of\n    when '00' op = MemBarrierOp_DSB;\n    when '01' op = MemBarrierOp_DMB;\n    when '10' op = MemBarrierOp_ISB;\n    otherwise UnallocatedEncoding();\n\ncase CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable;\n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\n\ncase CRm<1:0> of\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;\n    otherwise\n        types = MBReqTypes_All;\n        domain = MBReqDomain_FullSystem;"])]
          [Ps "aarch64/instrs/system/barriers" (Just PsExecute)
             "case op of\n    when MemBarrierOp_DSB\n        DataSynchronizationBarrier(domain, types);\n    when MemBarrierOp_DMB\n        DataMemoryBarrier(domain, types);\n    when MemBarrierOp_ISB\n        InstructionSynchronizationBarrier();"]),
     Right
       (Page "LDADD" ["STADD_LDADD"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDADD_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDADD  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDA_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDADDA  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDAL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDADDAL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDADDL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADD_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDADD  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDA_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDADDA  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDAL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDADDAL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDADDL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDADDB" ["STADDB_LDADDB"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDADDAB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDADDAB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDALB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDADDALB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDB_32_memop" [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDADDB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDLB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDADDLB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDADDH" ["STADDH_LDADDH"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDADDAH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDADDAH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDALH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDADDALH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDH_32_memop" [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDADDH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDADDLH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDADDLH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDAPR" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/memory/ordered-rcpc"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [I]),
                  Block (Just "R") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o3") (BlockEq [I]),
                  Block (Just "opc") (BlockEq [I, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDAPR_32L_memop" [("size", BlockEq [I, O])]
                 "LDAPR  <Wt>, [<Xn|SP> {,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDAPR_64L_memop" [("size", BlockEq [I, I])]
                 "LDAPR  <Xt>, [<Xn|SP> {,#0}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered-rcpc" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = AccType_ORDERED;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered-rcpc" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = Mem[address, dbytes, acctype];\nX[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDAPRB" []
          [(Class "LDAPRB_32L_memop" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/memory/ordered-rcpc"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [I]),
                  Block (Just "R") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o3") (BlockEq [I]),
                  Block (Just "opc") (BlockEq [I, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDAPRB_32L_memop" [] "LDAPRB  <Wt>, [<Xn|SP> {,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered-rcpc" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = AccType_ORDERED;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered-rcpc" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = Mem[address, dbytes, acctype];\nX[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDAPRH" []
          [(Class "LDAPRH_32L_memop" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/memory/ordered-rcpc"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [I]),
                  Block (Just "R") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o3") (BlockEq [I]),
                  Block (Just "opc") (BlockEq [I, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDAPRH_32L_memop" [] "LDAPRH  <Wt>, [<Xn|SP> {,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered-rcpc" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = AccType_ORDERED;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered-rcpc" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ndata = Mem[address, dbytes, acctype];\nX[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDAR" []
          [(Class "base_register" Nothing
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDAR_LR32_ldstexcl" [("size", BlockEq [I, O])]
                 "LDAR  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDAR_LR64_ldstexcl" [("size", BlockEq [I, I])]
                 "LDAR  <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDARB" []
          [(Class "LDARB_LR32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDARB_LR32_ldstexcl" [] "LDARB  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDARH" []
          [(Class "LDARH_LR32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDARH_LR32_ldstexcl" [] "LDARH  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDAXP" []
          [(Class "base_register" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/pair"
                 [Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDAXP_LP32_ldstexcl" [("sz", BlockEq [O])]
                 "LDAXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt1>" "Rt" Nothing, Symbol "<Wt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDAXP_LP64_ldstexcl" [("sz", BlockEq [I])]
                 "LDAXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/pair" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/pair" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDAXR" []
          [(Class "base_register" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDAXR_LR32_ldstexcl" [("size", BlockEq [I, O])]
                 "LDAXR  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDAXR_LR64_ldstexcl" [("size", BlockEq [I, I])]
                 "LDAXR  <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDAXRB" []
          [(Class "LDAXRB_LR32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDAXRB_LR32_ldstexcl" [] "LDAXRB  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDAXRH" []
          [(Class "LDAXRH_LR32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDAXRH_LR32_ldstexcl" [] "LDAXRH  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDCLR" ["STCLR_LDCLR"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDCLR_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDCLR  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRA_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDCLRA  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRAL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDCLRAL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDCLRL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLR_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDCLR  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRA_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDCLRA  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRAL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDCLRAL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDCLRL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDCLRB" ["STCLRB_LDCLRB"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDCLRAB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDCLRAB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRALB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDCLRALB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRB_32_memop" [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDCLRB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRLB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDCLRLB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDCLRH" ["STCLRH_LDCLRH"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDCLRAH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDCLRAH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRALH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDCLRALH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRH_32_memop" [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDCLRH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDCLRLH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDCLRLH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDEOR" ["STEOR_LDEOR"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDEOR_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDEOR  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORA_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDEORA  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORAL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDEORAL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDEORL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEOR_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDEOR  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORA_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDEORA  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORAL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDEORAL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDEORL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDEORB" ["STEORB_LDEORB"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDEORAB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDEORAB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORALB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDEORALB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORB_32_memop" [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDEORB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORLB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDEORLB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDEORH" ["STEORH_LDEORH"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDEORAH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDEORAH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORALH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDEORALH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORH_32_memop" [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDEORH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDEORLH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDEORLH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDLAR" []
          [(Class "base_register" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDLAR_LR32_ldstexcl" [("size", BlockEq [I, O])]
                 "LDLAR  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDLAR_LR64_ldstexcl" [("size", BlockEq [I, I])]
                 "LDLAR  <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDLARB" []
          [(Class "LDLARB_LR32_ldstexcl" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDLARB_LR32_ldstexcl" [] "LDLARB  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDLARH" []
          [(Class "LDLARH_LR32_ldstexcl" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDLARH_LR32_ldstexcl" [] "LDLARH  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDNP_gen" []
          [(Class "signed_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/no-alloc"
                 [Block (Just "opc") (BlockEq [X, O]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDNP_32_ldstnapair_offs" [("opc", BlockEq [O, O])]
                 "LDNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Wt1>" "Rt" Nothing, Symbol "<Wt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDNP_64_ldstnapair_offs" [("opc", BlockEq [I, O])]
                 "LDNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/no-alloc" (Just PsDecode)
               "boolean wback  = FALSE;\nboolean postindex = FALSE;"])]
          [Ps "aarch64/instrs/memory/pair/general/no-alloc"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_STREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc<0> == '1' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);",
           Ps "aarch64/instrs/memory/pair/general/no-alloc" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        X[t]  = data1;\n        X[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDP_gen" []
          [(Class "post_indexed" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/post-idx"
                 [Block (Just "opc") (BlockEq [X, O]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDP_32_ldstpair_post" [("opc", BlockEq [O, O])]
                 "LDP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>"
                 [Symbol "<Wt1>" "Rt" Nothing, Symbol "<Wt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDP_64_ldstpair_post" [("opc", BlockEq [I, O])]
                 "LDP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/post-idx" (Just PsDecode)
               "boolean wback  = TRUE;\nboolean postindex = TRUE;"]),
           (Class "pre_indexed" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/pre-idx"
                 [Block (Just "opc") (BlockEq [X, O]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDP_32_ldstpair_pre" [("opc", BlockEq [O, O])]
                 "LDP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<Wt1>" "Rt" Nothing, Symbol "<Wt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDP_64_ldstpair_pre" [("opc", BlockEq [I, O])]
                 "LDP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/pre-idx" (Just PsDecode)
               "boolean wback  = TRUE;\nboolean postindex = FALSE;"]),
           (Class "signed_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/offset"
                 [Block (Just "opc") (BlockEq [X, O]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDP_32_ldstpair_off" [("opc", BlockEq [O, O])]
                 "LDP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Wt1>" "Rt" Nothing, Symbol "<Wt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDP_64_ldstpair_off" [("opc", BlockEq [I, O])]
                 "LDP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/offset" (Just PsDecode)
               "boolean wback  = FALSE;\nboolean postindex = FALSE;"])]
          [Ps "aarch64/instrs/memory/pair/general/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_NORMAL;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif L:opc<0> == '01' || opc == '11' then UnallocatedEncoding();\nboolean signed = (opc<0> != '0');\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);",
           Ps "aarch64/instrs/memory/pair/general/post-idx" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean wb_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        if signed then\n            X[t]  = SignExtend(data1, 64);\n            X[t2] = SignExtend(data2, 64);\n        else\n            X[t]  = data1;\n            X[t2] = data2;\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDPSW" []
          [(Class "LDPSW_64_ldstpair_post" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/post-idx"
                 [Block (Just "opc") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDPSW_64_ldstpair_post" []
                 "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/post-idx" (Just PsDecode)
               "boolean wback  = TRUE;\nboolean postindex = TRUE;"]),
           (Class "LDPSW_64_ldstpair_pre" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/pre-idx"
                 [Block (Just "opc") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDPSW_64_ldstpair_pre" []
                 "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/pre-idx" (Just PsDecode)
               "boolean wback  = TRUE;\nboolean postindex = FALSE;"]),
           (Class "LDPSW_64_ldstpair_off" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/offset"
                 [Block (Just "opc") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDPSW_64_ldstpair_off" []
                 "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/offset" (Just PsDecode)
               "boolean wback  = FALSE;\nboolean postindex = FALSE;"])]
          [Ps "aarch64/instrs/memory/pair/general/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_NORMAL;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif L:opc<0> == '01' || opc == '11' then UnallocatedEncoding();\nboolean signed = (opc<0> != '0');\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);",
           Ps "aarch64/instrs/memory/pair/general/post-idx" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean wb_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        if signed then\n            X[t]  = SignExtend(data1, 64);\n            X[t2] = SignExtend(data2, 64);\n        else\n            X[t]  = data1;\n            X[t2] = data2;\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDR_imm_gen" []
          [(Class "post_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDR_32_ldst_immpost" [("size", BlockEq [I, O])]
                 "LDR  <Wt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDR_64_ldst_immpost" [("size", BlockEq [I, I])]
                 "LDR  <Xt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "pre_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDR_32_ldst_immpre" [("size", BlockEq [I, O])]
                 "LDR  <Wt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDR_64_ldst_immpre" [("size", BlockEq [I, I])]
                 "LDR  <Xt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "unsigned_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/single/general/immediate/unsigned"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [O, I]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDR_32_ldst_pos" [("size", BlockEq [I, O])]
                 "LDR  <Wt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "LDR_64_ldst_pos" [("size", BlockEq [I, I])]
                 "LDR  <Xt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDR_lit_gen" []
          [(Class "literal" Nothing
              (Diagram "aarch64/instrs/memory/literal/general"
                 [Block (Just "opc") (BlockEq [O, X]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "imm19")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDR_32_loadlit" [("opc", BlockEq [O, O])]
                 "LDR  <Wt>, <label>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<label>" "imm19" Nothing],
               Encoding "LDR_64_loadlit" [("opc", BlockEq [O, I])]
                 "LDR  <Xt>, <label>"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<label>" "imm19" Nothing]],
            [Ps "aarch64/instrs/memory/literal/general" (Just PsDecode)
               "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\n\noffset = SignExtend(imm19:'00', 64);"])]
          [Ps "aarch64/instrs/memory/literal/general" (Just PsExecute)
             "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);"]),
     Right
       (Page "LDR_reg_gen" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/memory/single/general/register"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDR_32_ldst_regoff" [("size", BlockEq [I, O])]
                 "LDR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#2" [[I]] Nothing]))],
               Encoding "LDR_64_ldst_regoff" [("size", BlockEq [I, I])]
                 "LDR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#3" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/memory/single/general/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/general/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRA" []
          [(Class "base_plus_offset" (Just (ArchName "ARMv8.3"))
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/pac"
                 [Block (Just "size") (BlockEq [I, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "M") (BlockEq [X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block (Just "W") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRAA_64_ldst_pac"
                 [("M", BlockEq [O]), ("W", BlockEq [O])]
                 "LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "S:imm9" Nothing],
               Encoding "LDRAA_64W_ldst_pac"
                 [("M", BlockEq [O]), ("W", BlockEq [I])]
                 "LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]!"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "S:imm9" Nothing],
               Encoding "LDRAB_64_ldst_pac"
                 [("M", BlockEq [I]), ("W", BlockEq [O])]
                 "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "S:imm9" Nothing],
               Encoding "LDRAB_64W_ldst_pac"
                 [("M", BlockEq [I]), ("W", BlockEq [I])]
                 "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]!"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "S:imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/signed/pac"
               (Just PsDecode)
               "if !HavePACExt() || size != '11' then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\nboolean wback = (W == '1');\nboolean use_key_a = (M == '0');\nbits(10) S10 = S:imm9;\ninteger scale = 3;\nbits(64) offset = LSL(SignExtend(S10, 64), scale);"])]
          [Ps "aarch64/instrs/memory/single/general/immediate/signed/pac"
             (Just PsExecute)
             "bits(64) address;\nbits(64) data;\nboolean wb_unknown = FALSE;\n\nif wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif use_key_a then\n    address = AuthDA(address, X[31]);\nelse\n    address = AuthDB(address, X[31]);\n\naddress = address + offset;\ndata = Mem[address, 8, AccType_NORMAL];\nX[t] = data;\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRB_imm" []
          [(Class "LDRB_32_ldst_immpost" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRB_32_ldst_immpost" []
                 "LDRB  <Wt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "LDRB_32_ldst_immpre" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRB_32_ldst_immpre" []
                 "LDRB  <Wt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "LDRB_32_ldst_pos" Nothing
              (Diagram "aarch64/instrs/memory/single/general/immediate/unsigned"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [O, I]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRB_32_ldst_pos" [] "LDRB  <Wt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRB_reg" []
          [(Class "32" Nothing
              (Diagram "aarch64/instrs/memory/single/general/register"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRB_32B_ldst_regoff" [("option", BlockNeq [O, I, I])]
                 "LDRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S" Nothing],
               Encoding "LDRB_32BL_ldst_regoff" [("option", BlockEq [O, I, I])]
                 "LDRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<amount>" "S" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/general/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRH_imm" []
          [(Class "LDRH_32_ldst_immpost" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRH_32_ldst_immpost" []
                 "LDRH  <Wt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "LDRH_32_ldst_immpre" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRH_32_ldst_immpre" []
                 "LDRH  <Wt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "LDRH_32_ldst_pos" Nothing
              (Diagram "aarch64/instrs/memory/single/general/immediate/unsigned"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [O, I]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRH_32_ldst_pos" [] "LDRH  <Wt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRH_reg" []
          [(Class "LDRH_32_ldst_regoff" Nothing
              (Diagram "aarch64/instrs/memory/single/general/register"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRH_32_ldst_regoff" []
                 "LDRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#1" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/memory/single/general/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/general/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRSB_imm" []
          [(Class "post_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, X]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSB_32_ldst_immpost" [("opc", BlockEq [I, I])]
                 "LDRSB  <Wt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDRSB_64_ldst_immpost" [("opc", BlockEq [I, O])]
                 "LDRSB  <Xt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "pre_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, X]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSB_32_ldst_immpre" [("opc", BlockEq [I, I])]
                 "LDRSB  <Wt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDRSB_64_ldst_immpre" [("opc", BlockEq [I, O])]
                 "LDRSB  <Xt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "unsigned_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/single/general/immediate/unsigned"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [I, X]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSB_32_ldst_pos" [("opc", BlockEq [I, I])]
                 "LDRSB  <Wt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "LDRSB_64_ldst_pos" [("opc", BlockEq [I, O])]
                 "LDRSB  <Xt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRSB_reg" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/memory/single/general/register"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSB_32B_ldst_regoff"
                 [("opc", BlockEq [I, I]), ("option", BlockNeq [O, I, I])]
                 "LDRSB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S" Nothing],
               Encoding "LDRSB_32BL_ldst_regoff"
                 [("opc", BlockEq [I, I]), ("option", BlockEq [O, I, I])]
                 "LDRSB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<amount>" "S" Nothing],
               Encoding "LDRSB_64B_ldst_regoff"
                 [("opc", BlockEq [I, O]), ("option", BlockNeq [O, I, I])]
                 "LDRSB  <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S" Nothing],
               Encoding "LDRSB_64BL_ldst_regoff"
                 [("opc", BlockEq [I, O]), ("option", BlockEq [O, I, I])]
                 "LDRSB  <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<amount>" "S" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/general/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRSH_imm" []
          [(Class "post_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, X]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSH_32_ldst_immpost" [("opc", BlockEq [I, I])]
                 "LDRSH  <Wt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDRSH_64_ldst_immpost" [("opc", BlockEq [I, O])]
                 "LDRSH  <Xt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "pre_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, X]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSH_32_ldst_immpre" [("opc", BlockEq [I, I])]
                 "LDRSH  <Wt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDRSH_64_ldst_immpre" [("opc", BlockEq [I, O])]
                 "LDRSH  <Xt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "unsigned_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/single/general/immediate/unsigned"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [I, X]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSH_32_ldst_pos" [("opc", BlockEq [I, I])]
                 "LDRSH  <Wt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "LDRSH_64_ldst_pos" [("opc", BlockEq [I, O])]
                 "LDRSH  <Xt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRSH_reg" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/memory/single/general/register"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSH_32_ldst_regoff" [("opc", BlockEq [I, I])]
                 "LDRSH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#1" [[I]] Nothing]))],
               Encoding "LDRSH_64_ldst_regoff" [("opc", BlockEq [I, O])]
                 "LDRSH  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#1" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/memory/single/general/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/general/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRSW_imm" []
          [(Class "LDRSW_64_ldst_immpost" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSW_64_ldst_immpost" []
                 "LDRSW  <Xt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "LDRSW_64_ldst_immpre" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSW_64_ldst_immpre" []
                 "LDRSW  <Xt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "LDRSW_64_ldst_pos" Nothing
              (Diagram "aarch64/instrs/memory/single/general/immediate/unsigned"
                 [Block (Just "size") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [I, O]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSW_64_ldst_pos" []
                 "LDRSW  <Xt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDRSW_lit" []
          [(Class "LDRSW_64_loadlit" Nothing
              (Diagram "aarch64/instrs/memory/literal/general"
                 [Block (Just "opc") (BlockEq [I, O]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "imm19")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSW_64_loadlit" [] "LDRSW  <Xt>, <label>"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<label>" "imm19" Nothing]],
            [Ps "aarch64/instrs/memory/literal/general" (Just PsDecode)
               "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\n\noffset = SignExtend(imm19:'00', 64);"])]
          [Ps "aarch64/instrs/memory/literal/general" (Just PsExecute)
             "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);"]),
     Right
       (Page "LDRSW_reg" []
          [(Class "LDRSW_64_ldst_regoff" Nothing
              (Diagram "aarch64/instrs/memory/single/general/register"
                 [Block (Just "size") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDRSW_64_ldst_regoff" []
                 "LDRSW  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#2" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/memory/single/general/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/general/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDSET" ["STSET_LDSET"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, I, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDSET_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSET  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETA_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSETA  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETAL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSETAL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSETL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSET_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSET  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETA_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSETA  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETAL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSETAL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSETL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDSETB" ["STSETB_LDSETB"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, I, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDSETAB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSETAB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETALB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSETALB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETB_32_memop" [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSETB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETLB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSETLB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDSETH" ["STSETH_LDSETH"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [O, I, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDSETAH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSETAH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETALH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSETALH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETH_32_memop" [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSETH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSETLH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSETLH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDSMAX" ["STSMAX_LDSMAX"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDSMAX_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSMAX  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXA_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSMAXA  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXAL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSMAXAL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSMAXL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAX_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSMAX  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXA_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSMAXA  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXAL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSMAXAL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSMAXL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDSMAXB" ["STSMAXB_LDSMAXB"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDSMAXAB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSMAXAB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXALB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSMAXALB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSMAXB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXLB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSMAXLB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDSMAXH" ["STSMAXH_LDSMAXH"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDSMAXAH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSMAXAH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXALH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSMAXALH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSMAXH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMAXLH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSMAXLH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDSMIN" ["STSMIN_LDSMIN"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, O, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDSMIN_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSMIN  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINA_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSMINA  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINAL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSMINAL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSMINL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMIN_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSMIN  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINA_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSMINA  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINAL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSMINAL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSMINL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDSMINB" ["STSMINB_LDSMINB"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, O, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDSMINAB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSMINAB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINALB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSMINALB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSMINB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINLB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSMINLB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDSMINH" ["STSMINH_LDSMINH"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, O, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDSMINAH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDSMINAH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINALH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDSMINALH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDSMINH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDSMINLH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDSMINLH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDTR" []
          [(Class "base_plus_offset" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDTR_32_ldst_unpriv" [("size", BlockEq [I, O])]
                 "LDTR  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDTR_64_ldst_unpriv" [("size", BlockEq [I, I])]
                 "LDTR  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDTRB" []
          [(Class "LDTRB_32_ldst_unpriv" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDTRB_32_ldst_unpriv" []
                 "LDTRB  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDTRH" []
          [(Class "LDTRH_32_ldst_unpriv" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDTRH_32_ldst_unpriv" []
                 "LDTRH  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDTRSB" []
          [(Class "base_plus_offset" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, X]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDTRSB_32_ldst_unpriv" [("opc", BlockEq [I, I])]
                 "LDTRSB  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDTRSB_64_ldst_unpriv" [("opc", BlockEq [I, O])]
                 "LDTRSB  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDTRSH" []
          [(Class "base_plus_offset" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, X]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDTRSH_32_ldst_unpriv" [("opc", BlockEq [I, I])]
                 "LDTRSH  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDTRSH_64_ldst_unpriv" [("opc", BlockEq [I, O])]
                 "LDTRSH  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDTRSW" []
          [(Class "LDTRSW_64_ldst_unpriv" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
                 [Block (Just "size") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDTRSW_64_ldst_unpriv" []
                 "LDTRSW  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDUMAX" ["STUMAX_LDUMAX"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, I, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDUMAX_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDUMAX  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXA_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDUMAXA  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXAL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDUMAXAL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDUMAXL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAX_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDUMAX  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXA_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDUMAXA  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXAL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDUMAXAL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDUMAXL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDUMAXB" ["STUMAXB_LDUMAXB"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, I, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDUMAXAB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDUMAXAB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXALB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDUMAXALB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDUMAXB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXLB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDUMAXLB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDUMAXH" ["STUMAXH_LDUMAXH"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, I, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDUMAXAH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDUMAXAH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXALH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDUMAXALH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDUMAXH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMAXLH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDUMAXLH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDUMIN" ["STUMIN_LDUMIN"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, I, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDUMIN_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDUMIN  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINA_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDUMINA  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINAL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDUMINAL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDUMINL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMIN_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDUMIN  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINA_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDUMINA  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINAL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDUMINAL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDUMINL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDUMINB" ["STUMINB_LDUMINB"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, I, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDUMINAB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDUMINAB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINALB_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDUMINALB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDUMINB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINLB_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDUMINLB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDUMINH" ["STUMINH_LDUMINH"]
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/ld"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [O]),
                  Block (Just "opc") (BlockEq [I, I, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDUMINAH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "LDUMINAH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINALH_32_memop"
                 [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "LDUMINALH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "LDUMINH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDUMINLH_32_memop"
                 [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "LDUMINLH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;"])]
          [Ps "aarch64/instrs/memory/atomicops/ld" (Just PsExecute)
             "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\n\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\n// All observers in the shareability domain observe the\n// following load and store atomically.\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\n\nMem[address, datasize DIV 8, stacctype] = result;\n\nif t != 31 then\n    X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDUR_gen" []
          [(Class "base_plus_offset" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDUR_32_ldst_unscaled" [("size", BlockEq [I, O])]
                 "LDUR  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDUR_64_ldst_unscaled" [("size", BlockEq [I, I])]
                 "LDUR  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDURB" []
          [(Class "LDURB_32_ldst_unscaled" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDURB_32_ldst_unscaled" []
                 "LDURB  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDURH" []
          [(Class "LDURH_32_ldst_unscaled" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDURH_32_ldst_unscaled" []
                 "LDURH  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDURSB" []
          [(Class "base_plus_offset" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, X]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDURSB_32_ldst_unscaled" [("opc", BlockEq [I, I])]
                 "LDURSB  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDURSB_64_ldst_unscaled" [("opc", BlockEq [I, O])]
                 "LDURSB  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDURSH" []
          [(Class "base_plus_offset" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, X]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDURSH_32_ldst_unscaled" [("opc", BlockEq [I, I])]
                 "LDURSH  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDURSH_64_ldst_unscaled" [("opc", BlockEq [I, O])]
                 "LDURSH  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDURSW" []
          [(Class "LDURSW_64_ldst_unscaled" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDURSW_64_ldst_unscaled" []
                 "LDURSW  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDXP" []
          [(Class "base_register" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/pair"
                 [Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDXP_LP32_ldstexcl" [("sz", BlockEq [O])]
                 "LDXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt1>" "Rt" Nothing, Symbol "<Wt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDXP_LP64_ldstexcl" [("sz", BlockEq [I])]
                 "LDXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/pair" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/pair" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDXR" []
          [(Class "base_register" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDXR_LR32_ldstexcl" [("size", BlockEq [I, O])]
                 "LDXR  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LDXR_LR64_ldstexcl" [("size", BlockEq [I, I])]
                 "LDXR  <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDXRB" []
          [(Class "LDXRB_LR32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDXRB_LR32_ldstexcl" [] "LDXRB  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "LDXRH" []
          [(Class "LDXRH_LR32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDXRH_LR32_ldstexcl" [] "LDXRH  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Left
       (AliasPage "LSL_UBFM" "UBFM"
          (Class "zero_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [I, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockNeq [X, I, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "LSL_UBFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O]),
                 ("imms", BlockNeq [O, I, I, I, I, I])]
                "LSL  <Wd>, <Wn>, #<shift>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<shift>" "" Nothing],
              Encoding "LSL_UBFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I]),
                 ("imms", BlockNeq [I, I, I, I, I, I])]
                "LSL  <Xd>, <Xn>, #<shift>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<shift>" "" Nothing]])),
     Left
       (AliasPage "LSL_LSLV" "LSLV"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/shift/variable"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "opcode2<5:2>") (BlockEq [O, O, I, O]),
                 Block (Just "op2") (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "LSL_LSLV_32_dp_2src" [("sf", BlockEq [O])]
                "LSL  <Wd>, <Wn>, <Wm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<Wm>" "Rm" Nothing],
              Encoding "LSL_LSLV_64_dp_2src" [("sf", BlockEq [I])]
                "LSL  <Xd>, <Xn>, <Xm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<Xm>" "Rm" Nothing]])),
     Right
       (Page "LSLV" ["LSL_LSLV"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/shift/variable"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2<5:2>") (BlockEq [O, O, I, O]),
                  Block (Just "op2") (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "LSLV_32_dp_2src" [("sf", BlockEq [O])]
                 "LSLV  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "LSLV_64_dp_2src" [("sf", BlockEq [I])]
                 "LSLV  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/shift/variable" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);"])]
          [Ps "aarch64/instrs/integer/shift/variable" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"]),
     Left
       (AliasPage "LSR_UBFM" "UBFM"
          (Class "zero_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [I, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, I, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "LSR_UBFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O]),
                 ("imms", BlockEq [O, I, I, I, I, I])]
                "LSR  <Wd>, <Wn>, #<shift>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<shift>" "immr" Nothing],
              Encoding "LSR_UBFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I]),
                 ("imms", BlockEq [I, I, I, I, I, I])]
                "LSR  <Xd>, <Xn>, #<shift>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<shift>" "immr" Nothing]])),
     Left
       (AliasPage "LSR_LSRV" "LSRV"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/shift/variable"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "opcode2<5:2>") (BlockEq [O, O, I, O]),
                 Block (Just "op2") (BlockEq [O, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "LSR_LSRV_32_dp_2src" [("sf", BlockEq [O])]
                "LSR  <Wd>, <Wn>, <Wm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<Wm>" "Rm" Nothing],
              Encoding "LSR_LSRV_64_dp_2src" [("sf", BlockEq [I])]
                "LSR  <Xd>, <Xn>, <Xm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<Xm>" "Rm" Nothing]])),
     Right
       (Page "LSRV" ["LSR_LSRV"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/shift/variable"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2<5:2>") (BlockEq [O, O, I, O]),
                  Block (Just "op2") (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "LSRV_32_dp_2src" [("sf", BlockEq [O])]
                 "LSRV  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "LSRV_64_dp_2src" [("sf", BlockEq [I])]
                 "LSRV  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/shift/variable" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);"])]
          [Ps "aarch64/instrs/integer/shift/variable" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"]),
     Right
       (Page "MADD" ["MUL_MADD"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/mul/uniform/add-sub"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "op54") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, O, I, I]),
                  Block (Just "op31") (BlockEq [O, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MADD_32A_dp_3src" [("sf", BlockEq [O])]
                 "MADD  <Wd>, <Wn>, <Wm>, <Wa>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Wa>" "Ra" Nothing],
               Encoding "MADD_64A_dp_3src" [("sf", BlockEq [I])]
                 "MADD  <Xd>, <Xn>, <Xm>, <Xa>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<Xa>" "Ra" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/mul/uniform/add-sub"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = if sf == '1' then 64 else 32;\ninteger datasize = destsize;\nboolean sub_op = (o0 == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/mul/uniform/add-sub"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));\nelse\n    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));\n\nX[d] = result<destsize-1:0>;"]),
     Left
       (AliasPage "MNEG_MSUB" "MSUB"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/mul/uniform/add-sub"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "op54") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, O, I, I]),
                 Block (Just "op31") (BlockEq [O, O, O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "o0") (BlockEq [I]),
                 Block (Just "Ra") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MNEG_MSUB_32A_dp_3src" [("sf", BlockEq [O])]
                "MNEG  <Wd>, <Wn>, <Wm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<Wm>" "Rm" Nothing],
              Encoding "MNEG_MSUB_64A_dp_3src" [("sf", BlockEq [I])]
                "MNEG  <Xd>, <Xn>, <Xm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<Xm>" "Rm" Nothing]])),
     Left
       (AliasPage "MOV_ORR_log_imm" "ORR_log_imm"
          (Class "no_s" Nothing
             (Diagram "aarch64/instrs/integer/logical/immediate"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, O, O, I, O, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MOV_ORR_32_log_imm"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "MOV  <Wd|WSP>, #<imm>"
                [Symbol "<Wd|WSP>" "Rd" Nothing,
                 Symbol "<imm>" "immr:imms" Nothing],
              Encoding "MOV_ORR_64_log_imm" [("sf", BlockEq [I])]
                "MOV  <Xd|SP>, #<imm>"
                [Symbol "<Xd|SP>" "Rd" Nothing,
                 Symbol "<imm>" "N:immr:imms" Nothing]])),
     Left
       (AliasPage "MOV_MOVN" "MOVN"
          (Class "imm18_packed" Nothing
             (Diagram "aarch64/instrs/integer/ins-ext/insert/movewide"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, O, O, I, O, I]),
                 Block (Just "hw") (BlockEq [X, X]),
                 Block (Just "imm16")
                   (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MOV_MOVN_32_movewide" [("sf", BlockEq [O])]
                "MOV  <Wd>, #<imm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<imm>" "hw:imm16" Nothing,
                 Symbol "<shift>" "hw" Nothing],
              Encoding "MOV_MOVN_64_movewide" [("sf", BlockEq [I])]
                "MOV  <Xd>, #<imm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<imm>" "hw:imm16" Nothing,
                 Symbol "<shift>" "hw" Nothing]])),
     Left
       (AliasPage "MOV_ORR_log_shift" "ORR_log_shift"
          (Class "no_s" Nothing
             (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, I]),
                 Block Nothing (BlockEq [O, I, O, I, O]),
                 Block (Just "shift") (BlockEq [O, O]),
                 Block (Just "N") (BlockEq [O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "imm6") (BlockEq [O, O, O, O, O, O]),
                 Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MOV_ORR_32_log_shift" [("sf", BlockEq [O])]
                "MOV  <Wd>, <Wm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wm>" "Rm" Nothing],
              Encoding "MOV_ORR_64_log_shift" [("sf", BlockEq [I])]
                "MOV  <Xd>, <Xm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xm>" "Rm" Nothing]])),
     Left
       (AliasPage "MOV_ADD_addsub_imm" "ADD_addsub_imm"
          (Class "no_s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/immediate"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, O, O, O, I]),
                 Block (Just "shift") (BlockEq [O, O]),
                 Block (Just "imm12")
                   (BlockEq [O, O, O, O, O, O, O, O, O, O, O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MOV_ADD_32_addsub_imm" [("sf", BlockEq [O])]
                "MOV  <Wd|WSP>, <Wn|WSP>"
                [Symbol "<Wd|WSP>" "Rd" Nothing, Symbol "<Wn|WSP>" "Rn" Nothing],
              Encoding "MOV_ADD_64_addsub_imm" [("sf", BlockEq [I])]
                "MOV  <Xd|SP>, <Xn|SP>"
                [Symbol "<Xd|SP>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]])),
     Left
       (AliasPage "MOV_MOVZ" "MOVZ"
          (Class "imm18_packed" Nothing
             (Diagram "aarch64/instrs/integer/ins-ext/insert/movewide"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [I, O]),
                 Block Nothing (BlockEq [I, O, O, I, O, I]),
                 Block (Just "hw") (BlockEq [X, X]),
                 Block (Just "imm16")
                   (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MOV_MOVZ_32_movewide" [("sf", BlockEq [O])]
                "MOV  <Wd>, #<imm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<imm>" "hw:imm16" Nothing,
                 Symbol "<shift>" "hw" Nothing],
              Encoding "MOV_MOVZ_64_movewide" [("sf", BlockEq [I])]
                "MOV  <Xd>, #<imm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<imm>" "hw:imm16" Nothing,
                 Symbol "<shift>" "hw" Nothing]])),
     Right
       (Page "MOVK" []
          [(Class "imm18_packed" Nothing
              (Diagram "aarch64/instrs/integer/ins-ext/insert/movewide"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [I, I]),
                  Block Nothing (BlockEq [I, O, O, I, O, I]),
                  Block (Just "hw") (BlockEq [X, X]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MOVK_32_movewide" [("sf", BlockEq [O])]
                 "MOVK  <Wd>, #<imm>{, LSL #<shift>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<imm>" "imm16" Nothing,
                  Symbol "<shift>" "hw" Nothing],
               Encoding "MOVK_64_movewide" [("sf", BlockEq [I])]
                 "MOVK  <Xd>, #<imm>{, LSL #<shift>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<imm>" "imm16" Nothing,
                  Symbol "<shift>" "hw" Nothing]],
            [Ps "aarch64/instrs/integer/ins-ext/insert/movewide"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\n\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UnallocatedEncoding();\n\nif sf == '0' && hw<1> == '1' then UnallocatedEncoding();\npos = UInt(hw:'0000');"])]
          [Ps "aarch64/instrs/integer/ins-ext/insert/movewide"
             (Just PsExecute)
             "bits(datasize) result;\n\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\n\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nX[d] = result;"]),
     Right
       (Page "MOVN" ["MOV_MOVN"]
          [(Class "imm18_packed" Nothing
              (Diagram "aarch64/instrs/integer/ins-ext/insert/movewide"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, O, I, O, I]),
                  Block (Just "hw") (BlockEq [X, X]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MOVN_32_movewide" [("sf", BlockEq [O])]
                 "MOVN  <Wd>, #<imm>{, LSL #<shift>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<imm>" "imm16" Nothing,
                  Symbol "<shift>" "hw" Nothing],
               Encoding "MOVN_64_movewide" [("sf", BlockEq [I])]
                 "MOVN  <Xd>, #<imm>{, LSL #<shift>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<imm>" "imm16" Nothing,
                  Symbol "<shift>" "hw" Nothing]],
            [Ps "aarch64/instrs/integer/ins-ext/insert/movewide"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\n\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UnallocatedEncoding();\n\nif sf == '0' && hw<1> == '1' then UnallocatedEncoding();\npos = UInt(hw:'0000');"])]
          [Ps "aarch64/instrs/integer/ins-ext/insert/movewide"
             (Just PsExecute)
             "bits(datasize) result;\n\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\n\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nX[d] = result;"]),
     Right
       (Page "MOVZ" ["MOV_MOVZ"]
          [(Class "imm18_packed" Nothing
              (Diagram "aarch64/instrs/integer/ins-ext/insert/movewide"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, O, O, I, O, I]),
                  Block (Just "hw") (BlockEq [X, X]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MOVZ_32_movewide" [("sf", BlockEq [O])]
                 "MOVZ  <Wd>, #<imm>{, LSL #<shift>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<imm>" "imm16" Nothing,
                  Symbol "<shift>" "hw" Nothing],
               Encoding "MOVZ_64_movewide" [("sf", BlockEq [I])]
                 "MOVZ  <Xd>, #<imm>{, LSL #<shift>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<imm>" "imm16" Nothing,
                  Symbol "<shift>" "hw" Nothing]],
            [Ps "aarch64/instrs/integer/ins-ext/insert/movewide"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\n\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UnallocatedEncoding();\n\nif sf == '0' && hw<1> == '1' then UnallocatedEncoding();\npos = UInt(hw:'0000');"])]
          [Ps "aarch64/instrs/integer/ins-ext/insert/movewide"
             (Just PsExecute)
             "bits(datasize) result;\n\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\n\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nX[d] = result;"]),
     Right
       (Page "MRS" []
          [(Class "MRS_RS_system" Nothing
              (Diagram "aarch64/instrs/system/register/system"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "o0") (BlockEq [X]),
                  Block (Just "op1") (BlockEq [X, X, X]),
                  Block (Just "CRn") (BlockEq [X, X, X, X]),
                  Block (Just "CRm") (BlockEq [X, X, X, X]),
                  Block (Just "op2") (BlockEq [X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "MRS_RS_system" []
                 "MRS  <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)"
                 [Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<systemreg>" "CRm:CRn:o0:op1:op2" Nothing,
                  Symbol "<op0>" "o0"
                    (Just
                       (Table ["o0"]
                          [TableRow "2" [[O]] Nothing, TableRow "3" [[I]] Nothing])),
                  Symbol "<op1>" "op1" Nothing, Symbol "<Cn>" "CRn" Nothing,
                  Symbol "<Cm>" "CRm" Nothing, Symbol "<op2>" "op2" Nothing]],
            [Ps "aarch64/instrs/system/register/system" (Just PsDecode)
               "AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 2 + UInt(o0);\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean read = (L == '1');"])]
          [Ps "aarch64/instrs/system/register/system" (Just PsExecute)
             "if read then\n    X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"]),
     Right
       (Page "MSR_imm" []
          [(Class "MSR_SI_system" Nothing
              (Diagram "aarch64/instrs/system/register/cpsr"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [X, X, X]),
                  Block (Just "CRn") (BlockEq [O, I, O, O]),
                  Block (Just "CRm") (BlockEq [X, X, X, X]),
                  Block (Just "op2") (BlockEq [X, X, X]),
                  Block (Just "Rt ") (BlockEq [I, I, I, I, I])])
              [Encoding "MSR_SI_system" [] "MSR  <pstatefield>, #<imm>"
                 [Symbol "<pstatefield>" "op1:op2"
                    (Just
                       (Table ["op2", "op1"]
                          [TableRow "RESERVED" [[O, O, X], [O, O, O]] Nothing,
                           TableRow "RESERVED" [[O, I, O], [O, O, O]] Nothing,
                           TableRow "UAO" [[O, I, I], [O, O, O]]
                             (Just (ArchFeature "ARMv8.2-UAO")),
                           TableRow "PAN" [[I, O, O], [O, O, O]]
                             (Just (ArchFeature "ARMv8.1-PAN")),
                           TableRow "SPSel" [[I, O, I], [O, O, O]] Nothing,
                           TableRow "RESERVED" [[I, I, X], [O, O, O]] Nothing,
                           TableRow "RESERVED" [[X, X, X], [O, O, I]] Nothing,
                           TableRow "RESERVED" [[X, X, X], [O, I, O]] Nothing,
                           TableRow "RESERVED" [[O, X, X], [O, I, I]] Nothing,
                           TableRow "RESERVED" [[I, O, X], [O, I, I]] Nothing,
                           TableRow "DAIFSet" [[I, I, O], [O, I, I]] Nothing,
                           TableRow "DAIFClr" [[I, I, I], [O, I, I]] Nothing,
                           TableRow "RESERVED" [[X, X, X], [I, X, X]] Nothing])),
                  Symbol "<imm>" "CRm" Nothing]],
            [Ps "aarch64/instrs/system/register/cpsr" (Just PsDecode)
               "AArch64.CheckSystemAccess('00', op1, '0100', CRm, op2, '11111', '0');\n\nbits(4) operand = CRm;\nPSTATEField field;\ncase op1:op2 of\n    when '000 011' \n        if !HaveUAOExt() then\n            UnallocatedEncoding();\n        field = PSTATEField_UAO;\n    when '000 100' \n        if !HavePANExt() then\n            UnallocatedEncoding();\n        field = PSTATEField_PAN;\n    when '000 101' field = PSTATEField_SP;\n    when '011 110' field = PSTATEField_DAIFSet;\n    when '011 111' field = PSTATEField_DAIFClr;\n    otherwise      UnallocatedEncoding();\n\n// Check that an AArch64 MSR/MRS access to the DAIF flags is permitted\nif op1 == '011' && PSTATE.EL == EL0 && (IsInHost() || SCTLR_EL1.UMA == '0') then\n    AArch64.SystemRegisterTrap(EL1, '00', op2, op1, '0100', '11111', CRm, '0');"])]
          [Ps "aarch64/instrs/system/register/cpsr" (Just PsExecute)
             "case field of\n    when PSTATEField_SP    \n        PSTATE.SP = operand<0>;\n    when PSTATEField_DAIFSet\n        PSTATE.D = PSTATE.D OR operand<3>;\n        PSTATE.A = PSTATE.A OR operand<2>;\n        PSTATE.I = PSTATE.I OR operand<1>;\n        PSTATE.F = PSTATE.F OR operand<0>;\n    when PSTATEField_DAIFClr\n        PSTATE.D = PSTATE.D AND NOT(operand<3>);\n        PSTATE.A = PSTATE.A AND NOT(operand<2>);\n        PSTATE.I = PSTATE.I AND NOT(operand<1>);\n        PSTATE.F = PSTATE.F AND NOT(operand<0>);\n    when PSTATEField_PAN\n        PSTATE.PAN = operand<0>;\n    when PSTATEField_UAO\n        PSTATE.UAO = operand<0>;"]),
     Right
       (Page "MSR_reg" []
          [(Class "MSR_SR_system" Nothing
              (Diagram "aarch64/instrs/system/register/system"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "o0") (BlockEq [X]),
                  Block (Just "op1") (BlockEq [X, X, X]),
                  Block (Just "CRn") (BlockEq [X, X, X, X]),
                  Block (Just "CRm") (BlockEq [X, X, X, X]),
                  Block (Just "op2") (BlockEq [X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "MSR_SR_system" []
                 "MSR  (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>"
                 [Symbol "<systemreg>" "CRm:CRn:o0:op1:op2" Nothing,
                  Symbol "<op0>" "o0"
                    (Just
                       (Table ["o0"]
                          [TableRow "2" [[O]] Nothing, TableRow "3" [[I]] Nothing])),
                  Symbol "<op1>" "op1" Nothing, Symbol "<Cn>" "CRn" Nothing,
                  Symbol "<Cm>" "CRm" Nothing, Symbol "<op2>" "op2" Nothing,
                  Symbol "<Xt>" "Rt" Nothing]],
            [Ps "aarch64/instrs/system/register/system" (Just PsDecode)
               "AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 2 + UInt(o0);\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean read = (L == '1');"])]
          [Ps "aarch64/instrs/system/register/system" (Just PsExecute)
             "if read then\n    X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"]),
     Right
       (Page "MSUB" ["MNEG_MSUB"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/mul/uniform/add-sub"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "op54") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, O, I, I]),
                  Block (Just "op31") (BlockEq [O, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MSUB_32A_dp_3src" [("sf", BlockEq [O])]
                 "MSUB  <Wd>, <Wn>, <Wm>, <Wa>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Wa>" "Ra" Nothing],
               Encoding "MSUB_64A_dp_3src" [("sf", BlockEq [I])]
                 "MSUB  <Xd>, <Xn>, <Xm>, <Xa>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<Xa>" "Ra" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/mul/uniform/add-sub"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = if sf == '1' then 64 else 32;\ninteger datasize = destsize;\nboolean sub_op = (o0 == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/mul/uniform/add-sub"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));\nelse\n    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));\n\nX[d] = result<destsize-1:0>;"]),
     Left
       (AliasPage "MUL_MADD" "MADD"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/mul/uniform/add-sub"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "op54") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, O, I, I]),
                 Block (Just "op31") (BlockEq [O, O, O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "o0") (BlockEq [O]),
                 Block (Just "Ra") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MUL_MADD_32A_dp_3src" [("sf", BlockEq [O])]
                "MUL  <Wd>, <Wn>, <Wm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<Wm>" "Rm" Nothing],
              Encoding "MUL_MADD_64A_dp_3src" [("sf", BlockEq [I])]
                "MUL  <Xd>, <Xn>, <Xm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<Xm>" "Rm" Nothing]])),
     Left
       (AliasPage "MVN_ORN_log_shift" "ORN_log_shift"
          (Class "no_s" Nothing
             (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, I]),
                 Block Nothing (BlockEq [O, I, O, I, O]),
                 Block (Just "shift") (BlockEq [X, X]),
                 Block (Just "N") (BlockEq [I]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MVN_ORN_32_log_shift" [("sf", BlockEq [O])]
                "MVN  <Wd>, <Wm>{, <shift> #<amount>}"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "ROR" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing],
              Encoding "MVN_ORN_64_log_shift" [("sf", BlockEq [I])]
                "MVN  <Xd>, <Xm>{, <shift> #<amount>}"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "ROR" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing]])),
     Left
       (AliasPage "NEG_SUB_addsub_shift" "SUB_addsub_shift"
          (Class "no_s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [O, I, O, I, I]),
                 Block (Just "shift") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "NEG_SUB_32_addsub_shift" [("sf", BlockEq [O])]
                "NEG  <Wd>, <Wm>{, <shift> #<amount>}"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "RESERVED" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing],
              Encoding "NEG_SUB_64_addsub_shift" [("sf", BlockEq [I])]
                "NEG  <Xd>, <Xm>{, <shift> #<amount>}"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "RESERVED" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing]])),
     Left
       (AliasPage "NEGS_SUBS_addsub_shift" "SUBS_addsub_shift"
          (Class "s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                 Block (Just "S") (BlockEq [I]),
                 Block Nothing (BlockEq [O, I, O, I, I]),
                 Block (Just "shift") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "NEGS_SUBS_32_addsub_shift" [("sf", BlockEq [O])]
                "NEGS  <Wd>, <Wm>{, <shift> #<amount>}"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "RESERVED" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing],
              Encoding "NEGS_SUBS_64_addsub_shift" [("sf", BlockEq [I])]
                "NEGS  <Xd>, <Xm>{, <shift> #<amount>}"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "RESERVED" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing]])),
     Left
       (AliasPage "NGC_SBC" "SBC"
          (Class "no_s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/carry"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, O, O, O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "opcode2") (BlockEq [O, O, O, O, O, O]),
                 Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "NGC_SBC_32_addsub_carry" [("sf", BlockEq [O])]
                "NGC  <Wd>, <Wm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wm>" "Rm" Nothing],
              Encoding "NGC_SBC_64_addsub_carry" [("sf", BlockEq [I])]
                "NGC  <Xd>, <Xm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xm>" "Rm" Nothing]])),
     Left
       (AliasPage "NGCS_SBCS" "SBCS"
          (Class "s" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/add-sub/carry"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                 Block (Just "S") (BlockEq [I]),
                 Block Nothing (BlockEq [I, I, O, I, O, O, O, O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "opcode2") (BlockEq [O, O, O, O, O, O]),
                 Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "NGCS_SBCS_32_addsub_carry" [("sf", BlockEq [O])]
                "NGCS  <Wd>, <Wm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wm>" "Rm" Nothing],
              Encoding "NGCS_SBCS_64_addsub_carry" [("sf", BlockEq [I])]
                "NGCS  <Xd>, <Xm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xm>" "Rm" Nothing]])),
     Right
       (Page "NOP" []
          [(Class "NOP_HI_system" Nothing
              (Diagram "aarch64/instrs/system/hints"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, O, O]),
                  Block (Just "op2") (BlockEq [O, O, O]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "NOP_HI_system" [] "NOP" []],
            [Ps "aarch64/instrs/system/hints" (Just PsDecode)
               "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 111'\n        SEE \"XPACLRI\";\n    when '0001 xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0011 xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                // Instruction executes as NOP"])]
          [Ps "aarch64/instrs/system/hints" (Just PsExecute)
             "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"]),
     Right
       (Page "ORN_log_shift" ["MVN_ORN_log_shift"]
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, I, O, I, O]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "N") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ORN_32_log_shift" [("sf", BlockEq [O])]
                 "ORN  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "ORN_64_log_shift" [("sf", BlockEq [I])]
                 "ORN  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');"])]
          [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"]),
     Right
       (Page "ORR_log_imm" ["MOV_ORR_log_imm"]
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/logical/immediate"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, O, O, I, O, O]),
                  Block (Just "N") (BlockEq [X]),
                  Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ORR_32_log_imm"
                 [("sf", BlockEq [O]), ("N", BlockEq [O])]
                 "ORR  <Wd|WSP>, <Wn>, #<imm>"
                 [Symbol "<Wd|WSP>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<imm>" "immr:imms" Nothing],
               Encoding "ORR_64_log_imm" [("sf", BlockEq [I])]
                 "ORR  <Xd|SP>, <Xn>, #<imm>"
                 [Symbol "<Xd|SP>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<imm>" "N:immr:imms" Nothing]],
            [Ps "aarch64/instrs/integer/logical/immediate" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);"])]
          [Ps "aarch64/instrs/integer/logical/immediate" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "ORR_log_shift" ["MOV_ORR_log_shift"]
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, I, O, I, O]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "N") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ORR_32_log_shift" [("sf", BlockEq [O])]
                 "ORR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "ORR_64_log_shift" [("sf", BlockEq [I])]
                 "ORR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "ROR" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\n\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');"])]
          [Ps "aarch64/instrs/integer/logical/shiftedreg" (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\n\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\n\nX[d] = result;"]),
     Right
       (Page "PACDA" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/pacda/dp_1src"
                 [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, I]),
                  Block (Just "opcode[5]") (BlockEq [O]),
                  Block (Just "opcode[4]") (BlockEq [O]),
                  Block (Just "Z") (BlockEq [X]),
                  Block (Just "opcode[2:0]") (BlockEq [O, I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "PACDA_64P_dp_1src" [("Z", BlockEq [O])]
                 "PACDA  <Xd>, <Xn|SP>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "PACDZA_64Z_dp_1src"
                 [("Z", BlockEq [I]), ("Rn", BlockEq [I, I, I, I, I])]
                 "PACDZA  <Xd>"
                 [Symbol "<Xd>" "Rd" Nothing]],
            [Ps "aarch64/instrs/integer/pac/pacda/dp_1src" (Just PsDecode)
               "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UnallocatedEncoding();\n\nif Z == '0' then // PACDA\n    if n == 31 then source_is_sp = TRUE;\nelse // PACDZA\n    if n != 31 then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/integer/pac/pacda/dp_1src" (Just PsExecute)
             "if source_is_sp then\n    X[d] = AddPACDA(X[d], SP[]);\nelse\n    X[d] = AddPACDA(X[d], X[n]);"]),
     Right
       (Page "PACDB" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/pacdb/dp_1src"
                 [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, I]),
                  Block (Just "opcode[5]") (BlockEq [O]),
                  Block (Just "opcode[4]") (BlockEq [O]),
                  Block (Just "Z") (BlockEq [X]),
                  Block (Just "opcode[2:0]") (BlockEq [O, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "PACDB_64P_dp_1src" [("Z", BlockEq [O])]
                 "PACDB  <Xd>, <Xn|SP>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "PACDZB_64Z_dp_1src"
                 [("Z", BlockEq [I]), ("Rn", BlockEq [I, I, I, I, I])]
                 "PACDZB  <Xd>"
                 [Symbol "<Xd>" "Rd" Nothing]],
            [Ps "aarch64/instrs/integer/pac/pacdb/dp_1src" (Just PsDecode)
               "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UnallocatedEncoding();\n\nif Z == '0' then // PACDB\n    if n == 31 then source_is_sp = TRUE;\nelse // PACDZB\n    if n != 31 then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/integer/pac/pacdb/dp_1src" (Just PsExecute)
             "if source_is_sp then\n    X[d] = AddPACDB(X[d], SP[]);\nelse\n    X[d] = AddPACDB(X[d], X[n]);"]),
     Right
       (Page "PACGA" []
          [(Class "PACGA_64P_dp_2src" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/pacga/dp_2src"
                 [Block (Just "sf") (BlockEq [I]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2") (BlockEq [O, O, I, I, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "PACGA_64P_dp_2src" [] "PACGA  <Xd>, <Xn>, <Xm|SP>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm|SP>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/pac/pacga/dp_2src" (Just PsDecode)
               "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif !HavePACExt() then\n    UnallocatedEncoding();\n\nif m == 31 then source_is_sp = TRUE;"])]
          [Ps "aarch64/instrs/integer/pac/pacga/dp_2src" (Just PsExecute)
             "if source_is_sp then\n    X[d] = AddPACGA(X[n], SP[]);\nelse\n    X[d] = AddPACGA(X[n], X[m]);"]),
     Right
       (Page "PACIA" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/pacia/dp_1src"
                 [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, I]),
                  Block (Just "opcode[5]") (BlockEq [O]),
                  Block (Just "opcode[4]") (BlockEq [O]),
                  Block (Just "Z") (BlockEq [X]),
                  Block (Just "opcode[2:0]") (BlockEq [O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "PACIA_64P_dp_1src" [("Z", BlockEq [O])]
                 "PACIA  <Xd>, <Xn|SP>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "PACIZA_64Z_dp_1src"
                 [("Z", BlockEq [I]), ("Rn", BlockEq [I, I, I, I, I])]
                 "PACIZA  <Xd>"
                 [Symbol "<Xd>" "Rd" Nothing]],
            [Ps "aarch64/instrs/integer/pac/pacia/dp_1src" (Just PsDecode)
               "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UnallocatedEncoding();\n\nif Z == '0' then // PACIA\n    if n == 31 then source_is_sp = TRUE;\nelse // PACIZA\n    if n != 31 then UnallocatedEncoding();"]),
           (Class "system" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/pacia/hint"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, X, I]),
                  Block (Just "op2") (BlockEq [O, O, X]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "PACIA1716_HI_system"
                 [("CRm", BlockEq [O, O, O, I]), ("op2", BlockEq [O, O, O])]
                 "PACIA1716"
                 [],
               Encoding "PACIASP_HI_system"
                 [("CRm", BlockEq [O, O, I, I]), ("op2", BlockEq [O, O, I])]
                 "PACIASP"
                 [],
               Encoding "PACIAZ_HI_system"
                 [("CRm", BlockEq [O, O, I, I]), ("op2", BlockEq [O, O, O])]
                 "PACIAZ"
                 []],
            [Ps "aarch64/instrs/integer/pac/pacia/hint" (Just PsDecode)
               "integer d;\ninteger n;\nboolean source_is_sp = FALSE;\n\ncase CRm:op2 of\n    when '0011 000' // PACIAZ \n        d = 30;\n        n = 31;\n    when '0011 001' // PACIASP\n        d = 30;\n        source_is_sp = TRUE;\n    when '0001 000' // PACIA1716\n        d = 17;\n        n = 16;\n    when '0001 010' SEE \"PACIB\";\n    when '0001 100' SEE \"AUTIA\";\n    when '0001 110' SEE \"AUTIB\";\n    when '0011 01x' SEE \"PACIB\";\n    when '0011 10x' SEE \"AUTIA\";\n    when '0011 11x' SEE \"AUTIB\";\n    when '0000 111' SEE \"XPACLRI\";"])]
          [Ps "aarch64/instrs/integer/pac/pacia/dp_1src" (Just PsExecute)
             "if HavePACExt() then\n    if source_is_sp then\n        X[d] = AddPACIA(X[d], SP[]);\n    else\n        X[d] = AddPACIA(X[d], X[n]);"]),
     Right
       (Page "PACIB" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/pacib/dp_1src"
                 [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, I]),
                  Block (Just "opcode[5]") (BlockEq [O]),
                  Block (Just "opcode[4]") (BlockEq [O]),
                  Block (Just "Z") (BlockEq [X]),
                  Block (Just "opcode[2:0]") (BlockEq [O, O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "PACIB_64P_dp_1src" [("Z", BlockEq [O])]
                 "PACIB  <Xd>, <Xn|SP>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "PACIZB_64Z_dp_1src"
                 [("Z", BlockEq [I]), ("Rn", BlockEq [I, I, I, I, I])]
                 "PACIZB  <Xd>"
                 [Symbol "<Xd>" "Rd" Nothing]],
            [Ps "aarch64/instrs/integer/pac/pacib/dp_1src" (Just PsDecode)
               "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UnallocatedEncoding();\n\nif Z == '0' then // PACIB\n    if n == 31 then source_is_sp = TRUE;\nelse // PACIZB\n    if n != 31 then UnallocatedEncoding();"]),
           (Class "system" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/pacib/hint"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, X, I]),
                  Block (Just "op2") (BlockEq [O, I, X]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "PACIB1716_HI_system"
                 [("CRm", BlockEq [O, O, O, I]), ("op2", BlockEq [O, I, O])]
                 "PACIB1716"
                 [],
               Encoding "PACIBSP_HI_system"
                 [("CRm", BlockEq [O, O, I, I]), ("op2", BlockEq [O, I, I])]
                 "PACIBSP"
                 [],
               Encoding "PACIBZ_HI_system"
                 [("CRm", BlockEq [O, O, I, I]), ("op2", BlockEq [O, I, O])]
                 "PACIBZ"
                 []],
            [Ps "aarch64/instrs/integer/pac/pacib/hint" (Just PsDecode)
               "integer d;\ninteger n;\nboolean source_is_sp = FALSE;\n\ncase CRm:op2 of\n    when '0011 010' // PACIBZ\n        d = 30;\n        n = 31;\n    when '0011 011' // PACIBSP\n        d = 30;\n        source_is_sp = TRUE;\n    when '0001 010' // PACIB1716\n        d = 17;\n        n = 16;\n    when '0001 000' SEE \"PACIA\";\n    when '0001 100' SEE \"AUTIA\";\n    when '0001 110' SEE \"AUTIB\";\n    when '0011 00x' SEE \"PACIA\";\n    when '0011 10x' SEE \"AUTIA\";\n    when '0011 11x' SEE \"AUTIB\";\n    when '0000 111' SEE \"XPACLRI\";"])]
          [Ps "aarch64/instrs/integer/pac/pacib/dp_1src" (Just PsExecute)
             "if HavePACExt() then\n    if source_is_sp then\n        X[d] = AddPACIB(X[d], SP[]);\n    else\n        X[d] = AddPACIB(X[d], X[n]);"]),
     Right
       (Page "PRFM_imm" []
          [(Class "PRFM_P_ldst_pos" Nothing
              (Diagram "aarch64/instrs/memory/single/general/immediate/unsigned"
                 [Block (Just "size") (BlockEq [I, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [I, O]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "PRFM_P_ldst_pos" []
                 "PRFM  (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<prfop>" "Rt" Nothing, Symbol "<imm5>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "PRFM_lit" []
          [(Class "PRFM_P_loadlit" Nothing
              (Diagram "aarch64/instrs/memory/literal/general"
                 [Block (Just "opc") (BlockEq [I, I]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "imm19")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "PRFM_P_loadlit" [] "PRFM  (<prfop>|#<imm5>), <label>"
                 [Symbol "<prfop>" "Rt" Nothing, Symbol "<imm5>" "Rt" Nothing,
                  Symbol "<label>" "imm19" Nothing]],
            [Ps "aarch64/instrs/memory/literal/general" (Just PsDecode)
               "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\n\noffset = SignExtend(imm19:'00', 64);"])]
          [Ps "aarch64/instrs/memory/literal/general" (Just PsExecute)
             "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);"]),
     Right
       (Page "PRFM_reg" []
          [(Class "PRFM_P_ldst_regoff" Nothing
              (Diagram "aarch64/instrs/memory/single/general/register"
                 [Block (Just "size") (BlockEq [I, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "PRFM_P_ldst_regoff" []
                 "PRFM  (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<prfop>" "Rt" Nothing, Symbol "<imm5>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#3" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/memory/single/general/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/general/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "PRFUM" []
          [(Class "PRFUM_P_ldst_unscaled" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [I, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [I, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "PRFUM_P_ldst_unscaled" []
                 "PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]"
                 [Symbol "<prfop>" "Rt" Nothing, Symbol "<imm5>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "PSB" []
          [(Class "PSB_HC_system" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/system/hints"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, I, O]),
                  Block (Just "op2") (BlockEq [O, O, I]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "PSB_HC_system" [] "PSB CSYNC" []],
            [Ps "aarch64/instrs/system/hints" (Just PsDecode)
               "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 111'\n        SEE \"XPACLRI\";\n    when '0001 xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0011 xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                // Instruction executes as NOP"])]
          [Ps "aarch64/instrs/system/hints" (Just PsExecute)
             "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"]),
     Right
       (Page "RBIT_int" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/rbit"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "opcode[1:0]") (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "RBIT_32_dp_1src" [("sf", BlockEq [O])]
                 "RBIT  <Wd>, <Wn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "RBIT_64_dp_1src" [("sf", BlockEq [I])] "RBIT  <Xd>, <Xn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/rbit" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;"])]
          [Ps "aarch64/instrs/integer/arithmetic/rbit" (Just PsExecute)
             "bits(datasize) operand = X[n];\nbits(datasize) result;\n\nfor i = 0 to datasize-1\n    result<datasize-1-i> = operand<i>;\n\nX[d] = result;"]),
     Right
       (Page "RET" []
          [(Class "RET_64R_branch_reg" Nothing
              (Diagram "aarch64/instrs/branch/unconditional/register"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, I]),
                  Block (Just "Z") (BlockEq [O]),
                  Block (Just "opc[2:1]") (BlockEq [O]),
                  Block (Just "op") (BlockEq [I, O]),
                  Block (Just "op2") (BlockEq [I, I, I, I, I]),
                  Block (Just "op3[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "A") (BlockEq [O]), Block (Just "M") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rm") (BlockEq [O, O, O, O, O])])
              [Encoding "RET_64R_branch_reg" [] "RET  {<Xn>}"
                 [Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/branch/unconditional/register" (Just PsDecode)
               "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\n\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\n\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;"])]
          [Ps "aarch64/instrs/branch/unconditional/register" (Just PsExecute)
             "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);"]),
     Right
       (Page "RETA" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/branch/unconditional/register"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, I]),
                  Block (Just "Z") (BlockEq [O]),
                  Block (Just "opc[2:1]") (BlockEq [O]),
                  Block (Just "op") (BlockEq [I, O]),
                  Block (Just "op2") (BlockEq [I, I, I, I, I]),
                  Block (Just "op3[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "A") (BlockEq [I]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rm") (BlockEq [I, I, I, I, I])])
              [Encoding "RETAA_64E_branch_reg" [("M", BlockEq [O])] "RETAA" [],
               Encoding "RETAB_64E_branch_reg" [("M", BlockEq [I])] "RETAB" []],
            [Ps "aarch64/instrs/branch/unconditional/register" (Just PsDecode)
               "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\n\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\n\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\n\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;"])]
          [Ps "aarch64/instrs/branch/unconditional/register" (Just PsExecute)
             "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);"]),
     Right
       (Page "REV" ["REV64_REV"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/rev"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "opc") (BlockEq [I, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "REV_32_dp_1src"
                 [("sf", BlockEq [O]), ("opc", BlockEq [I, O])]
                 "REV  <Wd>, <Wn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "REV_64_dp_1src"
                 [("sf", BlockEq [I]), ("opc", BlockEq [I, I])]
                 "REV  <Xd>, <Xn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/rev" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;\n\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UnallocatedEncoding();\n        container_size = 64;"])]
          [Ps "aarch64/instrs/integer/arithmetic/rev" (Just PsExecute)
             "bits(datasize) operand = X[n];\nbits(datasize) result;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n\nX[d] = result;"]),
     Right
       (Page "REV16_int" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/rev"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "opc") (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "REV16_32_dp_1src" [("sf", BlockEq [O])]
                 "REV16  <Wd>, <Wn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "REV16_64_dp_1src" [("sf", BlockEq [I])]
                 "REV16  <Xd>, <Xn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/rev" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;\n\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UnallocatedEncoding();\n        container_size = 64;"])]
          [Ps "aarch64/instrs/integer/arithmetic/rev" (Just PsExecute)
             "bits(datasize) operand = X[n];\nbits(datasize) result;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n\nX[d] = result;"]),
     Right
       (Page "REV32_int" []
          [(Class "REV32_64_dp_1src" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/rev"
                 [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode[5:2]") (BlockEq [O, O, O, O]),
                  Block (Just "opc") (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "REV32_64_dp_1src" [] "REV32  <Xd>, <Xn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/rev" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize = if sf == '1' then 64 else 32;\n\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UnallocatedEncoding();\n        container_size = 64;"])]
          [Ps "aarch64/instrs/integer/arithmetic/rev" (Just PsExecute)
             "bits(datasize) operand = X[n];\nbits(datasize) result;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n\nX[d] = result;"]),
     Left
       (AliasPage "REV64_REV" "REV"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/rev"
                [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                 Block (Just "opcode2") (BlockEq [O, O, O, O, O]),
                 Block (Just "opcode[5:2]") (BlockEq [O, O, O, O]),
                 Block (Just "opc") (BlockEq [I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "REV64_REV_64_dp_1src" [] "REV64  <Xd>, <Xn>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing]])),
     Left
       (AliasPage "ROR_EXTR" "EXTR"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/ins-ext/extract/immediate"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "op21") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, I]),
                 Block (Just "N") (BlockEq [X]), Block (Just "o0") (BlockEq [O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "ROR_EXTR_32_extract"
                [("sf", BlockEq [O]), ("N", BlockEq [O]),
                 ("imms", BlockEq [O, X, X, X, X, X])]
                "ROR  <Wd>, <Ws>, #<shift>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Ws>" "Rm:Rn" Nothing,
                 Symbol "<shift>" "imms" Nothing],
              Encoding "ROR_EXTR_64_extract"
                [("sf", BlockEq [I]), ("N", BlockEq [I])]
                "ROR  <Xd>, <Xs>, #<shift>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xs>" "Rm:Rn" Nothing,
                 Symbol "<shift>" "imms" Nothing]])),
     Left
       (AliasPage "ROR_RORV" "RORV"
          (Class "general" Nothing
             (Diagram "aarch64/instrs/integer/shift/variable"
                [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                 Block (Just "S") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "opcode2<5:2>") (BlockEq [O, O, I, O]),
                 Block (Just "op2") (BlockEq [I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "ROR_RORV_32_dp_2src" [("sf", BlockEq [O])]
                "ROR  <Wd>, <Wn>, <Wm>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<Wm>" "Rm" Nothing],
              Encoding "ROR_RORV_64_dp_2src" [("sf", BlockEq [I])]
                "ROR  <Xd>, <Xn>, <Xm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<Xm>" "Rm" Nothing]])),
     Right
       (Page "RORV" ["ROR_RORV"]
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/shift/variable"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2<5:2>") (BlockEq [O, O, I, O]),
                  Block (Just "op2") (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "RORV_32_dp_2src" [("sf", BlockEq [O])]
                 "RORV  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "RORV_64_dp_2src" [("sf", BlockEq [I])]
                 "RORV  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/shift/variable" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);"])]
          [Ps "aarch64/instrs/integer/shift/variable" (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand2 = X[m];\n\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;"]),
     Right
       (Page "SBC" ["NGC_SBC"]
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/carry"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, O, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SBC_32_addsub_carry" [("sf", BlockEq [O])]
                 "SBC  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "SBC_64_addsub_carry" [("sf", BlockEq [I])]
                 "SBC  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/carry"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/carry"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"]),
     Right
       (Page "SBCS" ["NGCS_SBCS"]
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/carry"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, O, I, O, O, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SBCS_32_addsub_carry" [("sf", BlockEq [O])]
                 "SBCS  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "SBCS_64_addsub_carry" [("sf", BlockEq [I])]
                 "SBCS  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/carry"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/carry"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\n\nif sub_op then\n    operand2 = NOT(operand2);\n\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"]),
     Left
       (AliasPage "SBFIZ_SBFM" "SBFM"
          (Class "signed_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "SBFIZ_SBFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "SBFIZ  <Wd>, <Wn>, #<lsb>, #<width>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing],
              Encoding "SBFIZ_SBFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I])]
                "SBFIZ  <Xd>, <Xn>, #<lsb>, #<width>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing]])),
     Right
       (Page "SBFM"
          ["ASR_SBFM", "SBFIZ_SBFM", "SBFX_SBFM", "SXTB_SBFM", "SXTH_SBFM",
           "SXTW_SBFM"]
          [(Class "signed_fill" Nothing
              (Diagram "aarch64/instrs/integer/bitfield"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, O, I, I, O]),
                  Block (Just "N") (BlockEq [X]),
                  Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SBFM_32M_bitfield"
                 [("sf", BlockEq [O]), ("N", BlockEq [O])]
                 "SBFM  <Wd>, <Wn>, #<immr>, #<imms>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<immr>" "immr" Nothing, Symbol "<imms>" "imms" Nothing],
               Encoding "SBFM_64M_bitfield"
                 [("sf", BlockEq [I]), ("N", BlockEq [I])]
                 "SBFM  <Xd>, <Xn>, #<immr>, #<imms>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<immr>" "immr" Nothing, Symbol "<imms>" "imms" Nothing]],
            [Ps "aarch64/instrs/integer/bitfield" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\n\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\n\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    // SBFM\n    when '01' inzero = FALSE; extend = FALSE;   // BFM\n    when '10' inzero = TRUE;  extend = FALSE;   // UBFM\n    when '11' UnallocatedEncoding();\n\nif sf == '1' && N != '1' then ReservedValue();\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();\n\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);"])]
          [Ps "aarch64/instrs/integer/bitfield" (Just PsExecute)
             "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\n\n// perform bitfield move on low bits\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\n\n// determine extension bits (sign, zero or dest register)\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\n\n// combine extension bits and result bits\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);"]),
     Left
       (AliasPage "SBFX_SBFM" "SBFM"
          (Class "signed_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "SBFX_SBFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "SBFX  <Wd>, <Wn>, #<lsb>, #<width>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing],
              Encoding "SBFX_SBFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I])]
                "SBFX  <Xd>, <Xn>, #<lsb>, #<width>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing]])),
     Right
       (Page "SDIV" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/div"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2<5:1>") (BlockEq [O, O, O, O, I]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SDIV_32_dp_2src" [("sf", BlockEq [O])]
                 "SDIV  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "SDIV_64_dp_2src" [("sf", BlockEq [I])]
                 "SDIV  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/div" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean unsigned = (o1 == '0');"])]
          [Ps "aarch64/instrs/integer/arithmetic/div" (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\ninteger result;\n\nif IsZero(operand2) then\n    result = 0;\nelse\n    result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));\n\nX[d] = result<datasize-1:0>;"]),
     Right
       (Page "SEV" []
          [(Class "SEV_HI_system" Nothing
              (Diagram "aarch64/instrs/system/hints"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, O, O]),
                  Block (Just "op2") (BlockEq [I, O, O]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "SEV_HI_system" [] "SEV" []],
            [Ps "aarch64/instrs/system/hints" (Just PsDecode)
               "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 111'\n        SEE \"XPACLRI\";\n    when '0001 xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0011 xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                // Instruction executes as NOP"])]
          [Ps "aarch64/instrs/system/hints" (Just PsExecute)
             "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"]),
     Right
       (Page "SEVL" []
          [(Class "SEVL_HI_system" Nothing
              (Diagram "aarch64/instrs/system/hints"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, O, O]),
                  Block (Just "op2") (BlockEq [I, O, I]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "SEVL_HI_system" [] "SEVL" []],
            [Ps "aarch64/instrs/system/hints" (Just PsDecode)
               "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 111'\n        SEE \"XPACLRI\";\n    when '0001 xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0011 xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                // Instruction executes as NOP"])]
          [Ps "aarch64/instrs/system/hints" (Just PsExecute)
             "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"]),
     Right
       (Page "SMADDL" ["SMULL_SMADDL"]
          [(Class "SMADDL_64WA_dp_3src" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
                 [Block (Just "sf") (BlockEq [I]),
                  Block (Just "op54") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, O, I, I]),
                  Block (Just "U") (BlockEq [O]), Block Nothing (BlockEq [O, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMADDL_64WA_dp_3src" [] "SMADDL  <Xd>, <Wn>, <Wm>, <Xa>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xa>" "Ra" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"]),
     Right
       (Page "SMC" []
          [(Class "SMC_EX_exception" Nothing
              (Diagram "aarch64/instrs/system/exceptions/runtime/smc"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "opc") (BlockEq [O, O, O]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "op2") (BlockEq [O, O, O]),
                  Block (Just "LL") (BlockEq [I, I])])
              [Encoding "SMC_EX_exception" [] "SMC  #<imm>"
                 [Symbol "<imm>" "imm16" Nothing]],
            [Ps "aarch64/instrs/system/exceptions/runtime/smc" (Just PsDecode)
               "bits(16) imm = imm16;"])]
          [Ps "aarch64/instrs/system/exceptions/runtime/smc" (Just PsExecute)
             "AArch64.CheckForSMCUndefOrTrap(imm);\n\nif SCR_EL3.SMD == '1' then\n    // SMC disabled\n    AArch64.UndefinedFault();\nelse\n    AArch64.CallSecureMonitor(imm);"]),
     Left
       (AliasPage "SMNEGL_SMSUBL" "SMSUBL"
          (Class "SMSUBL_64WA_dp_3src" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
                [Block (Just "sf") (BlockEq [I]),
                 Block (Just "op54") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, O, I, I]),
                 Block (Just "U") (BlockEq [O]), Block Nothing (BlockEq [O, I]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "o0") (BlockEq [I]),
                 Block (Just "Ra") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "SMNEGL_SMSUBL_64WA_dp_3src" []
                "SMNEGL  <Xd>, <Wn>, <Wm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<Wm>" "Rm" Nothing]])),
     Right
       (Page "SMSUBL" ["SMNEGL_SMSUBL"]
          [(Class "SMSUBL_64WA_dp_3src" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
                 [Block (Just "sf") (BlockEq [I]),
                  Block (Just "op54") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, O, I, I]),
                  Block (Just "U") (BlockEq [O]), Block Nothing (BlockEq [O, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMSUBL_64WA_dp_3src" [] "SMSUBL  <Xd>, <Wn>, <Wm>, <Xa>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xa>" "Ra" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"]),
     Right
       (Page "SMULH" []
          [(Class "SMULH_64_dp_3src" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/mul/widening/64-128hi"
                 [Block (Just "sf") (BlockEq [I]),
                  Block (Just "op54") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, O, I, I]),
                  Block (Just "U") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Ra") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMULH_64_dp_3src" [] "SMULH  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/mul/widening/64-128hi"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);           // ignored by UMULH/SMULH\ninteger destsize = 64;\ninteger datasize = destsize;\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/mul/widening/64-128hi"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\ninteger result;\n\nresult = Int(operand1, unsigned) * Int(operand2, unsigned);\n\nX[d] = result<127:64>;"]),
     Left
       (AliasPage "SMULL_SMADDL" "SMADDL"
          (Class "SMADDL_64WA_dp_3src" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
                [Block (Just "sf") (BlockEq [I]),
                 Block (Just "op54") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, O, I, I]),
                 Block (Just "U") (BlockEq [O]), Block Nothing (BlockEq [O, I]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "o0") (BlockEq [O]),
                 Block (Just "Ra") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "SMULL_SMADDL_64WA_dp_3src" [] "SMULL  <Xd>, <Wn>, <Wm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<Wm>" "Rm" Nothing]])),
     Left
       (AliasPage "STADD_LDADD" "LDADD"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [I, X]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, O, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STADD_LDADD_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [O])]
                "STADD  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STADDL_LDADDL_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [I])]
                "STADDL  <Ws>, [<Xn|SP>]"
                [],
              Encoding "STADD_LDADD_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [O])]
                "STADD  <Xs>, [<Xn|SP>]"
                [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STADDL_LDADDL_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [I])]
                "STADDL  <Xs>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STADDB_LDADDB" "LDADDB"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, O, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STADDB_LDADDB_32_memop" [("R", BlockEq [O])]
                "STADDB  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STADDLB_LDADDLB_32_memop" [("R", BlockEq [I])]
                "STADDLB  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STADDH_LDADDH" "LDADDH"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, O, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STADDH_LDADDH_32_memop" [("R", BlockEq [O])]
                "STADDH  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STADDLH_LDADDLH_32_memop" [("R", BlockEq [I])]
                "STADDLH  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STCLR_LDCLR" "LDCLR"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [I, X]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, O, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STCLR_LDCLR_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [O])]
                "STCLR  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STCLRL_LDCLRL_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [I])]
                "STCLRL  <Ws>, [<Xn|SP>]"
                [],
              Encoding "STCLR_LDCLR_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [O])]
                "STCLR  <Xs>, [<Xn|SP>]"
                [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STCLRL_LDCLRL_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [I])]
                "STCLRL  <Xs>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STCLRB_LDCLRB" "LDCLRB"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, O, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STCLRB_LDCLRB_32_memop" [("R", BlockEq [O])]
                "STCLRB  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STCLRLB_LDCLRLB_32_memop" [("R", BlockEq [I])]
                "STCLRLB  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STCLRH_LDCLRH" "LDCLRH"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, O, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STCLRH_LDCLRH_32_memop" [("R", BlockEq [O])]
                "STCLRH  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STCLRLH_LDCLRLH_32_memop" [("R", BlockEq [I])]
                "STCLRLH  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STEOR_LDEOR" "LDEOR"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [I, X]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, I, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STEOR_LDEOR_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [O])]
                "STEOR  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STEORL_LDEORL_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [I])]
                "STEORL  <Ws>, [<Xn|SP>]"
                [],
              Encoding "STEOR_LDEOR_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [O])]
                "STEOR  <Xs>, [<Xn|SP>]"
                [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STEORL_LDEORL_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [I])]
                "STEORL  <Xs>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STEORB_LDEORB" "LDEORB"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, I, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STEORB_LDEORB_32_memop" [("R", BlockEq [O])]
                "STEORB  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STEORLB_LDEORLB_32_memop" [("R", BlockEq [I])]
                "STEORLB  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STEORH_LDEORH" "LDEORH"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, I, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STEORH_LDEORH_32_memop" [("R", BlockEq [O])]
                "STEORH  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STEORLH_LDEORLH_32_memop" [("R", BlockEq [I])]
                "STEORLH  <Ws>, [<Xn|SP>]"
                []])),
     Right
       (Page "STLLR" []
          [(Class "base_register" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STLLR_SL32_ldstexcl" [("size", BlockEq [I, O])]
                 "STLLR  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "STLLR_SL64_ldstexcl" [("size", BlockEq [I, I])]
                 "STLLR  <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STLLRB" []
          [(Class "STLLRB_SL32_ldstexcl" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STLLRB_SL32_ldstexcl" [] "STLLRB  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STLLRH" []
          [(Class "STLLRH_SL32_ldstexcl" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STLLRH_SL32_ldstexcl" [] "STLLRH  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STLR" []
          [(Class "base_register" Nothing
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STLR_SL32_ldstexcl" [("size", BlockEq [I, O])]
                 "STLR  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "STLR_SL64_ldstexcl" [("size", BlockEq [I, I])]
                 "STLR  <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STLRB" []
          [(Class "STLRB_SL32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STLRB_SL32_ldstexcl" [] "STLRB  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STLRH" []
          [(Class "STLRH_SL32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/ordered"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [I, I, I, I, I]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STLRH_SL32_ldstexcl" [] "STLRH  <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/ordered" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;"])]
          [Ps "aarch64/instrs/memory/ordered" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STLXP" []
          [(Class "base_register" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/pair"
                 [Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STLXP_SP32_ldstexcl" [("sz", BlockEq [O])]
                 "STLXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt1>" "Rt" Nothing,
                  Symbol "<Wt2>" "Rt2" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "STLXP_SP64_ldstexcl" [("sz", BlockEq [I])]
                 "STLXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xt1>" "Rt" Nothing,
                  Symbol "<Xt2>" "Rt2" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/pair" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/pair" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STLXR" []
          [(Class "base_register" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STLXR_SR32_ldstexcl" [("size", BlockEq [I, O])]
                 "STLXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "STLXR_SR64_ldstexcl" [("size", BlockEq [I, I])]
                 "STLXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STLXRB" []
          [(Class "STLXRB_SR32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STLXRB_SR32_ldstexcl" []
                 "STLXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STLXRH" []
          [(Class "STLXRH_SR32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STLXRH_SR32_ldstexcl" []
                 "STLXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STNP_gen" []
          [(Class "signed_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/no-alloc"
                 [Block (Just "opc") (BlockEq [X, O]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STNP_32_ldstnapair_offs" [("opc", BlockEq [O, O])]
                 "STNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Wt1>" "Rt" Nothing, Symbol "<Wt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STNP_64_ldstnapair_offs" [("opc", BlockEq [I, O])]
                 "STNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/no-alloc" (Just PsDecode)
               "boolean wback  = FALSE;\nboolean postindex = FALSE;"])]
          [Ps "aarch64/instrs/memory/pair/general/no-alloc"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_STREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc<0> == '1' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);",
           Ps "aarch64/instrs/memory/pair/general/no-alloc" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        X[t]  = data1;\n        X[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STP_gen" []
          [(Class "post_indexed" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/post-idx"
                 [Block (Just "opc") (BlockEq [X, O]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, I]), Block (Just "L") (BlockEq [O]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STP_32_ldstpair_post" [("opc", BlockEq [O, O])]
                 "STP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>"
                 [Symbol "<Wt1>" "Rt" Nothing, Symbol "<Wt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STP_64_ldstpair_post" [("opc", BlockEq [I, O])]
                 "STP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/post-idx" (Just PsDecode)
               "boolean wback  = TRUE;\nboolean postindex = TRUE;"]),
           (Class "pre_indexed" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/pre-idx"
                 [Block (Just "opc") (BlockEq [X, O]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "L") (BlockEq [O]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STP_32_ldstpair_pre" [("opc", BlockEq [O, O])]
                 "STP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<Wt1>" "Rt" Nothing, Symbol "<Wt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STP_64_ldstpair_pre" [("opc", BlockEq [I, O])]
                 "STP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/pre-idx" (Just PsDecode)
               "boolean wback  = TRUE;\nboolean postindex = FALSE;"]),
           (Class "signed_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/pair/general/offset"
                 [Block (Just "opc") (BlockEq [X, O]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STP_32_ldstpair_off" [("opc", BlockEq [O, O])]
                 "STP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Wt1>" "Rt" Nothing, Symbol "<Wt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STP_64_ldstpair_off" [("opc", BlockEq [I, O])]
                 "STP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Xt1>" "Rt" Nothing, Symbol "<Xt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/general/offset" (Just PsDecode)
               "boolean wback  = FALSE;\nboolean postindex = FALSE;"])]
          [Ps "aarch64/instrs/memory/pair/general/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_NORMAL;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif L:opc<0> == '01' || opc == '11' then UnallocatedEncoding();\nboolean signed = (opc<0> != '0');\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);",
           Ps "aarch64/instrs/memory/pair/general/post-idx" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean wb_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        if signed then\n            X[t]  = SignExtend(data1, 64);\n            X[t2] = SignExtend(data2, 64);\n        else\n            X[t]  = data1;\n            X[t2] = data2;\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STR_imm_gen" []
          [(Class "post_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STR_32_ldst_immpost" [("size", BlockEq [I, O])]
                 "STR  <Wt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STR_64_ldst_immpost" [("size", BlockEq [I, I])]
                 "STR  <Xt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "pre_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STR_32_ldst_immpre" [("size", BlockEq [I, O])]
                 "STR  <Wt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STR_64_ldst_immpre" [("size", BlockEq [I, I])]
                 "STR  <Xt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "unsigned_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/single/general/immediate/unsigned"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [O, O]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STR_32_ldst_pos" [("size", BlockEq [I, O])]
                 "STR  <Wt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "STR_64_ldst_pos" [("size", BlockEq [I, I])]
                 "STR  <Xt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STR_reg_gen" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/memory/single/general/register"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STR_32_ldst_regoff" [("size", BlockEq [I, O])]
                 "STR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#2" [[I]] Nothing]))],
               Encoding "STR_64_ldst_regoff" [("size", BlockEq [I, I])]
                 "STR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#3" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/memory/single/general/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/general/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STRB_imm" []
          [(Class "STRB_32_ldst_immpost" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STRB_32_ldst_immpost" []
                 "STRB  <Wt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "STRB_32_ldst_immpre" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STRB_32_ldst_immpre" []
                 "STRB  <Wt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "STRB_32_ldst_pos" Nothing
              (Diagram "aarch64/instrs/memory/single/general/immediate/unsigned"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [O, O]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STRB_32_ldst_pos" [] "STRB  <Wt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STRB_reg" []
          [(Class "32" Nothing
              (Diagram "aarch64/instrs/memory/single/general/register"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STRB_32B_ldst_regoff" [("option", BlockNeq [O, I, I])]
                 "STRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S" Nothing],
               Encoding "STRB_32BL_ldst_regoff" [("option", BlockEq [O, I, I])]
                 "STRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<amount>" "S" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/general/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STRH_imm" []
          [(Class "STRH_32_ldst_immpost" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STRH_32_ldst_immpost" []
                 "STRH  <Wt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "STRH_32_ldst_immpre" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STRH_32_ldst_immpre" []
                 "STRH  <Wt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "STRH_32_ldst_pos" Nothing
              (Diagram "aarch64/instrs/memory/single/general/immediate/unsigned"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [O, O]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STRH_32_ldst_pos" [] "STRH  <Wt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/general/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/immediate/signed/post-idx"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STRH_reg" []
          [(Class "STRH_32_ldst_regoff" Nothing
              (Diagram "aarch64/instrs/memory/single/general/register"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STRH_32_ldst_regoff" []
                 "STRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#1" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/memory/single/general/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/general/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/general/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Left
       (AliasPage "STSET_LDSET" "LDSET"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [I, X]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, I, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STSET_LDSET_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [O])]
                "STSET  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSETL_LDSETL_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [I])]
                "STSETL  <Ws>, [<Xn|SP>]"
                [],
              Encoding "STSET_LDSET_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [O])]
                "STSET  <Xs>, [<Xn|SP>]"
                [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSETL_LDSETL_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [I])]
                "STSETL  <Xs>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STSETB_LDSETB" "LDSETB"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, I, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STSETB_LDSETB_32_memop" [("R", BlockEq [O])]
                "STSETB  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSETLB_LDSETLB_32_memop" [("R", BlockEq [I])]
                "STSETLB  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STSETH_LDSETH" "LDSETH"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [O, I, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STSETH_LDSETH_32_memop" [("R", BlockEq [O])]
                "STSETH  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSETLH_LDSETLH_32_memop" [("R", BlockEq [I])]
                "STSETLH  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STSMAX_LDSMAX" "LDSMAX"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [I, X]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, O, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STSMAX_LDSMAX_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [O])]
                "STSMAX  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSMAXL_LDSMAXL_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [I])]
                "STSMAXL  <Ws>, [<Xn|SP>]"
                [],
              Encoding "STSMAX_LDSMAX_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [O])]
                "STSMAX  <Xs>, [<Xn|SP>]"
                [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSMAXL_LDSMAXL_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [I])]
                "STSMAXL  <Xs>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STSMAXB_LDSMAXB" "LDSMAXB"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, O, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STSMAXB_LDSMAXB_32_memop" [("R", BlockEq [O])]
                "STSMAXB  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSMAXLB_LDSMAXLB_32_memop" [("R", BlockEq [I])]
                "STSMAXLB  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STSMAXH_LDSMAXH" "LDSMAXH"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, O, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STSMAXH_LDSMAXH_32_memop" [("R", BlockEq [O])]
                "STSMAXH  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSMAXLH_LDSMAXLH_32_memop" [("R", BlockEq [I])]
                "STSMAXLH  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STSMIN_LDSMIN" "LDSMIN"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [I, X]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, O, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STSMIN_LDSMIN_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [O])]
                "STSMIN  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSMINL_LDSMINL_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [I])]
                "STSMINL  <Ws>, [<Xn|SP>]"
                [],
              Encoding "STSMIN_LDSMIN_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [O])]
                "STSMIN  <Xs>, [<Xn|SP>]"
                [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSMINL_LDSMINL_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [I])]
                "STSMINL  <Xs>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STSMINB_LDSMINB" "LDSMINB"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, O, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STSMINB_LDSMINB_32_memop" [("R", BlockEq [O])]
                "STSMINB  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSMINLB_LDSMINLB_32_memop" [("R", BlockEq [I])]
                "STSMINLB  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STSMINH_LDSMINH" "LDSMINH"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, O, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STSMINH_LDSMINH_32_memop" [("R", BlockEq [O])]
                "STSMINH  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STSMINLH_LDSMINLH_32_memop" [("R", BlockEq [I])]
                "STSMINLH  <Ws>, [<Xn|SP>]"
                []])),
     Right
       (Page "STTR" []
          [(Class "base_plus_offset" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STTR_32_ldst_unpriv" [("size", BlockEq [I, O])]
                 "STTR  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STTR_64_ldst_unpriv" [("size", BlockEq [I, I])]
                 "STTR  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STTRB" []
          [(Class "STTRB_32_ldst_unpriv" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STTRB_32_ldst_unpriv" []
                 "STTRB  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STTRH" []
          [(Class "STTRH_32_ldst_unpriv" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STTRH_32_ldst_unpriv" []
                 "STTRH  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Left
       (AliasPage "STUMAX_LDUMAX" "LDUMAX"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [I, X]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, I, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STUMAX_LDUMAX_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [O])]
                "STUMAX  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STUMAXL_LDUMAXL_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [I])]
                "STUMAXL  <Ws>, [<Xn|SP>]"
                [],
              Encoding "STUMAX_LDUMAX_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [O])]
                "STUMAX  <Xs>, [<Xn|SP>]"
                [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STUMAXL_LDUMAXL_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [I])]
                "STUMAXL  <Xs>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STUMAXB_LDUMAXB" "LDUMAXB"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, I, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STUMAXB_LDUMAXB_32_memop" [("R", BlockEq [O])]
                "STUMAXB  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STUMAXLB_LDUMAXLB_32_memop" [("R", BlockEq [I])]
                "STUMAXLB  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STUMAXH_LDUMAXH" "LDUMAXH"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, I, O]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STUMAXH_LDUMAXH_32_memop" [("R", BlockEq [O])]
                "STUMAXH  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STUMAXLH_LDUMAXLH_32_memop" [("R", BlockEq [I])]
                "STUMAXLH  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STUMIN_LDUMIN" "LDUMIN"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [I, X]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, I, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STUMIN_LDUMIN_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [O])]
                "STUMIN  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STUMINL_LDUMINL_32_memop"
                [("size", BlockEq [I, O]), ("R", BlockEq [I])]
                "STUMINL  <Ws>, [<Xn|SP>]"
                [],
              Encoding "STUMIN_LDUMIN_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [O])]
                "STUMIN  <Xs>, [<Xn|SP>]"
                [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STUMINL_LDUMINL_64_memop"
                [("size", BlockEq [I, I]), ("R", BlockEq [I])]
                "STUMINL  <Xs>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STUMINB_LDUMINB" "LDUMINB"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, I, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STUMINB_LDUMINB_32_memop" [("R", BlockEq [O])]
                "STUMINB  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STUMINLB_LDUMINLB_32_memop" [("R", BlockEq [I])]
                "STUMINLB  <Ws>, [<Xn|SP>]"
                []])),
     Left
       (AliasPage "STUMINH_LDUMINH" "LDUMINH"
          (Class "general" (Just (ArchName "ARMv8.1"))
             (Diagram "aarch64/instrs/memory/atomicops/ld"
                [Block (Just "size") (BlockEq [O, I]),
                 Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                 Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [O]),
                 Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                 Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                 Block (Just "o3") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, I, I]),
                 Block Nothing (BlockEq [O, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rt") (BlockEq [I, I, I, I, I])])
             [Encoding "STUMINH_LDUMINH_32_memop" [("R", BlockEq [O])]
                "STUMINH  <Ws>, [<Xn|SP>]"
                [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
              Encoding "STUMINLH_LDUMINLH_32_memop" [("R", BlockEq [I])]
                "STUMINLH  <Ws>, [<Xn|SP>]"
                []])),
     Right
       (Page "STUR_gen" []
          [(Class "base_plus_offset" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STUR_32_ldst_unscaled" [("size", BlockEq [I, O])]
                 "STUR  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STUR_64_ldst_unscaled" [("size", BlockEq [I, I])]
                 "STUR  <Xt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STURB" []
          [(Class "STURB_32_ldst_unscaled" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STURB_32_ldst_unscaled" []
                 "STURB  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STURH" []
          [(Class "STURH_32_ldst_unscaled" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STURH_32_ldst_unscaled" []
                 "STURH  <Wt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Wt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\n\nif opc<1> == '0' then\n    // store or zero-extending load\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        // sign-extending load\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/general/immediate/signed/offset/normal"
             (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed\n        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value\n        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\n\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STXP" []
          [(Class "base_register" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/pair"
                 [Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STXP_SP32_ldstexcl" [("sz", BlockEq [O])]
                 "STXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt1>" "Rt" Nothing,
                  Symbol "<Wt2>" "Rt2" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "STXP_SP64_ldstexcl" [("sz", BlockEq [I])]
                 "STXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xt1>" "Rt" Nothing,
                  Symbol "<Xt2>" "Rt2" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/pair" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/pair" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STXR" []
          [(Class "base_register" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STXR_SR32_ldstexcl" [("size", BlockEq [I, O])]
                 "STXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "STXR_SR64_ldstexcl" [("size", BlockEq [I, I])]
                 "STXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STXRB" []
          [(Class "STXRB_SR32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STXRB_SR32_ldstexcl" []
                 "STXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "STXRH" []
          [(Class "STXRH_SR32_ldstexcl" Nothing
              (Diagram "aarch64/instrs/memory/exclusive/single"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [O, O, I, O, O, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Rt2") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STXRH_SR32_ldstexcl" []
                 "STXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/exclusive/single" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); // ignored by load/store single register\ninteger s = UInt(Rs);   // ignored by all loads and store-release\n\nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;"])]
          [Ps "aarch64/instrs/memory/exclusive/single" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\n\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value\n            when Constraint_NONE       rt_unknown = FALSE;   // store original value\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN\n            when Constraint_NONE       rn_unknown = FALSE;   // address is original base\n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\n\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n\n        bit status = '1';\n        // Check whether the Exclusives monitors are set to include the\n        // physical memory locations corresponding to virtual address\n        // range [address, address+dbytes-1].\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            // This atomic write will be rejected if it does not refer\n            // to the same physical locations after address translation.\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        X[s] = ZeroExtend(status, 32);\n\n    when MemOp_LOAD\n        // Tell the Exclusives monitors to record a sequence of one or more atomic\n        // memory reads from virtual address range [address, address+dbytes-1].\n        // The Exclusives monitor will only be set if all the reads are from the\n        // same dbytes-aligned physical address, to allow for the possibility of\n        // an atomicity break if the translation is changed between reads.\n        AArch64.SetExclusiveMonitors(address, dbytes);\n\n        if pair then\n            if rt_unknown then\n                // ConstrainedUNPREDICTABLE case\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                // 32-bit load exclusive pair (atomic)\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else // elsize == 64\n                // 64-bit load exclusive pair (not atomic),\n                // but must be 128-bit aligned\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "SUB_addsub_ext" []
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, O, I, I]),
                  Block (Just "opt") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "imm3") (BlockEq [X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUB_32_addsub_ext" [("sf", BlockEq [O])]
                 "SUB  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"
                 [Symbol "<Wd|WSP>" "Rd" Nothing, Symbol "<Wn|WSP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTB" [[O, O, O]] Nothing,
                           TableRow "UXTH" [[O, O, I]] Nothing,
                           TableRow "LSL|UXTW" [[O, I, O]] Nothing,
                           TableRow "UXTX" [[O, I, I]] Nothing,
                           TableRow "SXTB" [[I, O, O]] Nothing,
                           TableRow "SXTH" [[I, O, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "imm3" Nothing],
               Encoding "SUB_64_addsub_ext" [("sf", BlockEq [I])]
                 "SUB  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
                 [Symbol "<Xd|SP>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<R>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "W" [[O, O, X]] Nothing,
                           TableRow "W" [[O, I, O]] Nothing, TableRow "X" [[X, I, I]] Nothing,
                           TableRow "W" [[I, O, X]] Nothing,
                           TableRow "W" [[I, I, O]] Nothing])),
                  Symbol "<m>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTB" [[O, O, O]] Nothing,
                           TableRow "UXTH" [[O, O, I]] Nothing,
                           TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL|UXTX" [[O, I, I]] Nothing,
                           TableRow "SXTB" [[I, O, O]] Nothing,
                           TableRow "SXTH" [[I, O, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "imm3" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "SUB_addsub_imm" []
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/immediate"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, O, O, O, I]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUB_32_addsub_imm" [("sf", BlockEq [O])]
                 "SUB  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}"
                 [Symbol "<Wd|WSP>" "Rd" Nothing, Symbol "<Wn|WSP>" "Rn" Nothing,
                  Symbol "<imm>" "imm12" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL #0" [[O, O]] Nothing,
                           TableRow "LSL #12" [[O, I]] Nothing,
                           TableRow "RESERVED" [[I, X]] Nothing]))],
               Encoding "SUB_64_addsub_imm" [("sf", BlockEq [I])]
                 "SUB  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}"
                 [Symbol "<Xd|SP>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "imm12" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL #0" [[O, O]] Nothing,
                           TableRow "LSL #12" [[O, I]] Nothing,
                           TableRow "RESERVED" [[I, X]] Nothing]))]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/immediate"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/immediate"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "SUB_addsub_shift" ["NEG_SUB_addsub_shift"]
          [(Class "no_s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, O, I, I]),
                  Block (Just "shift") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUB_32_addsub_shift" [("sf", BlockEq [O])]
                 "SUB  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "SUB_64_addsub_shift" [("sf", BlockEq [I])]
                 "SUB  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"]),
     Right
       (Page "SUBS_addsub_ext" ["CMP_SUBS_addsub_ext"]
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, O, I, I]),
                  Block (Just "opt") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "imm3") (BlockEq [X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUBS_32S_addsub_ext" [("sf", BlockEq [O])]
                 "SUBS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn|WSP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTB" [[O, O, O]] Nothing,
                           TableRow "UXTH" [[O, O, I]] Nothing,
                           TableRow "LSL|UXTW" [[O, I, O]] Nothing,
                           TableRow "UXTX" [[O, I, I]] Nothing,
                           TableRow "SXTB" [[I, O, O]] Nothing,
                           TableRow "SXTH" [[I, O, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "imm3" Nothing],
               Encoding "SUBS_64S_addsub_ext" [("sf", BlockEq [I])]
                 "SUBS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<R>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "W" [[O, O, X]] Nothing,
                           TableRow "W" [[O, I, O]] Nothing, TableRow "X" [[X, I, I]] Nothing,
                           TableRow "W" [[I, O, X]] Nothing,
                           TableRow "W" [[I, I, O]] Nothing])),
                  Symbol "<m>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTB" [[O, O, O]] Nothing,
                           TableRow "UXTH" [[O, O, I]] Nothing,
                           TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL|UXTX" [[O, I, I]] Nothing,
                           TableRow "SXTB" [[I, O, O]] Nothing,
                           TableRow "SXTH" [[I, O, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "imm3" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/extendedreg"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "SUBS_addsub_imm" ["CMP_SUBS_addsub_imm"]
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/immediate"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [I, O, O, O, I]),
                  Block (Just "shift") (BlockEq [X, X]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUBS_32S_addsub_imm" [("sf", BlockEq [O])]
                 "SUBS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn|WSP>" "Rn" Nothing,
                  Symbol "<imm>" "imm12" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL #0" [[O, O]] Nothing,
                           TableRow "LSL #12" [[O, I]] Nothing,
                           TableRow "RESERVED" [[I, X]] Nothing]))],
               Encoding "SUBS_64S_addsub_imm" [("sf", BlockEq [I])]
                 "SUBS  <Xd>, <Xn|SP>, #<imm>{, <shift>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "imm12" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL #0" [[O, O]] Nothing,
                           TableRow "LSL #12" [[O, I]] Nothing,
                           TableRow "RESERVED" [[I, X]] Nothing]))]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/immediate"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\n\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/immediate"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;"]),
     Right
       (Page "SUBS_addsub_shift"
          ["CMP_SUBS_addsub_shift", "NEGS_SUBS_addsub_shift"]
          [(Class "s" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [I]),
                  Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, O, I, I]),
                  Block (Just "shift") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUBS_32_addsub_shift" [("sf", BlockEq [O])]
                 "SUBS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing],
               Encoding "SUBS_64_addsub_shift" [("sf", BlockEq [I])]
                 "SUBS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<shift>" "shift"
                    (Just
                       (Table ["shift"]
                          [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                           TableRow "ASR" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<amount>" "imm6" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\n\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);"])]
          [Ps "aarch64/instrs/integer/arithmetic/add-sub/shiftedreg"
             (Just PsExecute)
             "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\n\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\n\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\n\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\n\nX[d] = result;"]),
     Right
       (Page "SVC" []
          [(Class "SVC_EX_exception" Nothing
              (Diagram "aarch64/instrs/system/exceptions/runtime/svc"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, O]),
                  Block (Just "opc") (BlockEq [O, O, O]),
                  Block (Just "imm16")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "op2") (BlockEq [O, O, O]),
                  Block (Just "LL") (BlockEq [O, I])])
              [Encoding "SVC_EX_exception" [] "SVC  #<imm>"
                 [Symbol "<imm>" "imm16" Nothing]],
            [Ps "aarch64/instrs/system/exceptions/runtime/svc" (Just PsDecode)
               "bits(16) imm = imm16;"])]
          [Ps "aarch64/instrs/system/exceptions/runtime/svc" (Just PsExecute)
             "AArch64.CallSupervisor(imm);"]),
     Right
       (Page "SWP" []
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/swp"
                 [Block (Just "size") (BlockEq [I, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [I]),
                  Block (Just "opc") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "SWP_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "SWP  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPA_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "SWPA  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPAL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "SWPAL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPL_32_memop"
                 [("size", BlockEq [I, O]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "SWPL  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWP_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [O])]
                 "SWP  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPA_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [O])]
                 "SWPA  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPAL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [I]), ("R", BlockEq [I])]
                 "SWPAL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPL_64_memop"
                 [("size", BlockEq [I, I]), ("A", BlockEq [O]), ("R", BlockEq [I])]
                 "SWPL  <Xs>, <Xt>, [<Xn|SP>]"
                 [Symbol "<Xs>" "Rs" Nothing, Symbol "<Xt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/swp" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;"])]
          [Ps "aarch64/instrs/memory/atomicops/swp" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\n// all observers in the shareability domain \n// observe the load and store atomically\nMem[address, datasize DIV 8, stacctype] = X[s];\n\nX[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "SWPB" []
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/swp"
                 [Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [I]),
                  Block (Just "opc") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "SWPAB_32_memop" [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "SWPAB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPALB_32_memop" [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "SWPALB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPB_32_memop" [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "SWPB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPLB_32_memop" [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "SWPLB  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/swp" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;"])]
          [Ps "aarch64/instrs/memory/atomicops/swp" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\n// all observers in the shareability domain \n// observe the load and store atomically\nMem[address, datasize DIV 8, stacctype] = X[s];\n\nX[t] = ZeroExtend(data, regsize);"]),
     Right
       (Page "SWPH" []
          [(Class "general" (Just (ArchName "ARMv8.1"))
              (Diagram "aarch64/instrs/memory/atomicops/swp"
                 [Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "A") (BlockEq [X]),
                  Block (Just "R") (BlockEq [X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rs") (BlockEq [X, X, X, X, X]),
                  Block (Just "o3") (BlockEq [I]),
                  Block (Just "opc") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "SWPAH_32_memop" [("A", BlockEq [I]), ("R", BlockEq [O])]
                 "SWPAH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPALH_32_memop" [("A", BlockEq [I]), ("R", BlockEq [I])]
                 "SWPALH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPH_32_memop" [("A", BlockEq [O]), ("R", BlockEq [O])]
                 "SWPH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "SWPLH_32_memop" [("A", BlockEq [O]), ("R", BlockEq [I])]
                 "SWPLH  <Ws>, <Wt>, [<Xn|SP>]"
                 [Symbol "<Ws>" "Rs" Nothing, Symbol "<Wt>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/atomicops/swp" (Just PsDecode)
               "if !HaveAtomicExt() then UnallocatedEncoding();\n\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\n\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;"])]
          [Ps "aarch64/instrs/memory/atomicops/swp" (Just PsExecute)
             "bits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\ndata =  Mem[address, datasize DIV 8, ldacctype];\n\n// all observers in the shareability domain \n// observe the load and store atomically\nMem[address, datasize DIV 8, stacctype] = X[s];\n\nX[t] = ZeroExtend(data, regsize);"]),
     Left
       (AliasPage "SXTB_SBFM" "SBFM"
          (Class "signed_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [O, O, O, O, O, O]),
                 Block (Just "imms") (BlockEq [O, O, O, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "SXTB_SBFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "SXTB  <Wd>, <Wn>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
              Encoding "SXTB_SBFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I])]
                "SXTB  <Xd>, <Wn>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<Wn>" "Rn" Nothing]])),
     Left
       (AliasPage "SXTH_SBFM" "SBFM"
          (Class "signed_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [O, O, O, O, O, O]),
                 Block (Just "imms") (BlockEq [O, O, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "SXTH_SBFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "SXTH  <Wd>, <Wn>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
              Encoding "SXTH_SBFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I])]
                "SXTH  <Xd>, <Wn>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<Wn>" "Rn" Nothing]])),
     Left
       (AliasPage "SXTW_SBFM" "SBFM"
          (Class "signed_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [I]),
                 Block (Just "opc") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [I]),
                 Block (Just "immr") (BlockEq [O, O, O, O, O, O]),
                 Block (Just "imms") (BlockEq [O, I, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "SXTW_SBFM_64M_bitfield" [] "SXTW  <Xd>, <Wn>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<Wn>" "Rn" Nothing]])),
     Right
       (Page "SYS" ["AT_SYS", "DC_SYS", "IC_SYS", "TLBI_SYS"]
          [(Class "SYS_CR_system" Nothing
              (Diagram "aarch64/instrs/system/sysops"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, I]),
                  Block (Just "op1") (BlockEq [X, X, X]),
                  Block (Just "CRn") (BlockEq [X, X, X, X]),
                  Block (Just "CRm") (BlockEq [X, X, X, X]),
                  Block (Just "op2") (BlockEq [X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "SYS_CR_system" []
                 "SYS  #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}"
                 [Symbol "<op1>" "op1" Nothing, Symbol "<Cn>" "CRn" Nothing,
                  Symbol "<Cm>" "CRm" Nothing, Symbol "<op2>" "op2" Nothing,
                  Symbol "<Xt>" "Rt" Nothing]],
            [Ps "aarch64/instrs/system/sysops" (Just PsDecode)
               "AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 1;\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean has_result = (L == '1');"])]
          [Ps "aarch64/instrs/system/sysops" (Just PsExecute)
             "if has_result then\n    X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"]),
     Right
       (Page "SYSL" []
          [(Class "SYSL_RC_system" Nothing
              (Diagram "aarch64/instrs/system/sysops"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [I]),
                  Block (Just "op0") (BlockEq [O, I]),
                  Block (Just "op1") (BlockEq [X, X, X]),
                  Block (Just "CRn") (BlockEq [X, X, X, X]),
                  Block (Just "CRm") (BlockEq [X, X, X, X]),
                  Block (Just "op2") (BlockEq [X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "SYSL_RC_system" []
                 "SYSL  <Xt>, #<op1>, <Cn>, <Cm>, #<op2>"
                 [Symbol "<Xt>" "Rt" Nothing, Symbol "<op1>" "op1" Nothing,
                  Symbol "<Cn>" "CRn" Nothing, Symbol "<Cm>" "CRm" Nothing,
                  Symbol "<op2>" "op2" Nothing]],
            [Ps "aarch64/instrs/system/sysops" (Just PsDecode)
               "AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);\n\ninteger t = UInt(Rt);\n\ninteger sys_op0 = 1;\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean has_result = (L == '1');"])]
          [Ps "aarch64/instrs/system/sysops" (Just PsExecute)
             "if has_result then\n    X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);"]),
     Right
       (Page "TBNZ" []
          [(Class "TBNZ_only_testbranch" Nothing
              (Diagram "aarch64/instrs/branch/conditional/test"
                 [Block (Just "b5") (BlockEq [X]),
                  Block Nothing (BlockEq [O, I, I, O, I, I]),
                  Block (Just "op") (BlockEq [I]),
                  Block (Just "b40") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm14")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "TBNZ_only_testbranch" [] "TBNZ  <R><t>, #<imm>, <label>"
                 [Symbol "<R>" "b5"
                    (Just
                       (Table ["b5"]
                          [TableRow "W" [[O]] Nothing, TableRow "X" [[I]] Nothing])),
                  Symbol "<t>" "Rt" Nothing, Symbol "<imm>" "b40:b5" Nothing,
                  Symbol "<label>" "imm14" Nothing]],
            [Ps "aarch64/instrs/branch/conditional/test" (Just PsDecode)
               "integer t = UInt(Rt);\n\ninteger datasize = if b5 == '1' then 64 else 32;\ninteger bit_pos = UInt(b5:b40);\nbit bit_val = op;\nbits(64) offset = SignExtend(imm14:'00', 64);"])]
          [Ps "aarch64/instrs/branch/conditional/test" (Just PsExecute)
             "bits(datasize) operand = X[t];\n\nif operand<bit_pos> == bit_val then\n    BranchTo(PC[] + offset, BranchType_JMP);"]),
     Right
       (Page "TBZ" []
          [(Class "TBZ_only_testbranch" Nothing
              (Diagram "aarch64/instrs/branch/conditional/test"
                 [Block (Just "b5") (BlockEq [X]),
                  Block Nothing (BlockEq [O, I, I, O, I, I]),
                  Block (Just "op") (BlockEq [O]),
                  Block (Just "b40") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm14")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "TBZ_only_testbranch" [] "TBZ  <R><t>, #<imm>, <label>"
                 [Symbol "<R>" "b5"
                    (Just
                       (Table ["b5"]
                          [TableRow "W" [[O]] Nothing, TableRow "X" [[I]] Nothing])),
                  Symbol "<t>" "Rt" Nothing, Symbol "<imm>" "b40:b5" Nothing,
                  Symbol "<label>" "imm14" Nothing]],
            [Ps "aarch64/instrs/branch/conditional/test" (Just PsDecode)
               "integer t = UInt(Rt);\n\ninteger datasize = if b5 == '1' then 64 else 32;\ninteger bit_pos = UInt(b5:b40);\nbit bit_val = op;\nbits(64) offset = SignExtend(imm14:'00', 64);"])]
          [Ps "aarch64/instrs/branch/conditional/test" (Just PsExecute)
             "bits(datasize) operand = X[t];\n\nif operand<bit_pos> == bit_val then\n    BranchTo(PC[] + offset, BranchType_JMP);"]),
     Left
       (AliasPage "TLBI_SYS" "SYS"
          (Class "SYS_CR_system" Nothing
             (Diagram "aarch64/instrs/system/sysops"
                [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                 Block (Just "L") (BlockEq [O]),
                 Block (Just "op0") (BlockEq [O, I]),
                 Block (Just "op1") (BlockEq [X, X, X]),
                 Block (Just "CRn") (BlockEq [I, O, O, O]),
                 Block (Just "CRm") (BlockEq [X, X, X, X]),
                 Block (Just "op2") (BlockEq [X, X, X]),
                 Block (Just "Rt") (BlockEq [X, X, X, X, X])])
             [Encoding "TLBI_SYS_CR_system" [] "TLBI  <tlbi_op>{, <Xt>}"
                [Symbol "<op1>" "op1" Nothing, Symbol "<Cm>" "CRm" Nothing,
                 Symbol "<op2>" "op2" Nothing,
                 Symbol "<tlbi_op>" "op1:CRm:op2"
                   (Just
                      (Table ["op2", "CRm", "op1"]
                         [TableRow "VMALLE1IS" [[O, O, O], [O, O, I, I], [O, O, O]] Nothing,
                          TableRow "VAE1IS" [[O, O, I], [O, O, I, I], [O, O, O]] Nothing,
                          TableRow "ASIDE1IS" [[O, I, O], [O, O, I, I], [O, O, O]] Nothing,
                          TableRow "VAAE1IS" [[O, I, I], [O, O, I, I], [O, O, O]] Nothing,
                          TableRow "VALE1IS" [[I, O, I], [O, O, I, I], [O, O, O]] Nothing,
                          TableRow "VAALE1IS" [[I, I, I], [O, O, I, I], [O, O, O]] Nothing,
                          TableRow "VMALLE1" [[O, O, O], [O, I, I, I], [O, O, O]] Nothing,
                          TableRow "VAE1" [[O, O, I], [O, I, I, I], [O, O, O]] Nothing,
                          TableRow "ASIDE1" [[O, I, O], [O, I, I, I], [O, O, O]] Nothing,
                          TableRow "VAAE1" [[O, I, I], [O, I, I, I], [O, O, O]] Nothing,
                          TableRow "VALE1" [[I, O, I], [O, I, I, I], [O, O, O]] Nothing,
                          TableRow "VAALE1" [[I, I, I], [O, I, I, I], [O, O, O]] Nothing,
                          TableRow "IPAS2E1IS" [[O, O, I], [O, O, O, O], [I, O, O]] Nothing,
                          TableRow "IPAS2LE1IS" [[I, O, I], [O, O, O, O], [I, O, O]] Nothing,
                          TableRow "ALLE2IS" [[O, O, O], [O, O, I, I], [I, O, O]] Nothing,
                          TableRow "VAE2IS" [[O, O, I], [O, O, I, I], [I, O, O]] Nothing,
                          TableRow "ALLE1IS" [[I, O, O], [O, O, I, I], [I, O, O]] Nothing,
                          TableRow "VALE2IS" [[I, O, I], [O, O, I, I], [I, O, O]] Nothing,
                          TableRow "VMALLS12E1IS" [[I, I, O], [O, O, I, I], [I, O, O]]
                            Nothing,
                          TableRow "IPAS2E1" [[O, O, I], [O, I, O, O], [I, O, O]] Nothing,
                          TableRow "IPAS2LE1" [[I, O, I], [O, I, O, O], [I, O, O]] Nothing,
                          TableRow "ALLE2" [[O, O, O], [O, I, I, I], [I, O, O]] Nothing,
                          TableRow "VAE2" [[O, O, I], [O, I, I, I], [I, O, O]] Nothing,
                          TableRow "ALLE1" [[I, O, O], [O, I, I, I], [I, O, O]] Nothing,
                          TableRow "VALE2" [[I, O, I], [O, I, I, I], [I, O, O]] Nothing,
                          TableRow "VMALLS12E1" [[I, I, O], [O, I, I, I], [I, O, O]] Nothing,
                          TableRow "ALLE3IS" [[O, O, O], [O, O, I, I], [I, I, O]] Nothing,
                          TableRow "VAE3IS" [[O, O, I], [O, O, I, I], [I, I, O]] Nothing,
                          TableRow "VALE3IS" [[I, O, I], [O, O, I, I], [I, I, O]] Nothing,
                          TableRow "ALLE3" [[O, O, O], [O, I, I, I], [I, I, O]] Nothing,
                          TableRow "VAE3" [[O, O, I], [O, I, I, I], [I, I, O]] Nothing,
                          TableRow "VALE3" [[I, O, I], [O, I, I, I], [I, I, O]] Nothing])),
                 Symbol "<Xt>" "Rt" Nothing]])),
     Left
       (AliasPage "TST_ANDS_log_imm" "ANDS_log_imm"
          (Class "s" Nothing
             (Diagram "aarch64/instrs/integer/logical/immediate"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [I, I]),
                 Block Nothing (BlockEq [I, O, O, I, O, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [I, I, I, I, I])])
             [Encoding "TST_ANDS_32S_log_imm"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "TST  <Wn>, #<imm>"
                [Symbol "<Wn>" "Rn" Nothing, Symbol "<imm>" "immr:imms" Nothing],
              Encoding "TST_ANDS_64S_log_imm" [("sf", BlockEq [I])]
                "TST  <Xn>, #<imm>"
                [Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<imm>" "N:immr:imms" Nothing]])),
     Left
       (AliasPage "TST_ANDS_log_shift" "ANDS_log_shift"
          (Class "s" Nothing
             (Diagram "aarch64/instrs/integer/logical/shiftedreg"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [I, I]),
                 Block Nothing (BlockEq [O, I, O, I, O]),
                 Block (Just "shift") (BlockEq [X, X]),
                 Block (Just "N") (BlockEq [O]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [I, I, I, I, I])])
             [Encoding "TST_ANDS_32_log_shift" [("sf", BlockEq [O])]
                "TST  <Wn>, <Wm>{, <shift> #<amount>}"
                [Symbol "<Wn>" "Rn" Nothing, Symbol "<Wm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "ROR" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing],
              Encoding "TST_ANDS_64_log_shift" [("sf", BlockEq [I])]
                "TST  <Xn>, <Xm>{, <shift> #<amount>}"
                [Symbol "<Xn>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing,
                 Symbol "<shift>" "shift"
                   (Just
                      (Table ["shift"]
                         [TableRow "LSL" [[O, O]] Nothing, TableRow "LSR" [[O, I]] Nothing,
                          TableRow "ASR" [[I, O]] Nothing,
                          TableRow "ROR" [[I, I]] Nothing])),
                 Symbol "<amount>" "imm6" Nothing]])),
     Left
       (AliasPage "UBFIZ_UBFM" "UBFM"
          (Class "zero_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [I, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "UBFIZ_UBFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "UBFIZ  <Wd>, <Wn>, #<lsb>, #<width>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing],
              Encoding "UBFIZ_UBFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I])]
                "UBFIZ  <Xd>, <Xn>, #<lsb>, #<width>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing]])),
     Right
       (Page "UBFM"
          ["LSL_UBFM", "LSR_UBFM", "UBFIZ_UBFM", "UBFX_UBFM", "UXTB_UBFM",
           "UXTH_UBFM"]
          [(Class "zero_fill" Nothing
              (Diagram "aarch64/instrs/integer/bitfield"
                 [Block (Just "sf") (BlockEq [X]),
                  Block (Just "opc") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, O, O, I, I, O]),
                  Block (Just "N") (BlockEq [X]),
                  Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UBFM_32M_bitfield"
                 [("sf", BlockEq [O]), ("N", BlockEq [O])]
                 "UBFM  <Wd>, <Wn>, #<immr>, #<imms>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<immr>" "immr" Nothing, Symbol "<imms>" "imms" Nothing],
               Encoding "UBFM_64M_bitfield"
                 [("sf", BlockEq [I]), ("N", BlockEq [I])]
                 "UBFM  <Xd>, <Xn>, #<immr>, #<imms>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<immr>" "immr" Nothing, Symbol "<imms>" "imms" Nothing]],
            [Ps "aarch64/instrs/integer/bitfield" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\n\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\n\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    // SBFM\n    when '01' inzero = FALSE; extend = FALSE;   // BFM\n    when '10' inzero = TRUE;  extend = FALSE;   // UBFM\n    when '11' UnallocatedEncoding();\n\nif sf == '1' && N != '1' then ReservedValue();\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();\n\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);"])]
          [Ps "aarch64/instrs/integer/bitfield" (Just PsExecute)
             "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\n\n// perform bitfield move on low bits\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\n\n// determine extension bits (sign, zero or dest register)\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\n\n// combine extension bits and result bits\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);"]),
     Left
       (AliasPage "UBFX_UBFM" "UBFM"
          (Class "zero_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [X]),
                 Block (Just "opc") (BlockEq [I, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [X]),
                 Block (Just "immr") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "imms") (BlockEq [X, X, X, X, X, X]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "UBFX_UBFM_32M_bitfield"
                [("sf", BlockEq [O]), ("N", BlockEq [O])]
                "UBFX  <Wd>, <Wn>, #<lsb>, #<width>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing],
              Encoding "UBFX_UBFM_64M_bitfield"
                [("sf", BlockEq [I]), ("N", BlockEq [I])]
                "UBFX  <Xd>, <Xn>, #<lsb>, #<width>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                 Symbol "<lsb>" "" Nothing, Symbol "<width>" "" Nothing]])),
     Right
       (Page "UDIV" []
          [(Class "general" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/div"
                 [Block (Just "sf") (BlockEq [X]), Block (Just "op") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode2<5:1>") (BlockEq [O, O, O, O, I]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UDIV_32_dp_2src" [("sf", BlockEq [O])]
                 "UDIV  <Wd>, <Wn>, <Wm>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing],
               Encoding "UDIV_64_dp_2src" [("sf", BlockEq [I])]
                 "UDIV  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/div" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean unsigned = (o1 == '0');"])]
          [Ps "aarch64/instrs/integer/arithmetic/div" (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\ninteger result;\n\nif IsZero(operand2) then\n    result = 0;\nelse\n    result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));\n\nX[d] = result<datasize-1:0>;"]),
     Right
       (Page "UMADDL" ["UMULL_UMADDL"]
          [(Class "UMADDL_64WA_dp_3src" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
                 [Block (Just "sf") (BlockEq [I]),
                  Block (Just "op54") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, O, I, I]),
                  Block (Just "U") (BlockEq [I]), Block Nothing (BlockEq [O, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMADDL_64WA_dp_3src" [] "UMADDL  <Xd>, <Wn>, <Wm>, <Xa>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xa>" "Ra" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"]),
     Left
       (AliasPage "UMNEGL_UMSUBL" "UMSUBL"
          (Class "UMSUBL_64WA_dp_3src" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
                [Block (Just "sf") (BlockEq [I]),
                 Block (Just "op54") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, O, I, I]),
                 Block (Just "U") (BlockEq [I]), Block Nothing (BlockEq [O, I]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "o0") (BlockEq [I]),
                 Block (Just "Ra") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "UMNEGL_UMSUBL_64WA_dp_3src" []
                "UMNEGL  <Xd>, <Wn>, <Wm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<Wm>" "Rm" Nothing]])),
     Right
       (Page "UMSUBL" ["UMNEGL_UMSUBL"]
          [(Class "UMSUBL_64WA_dp_3src" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
                 [Block (Just "sf") (BlockEq [I]),
                  Block (Just "op54") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, O, I, I]),
                  Block (Just "U") (BlockEq [I]), Block Nothing (BlockEq [O, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMSUBL_64WA_dp_3src" [] "UMSUBL  <Xd>, <Wn>, <Wm>, <Xa>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xa>" "Ra" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\n\ninteger result;\n\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\n\nX[d] = result<63:0>;"]),
     Right
       (Page "UMULH" []
          [(Class "UMULH_64_dp_3src" Nothing
              (Diagram "aarch64/instrs/integer/arithmetic/mul/widening/64-128hi"
                 [Block (Just "sf") (BlockEq [I]),
                  Block (Just "op54") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, I, O, I, I]),
                  Block (Just "U") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Ra") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMULH_64_dp_3src" [] "UMULH  <Xd>, <Xn>, <Xm>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/integer/arithmetic/mul/widening/64-128hi"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);           // ignored by UMULH/SMULH\ninteger destsize = 64;\ninteger datasize = destsize;\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/integer/arithmetic/mul/widening/64-128hi"
             (Just PsExecute)
             "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\n\ninteger result;\n\nresult = Int(operand1, unsigned) * Int(operand2, unsigned);\n\nX[d] = result<127:64>;"]),
     Left
       (AliasPage "UMULL_UMADDL" "UMADDL"
          (Class "UMADDL_64WA_dp_3src" Nothing
             (Diagram "aarch64/instrs/integer/arithmetic/mul/widening/32-64"
                [Block (Just "sf") (BlockEq [I]),
                 Block (Just "op54") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, I, O, I, I]),
                 Block (Just "U") (BlockEq [I]), Block Nothing (BlockEq [O, I]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "o0") (BlockEq [O]),
                 Block (Just "Ra") (BlockEq [I, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "UMULL_UMADDL_64WA_dp_3src" [] "UMULL  <Xd>, <Wn>, <Wm>"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                 Symbol "<Wm>" "Rm" Nothing]])),
     Left
       (AliasPage "UXTB_UBFM" "UBFM"
          (Class "zero_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [O]),
                 Block (Just "immr") (BlockEq [O, O, O, O, O, O]),
                 Block (Just "imms") (BlockEq [O, O, O, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "UXTB_UBFM_32M_bitfield" [] "UXTB  <Wd>, <Wn>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing]])),
     Left
       (AliasPage "UXTH_UBFM" "UBFM"
          (Class "zero_fill" Nothing
             (Diagram "aarch64/instrs/integer/bitfield"
                [Block (Just "sf") (BlockEq [O]),
                 Block (Just "opc") (BlockEq [I, O]),
                 Block Nothing (BlockEq [I, O, O, I, I, O]),
                 Block (Just "N") (BlockEq [O]),
                 Block (Just "immr") (BlockEq [O, O, O, O, O, O]),
                 Block (Just "imms") (BlockEq [O, O, I, I, I, I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "UXTH_UBFM_32M_bitfield" [] "UXTH  <Wd>, <Wn>"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing]])),
     Right
       (Page "WFE" []
          [(Class "WFE_HI_system" Nothing
              (Diagram "aarch64/instrs/system/hints"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, O, O]),
                  Block (Just "op2") (BlockEq [O, I, O]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "WFE_HI_system" [] "WFE" []],
            [Ps "aarch64/instrs/system/hints" (Just PsDecode)
               "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 111'\n        SEE \"XPACLRI\";\n    when '0001 xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0011 xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                // Instruction executes as NOP"])]
          [Ps "aarch64/instrs/system/hints" (Just PsExecute)
             "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"]),
     Right
       (Page "WFI" []
          [(Class "WFI_HI_system" Nothing
              (Diagram "aarch64/instrs/system/hints"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, O, O]),
                  Block (Just "op2") (BlockEq [O, I, I]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "WFI_HI_system" [] "WFI" []],
            [Ps "aarch64/instrs/system/hints" (Just PsDecode)
               "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 111'\n        SEE \"XPACLRI\";\n    when '0001 xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0011 xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                // Instruction executes as NOP"])]
          [Ps "aarch64/instrs/system/hints" (Just PsExecute)
             "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"]),
     Right
       (Page "XPAC" []
          [(Class "general" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/strip/dp_1src"
                 [Block (Just "sf") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, I, O, I, I, O]),
                  Block (Just "opcode2") (BlockEq [O, O, O, O, I]),
                  Block (Just "opcode[5]") (BlockEq [O]),
                  Block (Just "opcode[4]") (BlockEq [I]),
                  Block (Just "opcode[3:1]") (BlockEq [O, O, O]),
                  Block (Just "D") (BlockEq [X]),
                  Block (Just "Rn") (BlockEq [I, I, I, I, I]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "XPACD_64Z_dp_1src" [("D", BlockEq [I])] "XPACD  <Xd>"
                 [Symbol "<Xd>" "Rd" Nothing],
               Encoding "XPACI_64Z_dp_1src" [("D", BlockEq [O])] "XPACI  <Xd>"
                 [Symbol "<Xd>" "Rd" Nothing]],
            [Ps "aarch64/instrs/integer/pac/strip/dp_1src" (Just PsDecode)
               "boolean data = (D == '1');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif !HavePACExt() then\n    UnallocatedEncoding();\n\nif n != 31 then UnallocatedEncoding();"]),
           (Class "XPACLRI_HI_system" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/integer/pac/strip/hint"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, O, O]),
                  Block (Just "op2") (BlockEq [I, I, I]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "XPACLRI_HI_system" [] "XPACLRI" []],
            [Ps "aarch64/instrs/integer/pac/strip/hint" (Just PsDecode)
               "integer d = 30;\nboolean data = FALSE;"])]
          [Ps "aarch64/instrs/integer/pac/strip/dp_1src" (Just PsExecute)
             "if HavePACExt() then\n    X[d] = Strip(X[d], data);"]),
     Right
       (Page "YIELD" []
          [(Class "YIELD_HI_system" Nothing
              (Diagram "aarch64/instrs/system/hints"
                 [Block Nothing (BlockEq [I, I, O, I, O, I, O, I, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block (Just "op0") (BlockEq [O, O]),
                  Block (Just "op1") (BlockEq [O, I, I]),
                  Block (Just "CRn") (BlockEq [O, O, I, O]),
                  Block (Just "CRm") (BlockEq [O, O, O, O]),
                  Block (Just "op2") (BlockEq [O, O, I]),
                  Block (Just "Rt") (BlockEq [I, I, I, I, I])])
              [Encoding "YIELD_HI_system" [] "YIELD" []],
            [Ps "aarch64/instrs/system/hints" (Just PsDecode)
               "SystemHintOp op;\n\ncase CRm:op2 of\n    when '0000 000' op = SystemHintOp_NOP;\n    when '0000 001' op = SystemHintOp_YIELD;\n    when '0000 010' op = SystemHintOp_WFE;\n    when '0000 011' op = SystemHintOp_WFI;\n    when '0000 100' op = SystemHintOp_SEV;\n    when '0000 101' op = SystemHintOp_SEVL;\n    when '0000 111'\n        SEE \"XPACLRI\";\n    when '0001 xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010 000'\n        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP\n        op = SystemHintOp_ESB;\n    when '0010 001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP\n        op = SystemHintOp_PSB;\n    when '0011 xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                // Instruction executes as NOP"])]
          [Ps "aarch64/instrs/system/hints" (Just PsExecute)
             "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            WaitForEvent();\n\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                // Check for traps described by the OS which may be EL1 or EL2.\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                // Check for traps described by the Hypervisor.\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                // Check for traps described by the Secure Monitor.\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            WaitForInterrupt();\n\n    when SystemHintOp_SEV\n        SendEvent();\n\n    when SystemHintOp_SEVL\n        SendEventLocal();\n\n    when SystemHintOp_ESB\n        SynchronizeErrors();\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n\n    otherwise // do nothing"]),
     Right
       (Page "ABS_advsimd" []
          [(Class "ABS_asisdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ABS_asisdmisc_R" [] "ABS  <V><d>, <V><n>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/int/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');"]),
           (Class "ABS_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ABS_asimdmisc_R" [] "ABS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/int/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/int/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    Elem[result, e, esize] = element<esize-1:0>;                \n\nV[d] = result;"]),
     Right
       (Page "ADD_advsimd" []
          [(Class "ADD_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADD_asisdsame_only" [] "ADD  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (U == '1');"]),
           (Class "ADD_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADD_asimdsame_only" []
                 "ADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then\n        Elem[result, e, esize] = element1 - element2;\n    else\n        Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;"]),
     Right
       (Page "ADDHN_advsimd" []
          [(Class "ADDHN_asimddiff_N" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "o1") (BlockEq [O]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADDHN_asimddiff_N" []
                 "ADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"]),
     Right
       (Page "ADDP_advsimd_pair" []
          [(Class "ADDP_asisdpair_only" Nothing
              (Diagram "aarch64/instrs/vector/reduce/add/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADDP_asisdpair_only" [] "ADDP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "2D" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/add/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = ReduceOp_ADD;"])]
          [Ps "aarch64/instrs/vector/reduce/add/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "ADDP_advsimd_vec" []
          [(Class "ADDP_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/pair"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADDP_asimdsame_only" []
                 "ADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/pair"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/pair"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[concat, 2*e, esize];\n    element2 = Elem[concat, (2*e)+1, esize];\n    Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;"]),
     Right
       (Page "ADDV_advsimd" []
          [(Class "ADDV_asimdall_only" Nothing
              (Diagram "aarch64/instrs/vector/reduce/add/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ADDV_asimdall_only" [] "ADDV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "RESERVED" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/add/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = ReduceOp_ADD;"])]
          [Ps "aarch64/instrs/vector/reduce/add/simd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "AESD_advsimd" []
          [(Class "AESD_B_cryptoaes" Nothing
              (Diagram "aarch64/instrs/vector/crypto/aes/round"
                 [Block Nothing (BlockEq [O, I, O, O, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, I, O, O]),
                  Block Nothing (BlockEq [O, O, I, O]),
                  Block (Just "D") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AESD_B_cryptoaes" [] "AESD  <Vd>.16B, <Vn>.16B"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/aes/round" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');"])]
          [Ps "aarch64/instrs/vector/crypto/aes/round" (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nresult = operand1 EOR operand2;\nif decrypt then\n    result = AESInvSubBytes(AESInvShiftRows(result));\nelse\n    result = AESSubBytes(AESShiftRows(result));\n\nV[d] = result;"]),
     Right
       (Page "AESE_advsimd" []
          [(Class "AESE_B_cryptoaes" Nothing
              (Diagram "aarch64/instrs/vector/crypto/aes/round"
                 [Block Nothing (BlockEq [O, I, O, O, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, I, O, O]),
                  Block Nothing (BlockEq [O, O, I, O]),
                  Block (Just "D") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AESE_B_cryptoaes" [] "AESE  <Vd>.16B, <Vn>.16B"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/aes/round" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');"])]
          [Ps "aarch64/instrs/vector/crypto/aes/round" (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nresult = operand1 EOR operand2;\nif decrypt then\n    result = AESInvSubBytes(AESInvShiftRows(result));\nelse\n    result = AESSubBytes(AESShiftRows(result));\n\nV[d] = result;"]),
     Right
       (Page "AESIMC_advsimd" []
          [(Class "AESIMC_B_cryptoaes" Nothing
              (Diagram "aarch64/instrs/vector/crypto/aes/mix"
                 [Block Nothing (BlockEq [O, I, O, O, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, I, O, O]),
                  Block Nothing (BlockEq [O, O, I, I]),
                  Block (Just "D") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AESIMC_B_cryptoaes" [] "AESIMC  <Vd>.16B, <Vn>.16B"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/aes/mix" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');"])]
          [Ps "aarch64/instrs/vector/crypto/aes/mix" (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) operand = V[n];\nbits(128) result;\nif decrypt then\n    result = AESInvMixColumns(operand);\nelse\n    result = AESMixColumns(operand);\nV[d] = result;"]),
     Right
       (Page "AESMC_advsimd" []
          [(Class "AESMC_B_cryptoaes" Nothing
              (Diagram "aarch64/instrs/vector/crypto/aes/mix"
                 [Block Nothing (BlockEq [O, I, O, O, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, I, O, O]),
                  Block Nothing (BlockEq [O, O, I, I]),
                  Block (Just "D") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AESMC_B_cryptoaes" [] "AESMC  <Vd>.16B, <Vn>.16B"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/aes/mix" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');"])]
          [Ps "aarch64/instrs/vector/crypto/aes/mix" (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) operand = V[n];\nbits(128) result;\nif decrypt then\n    result = AESInvMixColumns(operand);\nelse\n    result = AESMixColumns(operand);\nV[d] = result;"]),
     Right
       (Page "AND_advsimd" []
          [(Class "AND_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "AND_asimdsame_only" []
                 "AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"]),
     Right
       (Page "BCAX_advsimd" []
          [(Class "BCAX_VVV16_crypto4" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sha3/bcax"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O]),
                  Block (Just "Op0") (BlockEq [O, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "BCAX_VVV16_crypto4" []
                 "BCAX  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<Va>" "Ra" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3/bcax" (Just PsDecode)
               "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger a = UInt(Ra);"])]
          [Ps "aarch64/instrs/vector/crypto/sha3/bcax" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Va = V[a];\nV[d] = Vn EOR (Vm AND NOT(Va));"]),
     Right
       (Page "BIC_advsimd_imm" []
          [(Class "shifted_immediate" Nothing
              (Diagram "aarch64/instrs/vector/logical"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O, O, O, O, O]),
                  Block (Just "a") (BlockEq [X]), Block (Just "b") (BlockEq [X]),
                  Block (Just "c") (BlockEq [X]),
                  Block (Just "cmode") (BlockEq [X, X, X, I]),
                  Block (Just "o2") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "d") (BlockEq [X]), Block (Just "e") (BlockEq [X]),
                  Block (Just "f") (BlockEq [X]), Block (Just "g") (BlockEq [X]),
                  Block (Just "h") (BlockEq [X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "BIC_asimdimm_L_hl" [("cmode", BlockEq [I, O, X, I])]
                 "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing,
                  Symbol "<amount>" "cmode<1>"
                    (Just
                       (Table ["cmode<1>"]
                          [TableRow "0" [[O]] Nothing, TableRow "8" [[I]] Nothing]))],
               Encoding "BIC_asimdimm_L_sl" [("cmode", BlockEq [O, X, X, I])]
                 "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing,
                  Symbol "<amount>" "cmode<2:1>"
                    (Just
                       (Table ["cmode<2:1>"]
                          [TableRow "0" [[O, O]] Nothing, TableRow "8" [[O, I]] Nothing,
                           TableRow "16" [[I, O]] Nothing,
                           TableRow "24" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/logical" (Just PsDecode)
               "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);"])]
          [Ps "aarch64/instrs/vector/logical" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"]),
     Right
       (Page "BIC_advsimd_reg" []
          [(Class "BIC_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "BIC_asimdsame_only" []
                 "BIC  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"]),
     Right
       (Page "BIF_advsimd" []
          [(Class "BIF_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "opc2") (BlockEq [I, I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "BIF_asimdsame_only" []
                 "BIF  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"]),
     Right
       (Page "BIT_advsimd" []
          [(Class "BIT_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "opc2") (BlockEq [I, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "BIT_asimdsame_only" []
                 "BIT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"]),
     Right
       (Page "BSL_advsimd" []
          [(Class "BSL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "opc2") (BlockEq [O, I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "BSL_asimdsame_only" []
                 "BSL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"]),
     Right
       (Page "CLS_advsimd" []
          [(Class "CLS_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/clsz"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CLS_asimdmisc_R" [] "CLS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/clsz" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/clsz" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    if countop == CountOp_CLS then\n        count = CountLeadingSignBits(Elem[operand, e, esize]);\n    else\n        count = CountLeadingZeroBits(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;"]),
     Right
       (Page "CLZ_advsimd" []
          [(Class "CLZ_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/clsz"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CLZ_asimdmisc_R" [] "CLZ  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/clsz" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/clsz" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    if countop == CountOp_CLS then\n        count = CountLeadingSignBits(Elem[operand, e, esize]);\n    else\n        count = CountLeadingZeroBits(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;"]),
     Right
       (Page "CMEQ_advsimd_reg" []
          [(Class "CMEQ_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMEQ_asisdsame_only" [] "CMEQ  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean and_test = (U == '0');"]),
           (Class "CMEQ_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMEQ_asimdsame_only" []
                 "CMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean and_test = (U == '0');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if and_test then\n        test_passed = !IsZero(element1 AND element2);\n    else\n        test_passed = (element1 == element2);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CMEQ_advsimd_zero" []
          [(Class "CMEQ_asisdmisc_Z" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, O, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMEQ_asisdmisc_Z" [] "CMEQ  <V><d>, <V><n>, #0"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "CMEQ_asimdmisc_Z" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, O, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMEQ_asimdmisc_Z" [] "CMEQ  <Vd>.<T>, <Vn>.<T>, #0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CMGE_advsimd_reg" []
          [(Class "CMGE_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O, I, I]),
                  Block (Just "eq") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMGE_asisdsame_only" [] "CMGE  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');"]),
           (Class "CMGE_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O, I, I]),
                  Block (Just "eq") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMGE_asimdsame_only" []
                 "CMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CMGE_advsimd_zero" []
          [(Class "CMGE_asisdmisc_Z" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, O, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMGE_asisdmisc_Z" [] "CMGE  <V><d>, <V><n>, #0"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "CMGE_asimdmisc_Z" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, O, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMGE_asimdmisc_Z" [] "CMGE  <Vd>.<T>, <Vn>.<T>, #0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CMGT_advsimd_reg" []
          [(Class "CMGT_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O, I, I]),
                  Block (Just "eq") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMGT_asisdsame_only" [] "CMGT  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');"]),
           (Class "CMGT_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O, I, I]),
                  Block (Just "eq") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMGT_asimdsame_only" []
                 "CMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CMGT_advsimd_zero" []
          [(Class "CMGT_asisdmisc_Z" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, O, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMGT_asisdmisc_Z" [] "CMGT  <V><d>, <V><n>, #0"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "CMGT_asimdmisc_Z" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, O, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMGT_asimdmisc_Z" [] "CMGT  <Vd>.<T>, <Vn>.<T>, #0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CMHI_advsimd" []
          [(Class "CMHI_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O, I, I]),
                  Block (Just "eq") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMHI_asisdsame_only" [] "CMHI  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');"]),
           (Class "CMHI_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O, I, I]),
                  Block (Just "eq") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMHI_asimdsame_only" []
                 "CMHI  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CMHS_advsimd" []
          [(Class "CMHS_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O, I, I]),
                  Block (Just "eq") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMHS_asisdsame_only" [] "CMHS  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');"]),
           (Class "CMHS_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O, I, I]),
                  Block (Just "eq") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMHS_asimdsame_only" []
                 "CMHS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CMLE_advsimd" []
          [(Class "CMLE_asisdmisc_Z" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, O, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMLE_asisdmisc_Z" [] "CMLE  <V><d>, <V><n>, #0"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "CMLE_asimdmisc_Z" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, O, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMLE_asimdmisc_Z" [] "CMLE  <Vd>.<T>, <Vn>.<T>, #0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CMLT_advsimd" []
          [(Class "CMLT_asisdmisc_Z" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMLT_asisdmisc_Z" [] "CMLT  <V><d>, <V><n>, #0"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison = CompareOp_LT;"]),
           (Class "CMLT_asimdmisc_Z" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMLT_asimdmisc_Z" [] "CMLT  <Vd>.<T>, <Vn>.<T>, #0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison = CompareOp_LT;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CMTST_advsimd" []
          [(Class "CMTST_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMTST_asisdsame_only" [] "CMTST  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean and_test = (U == '0');"]),
           (Class "CMTST_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CMTST_asimdsame_only" []
                 "CMTST  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean and_test = (U == '0');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if and_test then\n        test_passed = !IsZero(element1 AND element2);\n    else\n        test_passed = (element1 == element2);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "CNT_advsimd" []
          [(Class "CNT_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/cnt"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "CNT_asimdmisc_R" [] "CNT  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "RESERVED" [[X], [O, I]] Nothing,
                           TableRow "RESERVED" [[X], [I, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cnt" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '00' then ReservedValue();\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cnt" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    count = BitCount(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;"]),
     Right
       (Page "DUP_advsimd_elt" ["MOV_DUP_advsimd_elt"]
          [(Class "DUP_asisdone_only" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/cpy-dup/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O, O, O]),
                  Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "imm4") (BlockEq [O, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "DUP_asisdone_only" [] "DUP  <V><d>, <Vn>.<T>[<index>]"
                 [Symbol "<T>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "B" [[X, X, X, X, I]] Nothing,
                           TableRow "H" [[X, X, X, I, O]] Nothing,
                           TableRow "S" [[X, X, I, O, O]] Nothing,
                           TableRow "D" [[X, I, O, O, O]] Nothing])),
                  Symbol "<V>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "B" [[X, X, X, X, I]] Nothing,
                           TableRow "H" [[X, X, X, I, O]] Nothing,
                           TableRow "S" [[X, X, I, O, O]] Nothing,
                           TableRow "D" [[X, I, O, O, O]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<index>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "imm5<4:1>" [[X, X, X, X, I]] Nothing,
                           TableRow "imm5<4:2>" [[X, X, X, I, O]] Nothing,
                           TableRow "imm5<4:3>" [[X, X, I, O, O]] Nothing,
                           TableRow "imm5<4>" [[X, I, O, O, O]] Nothing])),
                  Symbol "<d>" "Rd" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/vector/cpy-dup/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\n\ninteger index = UInt(imm5<4:size+1>);\ninteger idxdsize = if imm5<4> == '1' then 128 else 64; \n\ninteger esize = 8 << size;\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "DUP_asimdins_DV_v" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/cpy-dup/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O, O, O, O]),
                  Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "imm4") (BlockEq [O, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "DUP_asimdins_DV_v" []
                 "DUP  <Vd>.<T>, <Vn>.<Ts>[<index>]"
                 [Symbol "<T>" "imm5:Q"
                    (Just
                       (Table ["Q", "imm5"]
                          [TableRow "RESERVED" [[X], [X, O, O, O, O]] Nothing,
                           TableRow "8B" [[O], [X, X, X, X, I]] Nothing,
                           TableRow "16B" [[I], [X, X, X, X, I]] Nothing,
                           TableRow "4H" [[O], [X, X, X, I, O]] Nothing,
                           TableRow "8H" [[I], [X, X, X, I, O]] Nothing,
                           TableRow "2S" [[O], [X, X, I, O, O]] Nothing,
                           TableRow "4S" [[I], [X, X, I, O, O]] Nothing,
                           TableRow "RESERVED" [[O], [X, I, O, O, O]] Nothing,
                           TableRow "2D" [[I], [X, I, O, O, O]] Nothing])),
                  Symbol "<Ts>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "B" [[X, X, X, X, I]] Nothing,
                           TableRow "H" [[X, X, X, I, O]] Nothing,
                           TableRow "S" [[X, X, I, O, O]] Nothing,
                           TableRow "D" [[X, I, O, O, O]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<index>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "imm5<4:1>" [[X, X, X, X, I]] Nothing,
                           TableRow "imm5<4:2>" [[X, X, X, I, O]] Nothing,
                           TableRow "imm5<4:3>" [[X, X, I, O, O]] Nothing,
                           TableRow "imm5<4>" [[X, I, O, O, O]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/vector/cpy-dup/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\n\ninteger index = UInt(imm5<4:size+1>);\ninteger idxdsize = if imm5<4> == '1' then 128 else 64; \n\nif size == 3 && Q == '0' then ReservedValue();\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/transfer/vector/cpy-dup/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nelement = Elem[operand, index, esize];\nfor e = 0 to elements-1\n    Elem[result, e, esize] = element;\nV[d] = result;"]),
     Right
       (Page "DUP_advsimd_gen" []
          [(Class "DUP_asimdins_DR_r" Nothing
              (Diagram "aarch64/instrs/vector/transfer/integer/dup"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O, O, O, O]),
                  Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "imm4") (BlockEq [O, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "DUP_asimdins_DR_r" [] "DUP  <Vd>.<T>, <R><n>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "imm5:Q"
                    (Just
                       (Table ["Q", "imm5"]
                          [TableRow "RESERVED" [[X], [X, O, O, O, O]] Nothing,
                           TableRow "8B" [[O], [X, X, X, X, I]] Nothing,
                           TableRow "16B" [[I], [X, X, X, X, I]] Nothing,
                           TableRow "4H" [[O], [X, X, X, I, O]] Nothing,
                           TableRow "8H" [[I], [X, X, X, I, O]] Nothing,
                           TableRow "2S" [[O], [X, X, I, O, O]] Nothing,
                           TableRow "4S" [[I], [X, X, I, O, O]] Nothing,
                           TableRow "RESERVED" [[O], [X, I, O, O, O]] Nothing,
                           TableRow "2D" [[I], [X, I, O, O, O]] Nothing])),
                  Symbol "<R>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "W" [[X, X, X, X, I]] Nothing,
                           TableRow "W" [[X, X, X, I, O]] Nothing,
                           TableRow "W" [[X, X, I, O, O]] Nothing,
                           TableRow "X" [[X, I, O, O, O]] Nothing])),
                  Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/integer/dup" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\n\n// imm5<4:size+1> is IGNORED\n\nif size == 3 && Q == '0' then ReservedValue();\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/transfer/integer/dup" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(esize) element = X[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = element;\nV[d] = result;"]),
     Right
       (Page "EOR_advsimd" []
          [(Class "EOR_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "opc2") (BlockEq [O, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "EOR_asimdsame_only" []
                 "EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nVBitOp op;\n\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);"]),
     Right
       (Page "EOR3_advsimd" []
          [(Class "EOR3_VVV16_crypto4" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sha3/eor3"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O]),
                  Block (Just "Op0") (BlockEq [O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "EOR3_VVV16_crypto4" []
                 "EOR3  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<Va>" "Ra" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3/eor3" (Just PsDecode)
               "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger a = UInt(Ra);"])]
          [Ps "aarch64/instrs/vector/crypto/sha3/eor3" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Va = V[a];\nV[d] = Vn EOR Vm EOR Va;"]),
     Right
       (Page "EXT_advsimd" []
          [(Class "EXT_asimdext_only" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/extract"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, I, I, I, O]),
                  Block (Just "op2") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "imm4") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "EXT_asimdext_only" []
                 "EXT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<index>" "Q:imm4"
                    (Just
                       (Table ["imm4<3>", "Q"]
                          [TableRow "imm4<2:0>" [[O], [O]] Nothing,
                           TableRow "RESERVED" [[I], [O]] Nothing,
                           TableRow "imm4" [[X], [I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/transfer/vector/extract" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif Q == '0' && imm4<3> == '1' then UnallocatedEncoding();\n\ninteger datasize = if Q == '1' then 128 else 64;\ninteger position = UInt(imm4) << 3;"])]
          [Ps "aarch64/instrs/vector/transfer/vector/extract"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) hi = V[m];\nbits(datasize) lo = V[n];\nbits(datasize*2) concat = hi : lo;\n\nV[d] = concat<position+datasize-1:position>;"]),
     Right
       (Page "FABD_advsimd" []
          [(Class "FABD_asisdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FABD_asisdsamefp16_only" [] "FABD  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean abs = TRUE;"]),
           (Class "FABD_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FABD_asisdsame_only" [] "FABD  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean abs = TRUE;"]),
           (Class "FABD_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FABD_asimdsamefp16_only" []
                 "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean abs = (U == '1');"]),
           (Class "FABD_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FABD_asimdsame_only" []
                 "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean abs = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) diff;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    diff = FPSub(element1, element2, FPCR);\n    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;\n\nV[d] = result;"]),
     Right
       (Page "FABS_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/unary"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O]),
                  Block (Just "opc") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FABS_H_floatdp1" [("type", BlockEq [I, I])]
                 "FABS  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FABS_S_floatdp1" [("type", BlockEq [O, O])]
                 "FABS  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FABS_D_floatdp1" [("type", BlockEq [O, I])]
                 "FABS  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/unary" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;"])]
          [Ps "aarch64/instrs/float/arithmetic/unary" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FABS_advsimd" []
          [(Class "FABS_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/fp16"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FABS_asimdmiscfp16_R" [] "FABS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/fp16"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');"]),
           (Class "FABS_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/float"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FABS_asimdmisc_R" [] "FABS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/float"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/fp16"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    if neg then\n        element = FPNeg(element);\n    else\n        element = FPAbs(element);\n    Elem[result, e, esize] = element;\n\nV[d] = result;"]),
     Right
       (Page "FACGE_advsimd" []
          [(Class "FACGE_asisdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "ac") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FACGE_asisdsamefp16_only" [] "FACGE  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FACGE_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I, I, O]),
                  Block (Just "ac") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FACGE_asisdsame_only" [] "FACGE  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FACGE_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "ac") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FACGE_asimdsamefp16_only" []
                 "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FACGE_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I, I, O]),
                  Block (Just "ac") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FACGE_asimdsame_only" []
                 "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "FACGT_advsimd" []
          [(Class "FACGT_asisdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "E") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "ac") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FACGT_asisdsamefp16_only" [] "FACGT  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FACGT_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "E") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I, I, O]),
                  Block (Just "ac") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FACGT_asisdsame_only" [] "FACGT  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FACGT_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "E") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "ac") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FACGT_asimdsamefp16_only" []
                 "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FACGT_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "E") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I, I, O]),
                  Block (Just "ac") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FACGT_asimdsame_only" []
                 "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "FADD_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/add-sub"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O, I]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FADD_H_floatdp2" [("type", BlockEq [I, I])]
                 "FADD  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing],
               Encoding "FADD_S_floatdp2" [("type", BlockEq [O, O])]
                 "FADD  <Sd>, <Sn>, <Sm>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing],
               Encoding "FADD_D_floatdp2" [("type", BlockEq [O, I])]
                 "FADD  <Dd>, <Dn>, <Dm>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/add-sub" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean sub_op = (op == '1');"])]
          [Ps "aarch64/instrs/float/arithmetic/add-sub" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif sub_op then\n    result = FPSub(operand1, operand2, FPCR);\nelse\n    result = FPAdd(operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FADD_advsimd" []
          [(Class "FADD_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp16"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FADD_asimdsamefp16_only" []
                 "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp16"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');"]),
           (Class "FADD_asimdsame_only" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FADD_asimdsame_only" []
                 "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp16"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPAdd(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FADDP_advsimd_pair" []
          [(Class "FADDP_asisdpair_only_H" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/reduce/fp16-add/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FADDP_asisdpair_only_H" [] "FADDP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "H" [[O]] Nothing, TableRow "RESERVED" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "2H" [[O]] Nothing,
                           TableRow "RESERVED" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp16-add/sisd" (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = ReduceOp_FADD;"]),
           (Class "FADDP_asisdpair_only_SD" Nothing
              (Diagram "aarch64/instrs/vector/reduce/fp-add/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FADDP_asisdpair_only_SD" [] "FADDP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "2S" [[O]] Nothing, TableRow "2D" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp-add/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = ReduceOp_FADD;"])]
          [Ps "aarch64/instrs/vector/reduce/fp16-add/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "FADDP_advsimd_vec" []
          [(Class "FADDP_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp16"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FADDP_asimdsamefp16_only" []
                 "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp16"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');"]),
           (Class "FADDP_asimdsame_only" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FADDP_asimdsame_only" []
                 "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp16"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPAdd(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FCADD_advsimd_vec" []
          [(Class "FCADD_asimdsame2_C" (Just (ArchName "ARMv8.3"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp/complex"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [I, I]),
                  Block (Just "rot") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCADD_asimdsame2_C" []
                 "FCADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<rotate>" "rot"
                    (Just
                       (Table ["rot"]
                          [TableRow "90" [[O]] Nothing, TableRow "270" [[I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp/complex"
               (Just PsDecode)
               "if !HaveFCADDExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' then ReservedValue();\nif Q == '0' && size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\nif !HaveFP16Ext() && esize == 16 then ReservedValue();\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/add/fp/complex"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element3;\n\nfor e = 0 to (elements DIV 2) -1 \n    case rot of \n        when '0'\n            element1 = FPNeg(Elem[operand2, e*2+1, esize]); \n            element3 = Elem[operand2, e*2, esize];\n        when '1'\n            element1 = Elem[operand2, e*2+1, esize]; \n            element3 = FPNeg(Elem[operand2, e*2, esize]);   \n    Elem[result, e*2,   esize] = FPAdd(Elem[operand1, e*2, esize], element1, FPCR);\n    Elem[result, e*2+1, esize] = FPAdd(Elem[operand1, e*2+1, esize], element3, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FCCMP_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/compare/cond"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "op") (BlockEq [O]),
                  Block (Just "nzcv") (BlockEq [X, X, X, X])])
              [Encoding "FCCMP_H_floatccmp" [("type", BlockEq [I, I])]
                 "FCCMP  <Hn>, <Hm>, #<nzcv>, <cond>"
                 [Symbol "<Hn>" "Rn" Nothing, Symbol "<Hm>" "Rm" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "FCCMP_S_floatccmp" [("type", BlockEq [O, O])]
                 "FCCMP  <Sn>, <Sm>, #<nzcv>, <cond>"
                 [Symbol "<Sn>" "Rn" Nothing, Symbol "<Sm>" "Rm" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "FCCMP_D_floatccmp" [("type", BlockEq [O, I])]
                 "FCCMP  <Dn>, <Dm>, #<nzcv>, <cond>"
                 [Symbol "<Dn>" "Rn" Nothing, Symbol "<Dm>" "Rm" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/float/compare/cond" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean signal_all_nans = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;"])]
          [Ps "aarch64/instrs/float/compare/cond" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = V[m];\n\nif ConditionHolds(condition) then\n    flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);\nPSTATE.<N,Z,C,V> = flags;"]),
     Right
       (Page "FCCMPE_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/compare/cond"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "op") (BlockEq [I]),
                  Block (Just "nzcv") (BlockEq [X, X, X, X])])
              [Encoding "FCCMPE_H_floatccmp" [("type", BlockEq [I, I])]
                 "FCCMPE  <Hn>, <Hm>, #<nzcv>, <cond>"
                 [Symbol "<Hn>" "Rn" Nothing, Symbol "<Hm>" "Rm" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "FCCMPE_S_floatccmp" [("type", BlockEq [O, O])]
                 "FCCMPE  <Sn>, <Sm>, #<nzcv>, <cond>"
                 [Symbol "<Sn>" "Rn" Nothing, Symbol "<Sm>" "Rm" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "FCCMPE_D_floatccmp" [("type", BlockEq [O, I])]
                 "FCCMPE  <Dn>, <Dm>, #<nzcv>, <cond>"
                 [Symbol "<Dn>" "Rn" Nothing, Symbol "<Dm>" "Rm" Nothing,
                  Symbol "<nzcv>" "nzcv" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/float/compare/cond" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean signal_all_nans = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;"])]
          [Ps "aarch64/instrs/float/compare/cond" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = V[m];\n\nif ConditionHolds(condition) then\n    flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);\nPSTATE.<N,Z,C,V> = flags;"]),
     Right
       (Page "FCMEQ_advsimd_reg" []
          [(Class "FCMEQ_asisdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMEQ_asisdsamefp16_only" [] "FCMEQ  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FCMEQ_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I, I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMEQ_asisdsame_only" [] "FCMEQ  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FCMEQ_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMEQ_asimdsamefp16_only" []
                 "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FCMEQ_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I, I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMEQ_asimdsame_only" []
                 "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "FCMEQ_advsimd_zero" []
          [(Class "FCMEQ_asisdmiscfp16_FZ" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMEQ_asisdmiscfp16_FZ" [] "FCMEQ  <Hd>, <Hn>, #0.0"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMEQ_asisdmisc_FZ" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMEQ_asisdmisc_FZ" [] "FCMEQ  <V><d>, <V><n>, #0.0"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMEQ_asimdmiscfp16_FZ" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMEQ_asimdmiscfp16_FZ" []
                 "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMEQ_asimdmisc_FZ" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMEQ_asimdmisc_FZ" [] "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "FCMGE_advsimd_reg" []
          [(Class "FCMGE_asisdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGE_asisdsamefp16_only" [] "FCMGE  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FCMGE_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I, I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGE_asisdsame_only" [] "FCMGE  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FCMGE_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGE_asimdsamefp16_only" []
                 "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FCMGE_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "E") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I, I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGE_asimdsame_only" []
                 "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "FCMGE_advsimd_zero" []
          [(Class "FCMGE_asisdmiscfp16_FZ" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGE_asisdmiscfp16_FZ" [] "FCMGE  <Hd>, <Hn>, #0.0"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMGE_asisdmisc_FZ" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGE_asisdmisc_FZ" [] "FCMGE  <V><d>, <V><n>, #0.0"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMGE_asimdmiscfp16_FZ" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGE_asimdmiscfp16_FZ" []
                 "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMGE_asimdmisc_FZ" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGE_asimdmisc_FZ" [] "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "FCMGT_advsimd_reg" []
          [(Class "FCMGT_asisdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "E") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGT_asisdsamefp16_only" [] "FCMGT  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FCMGT_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "E") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I, I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGT_asisdsame_only" [] "FCMGT  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FCMGT_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "E") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGT_asimdsamefp16_only" []
                 "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"]),
           (Class "FCMGT_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "E") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I, I, O]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGT_asimdsame_only" []
                 "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\n\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "FCMGT_advsimd_zero" []
          [(Class "FCMGT_asisdmiscfp16_FZ" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGT_asisdmiscfp16_FZ" [] "FCMGT  <Hd>, <Hn>, #0.0"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMGT_asisdmisc_FZ" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGT_asisdmisc_FZ" [] "FCMGT  <V><d>, <V><n>, #0.0"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMGT_asimdmiscfp16_FZ" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGT_asimdmiscfp16_FZ" []
                 "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMGT_asimdmisc_FZ" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMGT_asimdmisc_FZ" [] "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "FCMLA_advsimd_vec" []
          [(Class "FCMLA_asimdsame2_C" (Just (ArchName "ARMv8.3"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/complex"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "rot") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMLA_asimdsame2_C" []
                 "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<rotate>" "rot"
                    (Just
                       (Table ["rot"]
                          [TableRow "0" [[O, O]] Nothing, TableRow "90" [[O, I]] Nothing,
                           TableRow "180" [[I, O]] Nothing,
                           TableRow "270" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/complex"
               (Just PsDecode)
               "if !HaveFCADDExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' then ReservedValue();\nif Q == '0' && size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\nif !HaveFP16Ext() && esize == 16 then ReservedValue();\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/complex"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) element3;\nbits(esize) element4;\n\nfor e = 0 to (elements DIV 2) -1 \n    case rot of \n        when '00'\n            element1 = Elem[operand2, e*2, esize]; \n            element2 = Elem[operand1, e*2, esize];\n            element3 = Elem[operand2, e*2+1, esize];\n            element4 = Elem[operand1, e*2, esize];\n        when '01'\n            element1 = FPNeg(Elem[operand2, e*2+1, esize]); \n            element2 = Elem[operand1, e*2+1, esize];\n            element3 = Elem[operand2, e*2, esize];\n            element4 = Elem[operand1, e*2+1, esize];\n        when '10'\n            element1 = FPNeg(Elem[operand2, e*2, esize]); \n            element2 = Elem[operand1, e*2, esize];\n            element3 = FPNeg(Elem[operand2, e*2+1, esize]);\n            element4 = Elem[operand1, e*2, esize];\n        when '11'\n            element1 = Elem[operand2, e*2+1, esize]; \n            element2 = Elem[operand1, e*2+1, esize];\n            element3 = FPNeg(Elem[operand2, e*2, esize]);\n            element4 = Elem[operand1, e*2+1, esize];\n\n    Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2,   esize], element2, element1, FPCR);\n    Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FCMLA_advsimd_elt" []
          [(Class "2reg_element" (Just (ArchName "ARMv8.3"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/complex"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "rot") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMLA_asimdelem_C_H" [("size", BlockEq [O, I])]
                 "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "RESERVED" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "M:Rm" Nothing,
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:H:L"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L" [[O, I]] Nothing, TableRow "H" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<rotate>" "rot"
                    (Just
                       (Table ["rot"]
                          [TableRow "0" [[O, O]] Nothing, TableRow "90" [[O, I]] Nothing,
                           TableRow "180" [[I, O]] Nothing,
                           TableRow "270" [[I, I]] Nothing]))],
               Encoding "FCMLA_asimdelem_C_S" [("size", BlockEq [I, O])]
                 "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "RESERVED" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "M:Rm" Nothing,
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:H:L"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L" [[O, I]] Nothing, TableRow "H" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<rotate>" "rot"
                    (Just
                       (Table ["rot"]
                          [TableRow "0" [[O, O]] Nothing, TableRow "90" [[O, I]] Nothing,
                           TableRow "180" [[I, O]] Nothing,
                           TableRow "270" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/complex"
               (Just PsDecode)
               "if !HaveFCADDExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\nif size == '00' || size == '11' then ReservedValue();\nif size == '01' then index = UInt(H:L);\nif size == '10' then index = UInt(H);\ninteger esize = 8 << UInt(size);\nif !HaveFP16Ext() && esize == 16 then ReservedValue();\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nif size == '10' && (L == '1' || Q == '0') then ReservedValue(); \nif size == '01' && H == '1' && Q=='0' then ReservedValue();"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/complex"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[m];\nbits(datasize) operand2 = V[n];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\n\nfor e = 0 to (elements DIV 2) -1 \n    case rot of \n        when '00'\n            element1 = Elem[operand1, index*2, esize]; \n            element2 = Elem[operand2, e*2, esize];\n            element3 = Elem[operand1, index*2+1, esize];\n            element4 = Elem[operand2, e*2, esize];\n        when '01'\n            element1 = FPNeg(Elem[operand1, index*2+1, esize]); \n            element2 = Elem[operand2, e*2+1, esize];\n            element3 = Elem[operand1, index*2, esize];\n            element4 = Elem[operand2, e*2+1, esize];\n        when '10'\n            element1 = FPNeg(Elem[operand1, index*2,esize]); \n            element2 = Elem[operand2, e*2, esize];\n            element3 = FPNeg(Elem[operand1, index*2+1, esize]);\n            element4 = Elem[operand2, e*2, esize];\n        when '11'\n            element1 = Elem[operand1, index*2+1, esize]; \n            element2 = Elem[operand2, e*2+1, esize];\n            element3 = FPNeg(Elem[operand1, index*2, esize]);\n            element4 = Elem[operand2, e*2+1, esize];\n\n    Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, FPCR);\n    Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FCMLE_advsimd" []
          [(Class "FCMLE_asisdmiscfp16_FZ" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMLE_asisdmiscfp16_FZ" [] "FCMLE  <Hd>, <Hn>, #0.0"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMLE_asisdmisc_FZ" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMLE_asisdmisc_FZ" [] "FCMLE  <V><d>, <V><n>, #0.0"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMLE_asimdmiscfp16_FZ" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMLE_asimdmiscfp16_FZ" []
                 "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"]),
           (Class "FCMLE_asimdmisc_FZ" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMLE_asimdmisc_FZ" [] "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "FCMLT_advsimd" []
          [(Class "FCMLT_asisdmiscfp16_FZ" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMLT_asisdmiscfp16_FZ" [] "FCMLT  <Hd>, <Hn>, #0.0"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison = CompareOp_LT;"]),
           (Class "FCMLT_asisdmisc_FZ" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMLT_asisdmisc_FZ" [] "FCMLT  <V><d>, <V><n>, #0.0"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nCompareOp comparison = CompareOp_LT;"]),
           (Class "FCMLT_asimdmiscfp16_FZ" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMLT_asimdmiscfp16_FZ" []
                 "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison = CompareOp_LT;"]),
           (Class "FCMLT_asimdmisc_FZ" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCMLT_asimdmisc_FZ" [] "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nCompareOp comparison = CompareOp_LT;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;"]),
     Right
       (Page "FCMP_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/compare/uncond"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "op") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "opc") (BlockEq [O, X]),
                  Block Nothing (BlockEq [O, O, O])])
              [Encoding "FCMP_H_floatcmp"
                 [("type", BlockEq [I, I]), ("opc", BlockEq [O, O])]
                 "FCMP  <Hn>, <Hm>"
                 [Symbol "<Hn>" "Rn" Nothing, Symbol "<Hm>" "Rm" Nothing],
               Encoding "FCMP_HZ_floatcmp"
                 [("type", BlockEq [I, I]), ("Rm", BlockNeq [O, O, O, O, O]),
                  ("opc", BlockEq [O, I])]
                 "FCMP  <Hn>, #0.0"
                 [Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCMP_S_floatcmp"
                 [("type", BlockEq [O, O]), ("opc", BlockEq [O, O])]
                 "FCMP  <Sn>, <Sm>"
                 [Symbol "<Sn>" "Rn" Nothing, Symbol "<Sm>" "Rm" Nothing],
               Encoding "FCMP_SZ_floatcmp"
                 [("type", BlockEq [O, O]), ("Rm", BlockNeq [O, O, O, O, O]),
                  ("opc", BlockEq [O, I])]
                 "FCMP  <Sn>, #0.0"
                 [Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCMP_D_floatcmp"
                 [("type", BlockEq [O, I]), ("opc", BlockEq [O, O])]
                 "FCMP  <Dn>, <Dm>"
                 [Symbol "<Dn>" "Rn" Nothing, Symbol "<Dm>" "Rm" Nothing],
               Encoding "FCMP_DZ_floatcmp"
                 [("type", BlockEq [O, I]), ("Rm", BlockNeq [O, O, O, O, O]),
                  ("opc", BlockEq [O, I])]
                 "FCMP  <Dn>, #0.0"
                 [Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/compare/uncond" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger m = UInt(Rm);   // ignored when opc<0> == '1'\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean signal_all_nans = (opc<1> == '1');\nboolean cmp_with_zero = (opc<0> == '1');"])]
          [Ps "aarch64/instrs/float/compare/uncond" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = if cmp_with_zero then FPZero('0') else V[m];\n\nPSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);"]),
     Right
       (Page "FCMPE_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/compare/uncond"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "op") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "opc") (BlockEq [I, X]),
                  Block Nothing (BlockEq [O, O, O])])
              [Encoding "FCMPE_H_floatcmp"
                 [("type", BlockEq [I, I]), ("opc", BlockEq [I, O])]
                 "FCMPE  <Hn>, <Hm>"
                 [Symbol "<Hn>" "Rn" Nothing, Symbol "<Hm>" "Rm" Nothing],
               Encoding "FCMPE_HZ_floatcmp"
                 [("type", BlockEq [I, I]), ("Rm", BlockNeq [O, O, O, O, O]),
                  ("opc", BlockEq [I, I])]
                 "FCMPE  <Hn>, #0.0"
                 [Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCMPE_S_floatcmp"
                 [("type", BlockEq [O, O]), ("opc", BlockEq [I, O])]
                 "FCMPE  <Sn>, <Sm>"
                 [Symbol "<Sn>" "Rn" Nothing, Symbol "<Sm>" "Rm" Nothing],
               Encoding "FCMPE_SZ_floatcmp"
                 [("type", BlockEq [O, O]), ("Rm", BlockNeq [O, O, O, O, O]),
                  ("opc", BlockEq [I, I])]
                 "FCMPE  <Sn>, #0.0"
                 [Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCMPE_D_floatcmp"
                 [("type", BlockEq [O, I]), ("opc", BlockEq [I, O])]
                 "FCMPE  <Dn>, <Dm>"
                 [Symbol "<Dn>" "Rn" Nothing, Symbol "<Dm>" "Rm" Nothing],
               Encoding "FCMPE_DZ_floatcmp"
                 [("type", BlockEq [O, I]), ("Rm", BlockNeq [O, O, O, O, O]),
                  ("opc", BlockEq [I, I])]
                 "FCMPE  <Dn>, #0.0"
                 [Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/compare/uncond" (Just PsDecode)
               "integer n = UInt(Rn);\ninteger m = UInt(Rm);   // ignored when opc<0> == '1'\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean signal_all_nans = (opc<1> == '1');\nboolean cmp_with_zero = (opc<0> == '1');"])]
          [Ps "aarch64/instrs/float/compare/uncond" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\n\noperand2 = if cmp_with_zero then FPZero('0') else V[m];\n\nPSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);"]),
     Right
       (Page "FCSEL_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/move/fp/select"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "cond") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCSEL_H_floatsel" [("type", BlockEq [I, I])]
                 "FCSEL  <Hd>, <Hn>, <Hm>, <cond>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "FCSEL_S_floatsel" [("type", BlockEq [O, O])]
                 "FCSEL  <Sd>, <Sn>, <Sm>, <cond>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing],
               Encoding "FCSEL_D_floatsel" [("type", BlockEq [O, I])]
                 "FCSEL  <Dd>, <Dn>, <Dm>, <cond>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing, Symbol "<cond>" "cond" Nothing]],
            [Ps "aarch64/instrs/float/move/fp/select" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nbits(4) condition = cond;"])]
          [Ps "aarch64/instrs/float/move/fp/select" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\n\nresult = if ConditionHolds(condition) then V[n] else V[m];\n\nV[d] = result;"]),
     Right
       (Page "FCVT_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/fp"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, I]),
                  Block (Just "opc") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVT_SH_floatdp1"
                 [("type", BlockEq [I, I]), ("opc", BlockEq [O, O])]
                 "FCVT  <Sd>, <Hn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVT_DH_floatdp1"
                 [("type", BlockEq [I, I]), ("opc", BlockEq [O, I])]
                 "FCVT  <Dd>, <Hn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVT_HS_floatdp1"
                 [("type", BlockEq [O, O]), ("opc", BlockEq [I, I])]
                 "FCVT  <Hd>, <Sn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVT_DS_floatdp1"
                 [("type", BlockEq [O, O]), ("opc", BlockEq [O, I])]
                 "FCVT  <Dd>, <Sn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVT_HD_floatdp1"
                 [("type", BlockEq [O, I]), ("opc", BlockEq [I, I])]
                 "FCVT  <Hd>, <Dn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVT_SD_floatdp1"
                 [("type", BlockEq [O, I]), ("opc", BlockEq [O, O])]
                 "FCVT  <Sd>, <Dn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/fp" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif type == opc then UnallocatedEncoding();\n\ninteger srcsize;\ncase type of\n    when '00' srcsize = 32;\n    when '01' srcsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11' srcsize = 16;\ninteger dstsize;\ncase opc of\n    when '00' dstsize = 32;\n    when '01' dstsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11' dstsize = 16;"])]
          [Ps "aarch64/instrs/float/convert/fp" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(dstsize) result;\nbits(srcsize) operand = V[n];\n\nresult = FPConvert(operand, FPCR);\nV[d] = result;"]),
     Right
       (Page "FCVTAS_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, O, O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTAS_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTAS  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTAS_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTAS  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTAS_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTAS  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTAS_64S_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTAS  <Xd>, <Sn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTAS_32D_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTAS  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVTAS_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTAS  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FCVTAS_advsimd" []
          [(Class "FCVTAS_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size<1>") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTAS_asisdmiscfp16_R" [] "FCVTAS  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');"]),
           (Class "FCVTAS_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTAS_asisdmisc_R" [] "FCVTAS  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');"]),
           (Class "FCVTAS_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTAS_asimdmiscfp16_R" [] "FCVTAS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');"]),
           (Class "FCVTAS_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTAS_asimdmisc_R" [] "FCVTAS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTAU_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, O, I]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTAU_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTAU  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTAU_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTAU  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTAU_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTAU  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTAU_64S_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTAU  <Xd>, <Sn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTAU_32D_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTAU  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVTAU_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTAU  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FCVTAU_advsimd" []
          [(Class "FCVTAU_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size<1>") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTAU_asisdmiscfp16_R" [] "FCVTAU  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');"]),
           (Class "FCVTAU_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTAU_asisdmisc_R" [] "FCVTAU  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');"]),
           (Class "FCVTAU_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTAU_asimdmiscfp16_R" [] "FCVTAU  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');"]),
           (Class "FCVTAU_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTAU_asimdmisc_R" [] "FCVTAU  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTL_advsimd" []
          [(Class "FCVTL_asimdmisc_L" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/widen"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTL_asimdmisc_L" [] "FCVTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "4S" [[O]] Nothing, TableRow "2D" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "4H" [[O], [O]] Nothing,
                           TableRow "8H" [[I], [O]] Nothing, TableRow "2S" [[O], [I]] Nothing,
                           TableRow "4S" [[I], [I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/widen"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16 << UInt(sz);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/float/widen"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(2*datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FCVTMS_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [I, O]),
                  Block (Just "opcode") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTMS_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTMS  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTMS_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTMS  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTMS_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTMS  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTMS_64S_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTMS  <Xd>, <Sn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTMS_32D_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTMS  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVTMS_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTMS  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FCVTMS_advsimd" []
          [(Class "FCVTMS_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTMS_asisdmiscfp16_R" [] "FCVTMS  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTMS_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTMS_asisdmisc_R" [] "FCVTMS  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTMS_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTMS_asimdmiscfp16_R" [] "FCVTMS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTMS_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTMS_asimdmisc_R" [] "FCVTMS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTMU_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [I, O]),
                  Block (Just "opcode") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTMU_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTMU  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTMU_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTMU  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTMU_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTMU  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTMU_64S_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTMU  <Xd>, <Sn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTMU_32D_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTMU  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVTMU_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTMU  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FCVTMU_advsimd" []
          [(Class "FCVTMU_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTMU_asisdmiscfp16_R" [] "FCVTMU  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTMU_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTMU_asisdmisc_R" [] "FCVTMU  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTMU_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTMU_asimdmiscfp16_R" [] "FCVTMU  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTMU_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTMU_asimdmisc_R" [] "FCVTMU  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTN_advsimd" []
          [(Class "FCVTN_asimdmisc_N" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/narrow"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, I, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTN_asimdmisc_N" [] "FCVTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "4H" [[O], [O]] Nothing,
                           TableRow "8H" [[I], [O]] Nothing, TableRow "2S" [[O], [I]] Nothing,
                           TableRow "4S" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "4S" [[O]] Nothing, TableRow "2D" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/narrow"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16 << UInt(sz);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/float/narrow"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR);\n\nVpart[d, part] = result;"]),
     Right
       (Page "FCVTNS_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTNS_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTNS  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTNS_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTNS  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTNS_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTNS  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTNS_64S_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTNS  <Xd>, <Sn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTNS_32D_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTNS  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVTNS_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTNS  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FCVTNS_advsimd" []
          [(Class "FCVTNS_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTNS_asisdmiscfp16_R" [] "FCVTNS  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTNS_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTNS_asisdmisc_R" [] "FCVTNS  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTNS_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTNS_asimdmiscfp16_R" [] "FCVTNS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTNS_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTNS_asimdmisc_R" [] "FCVTNS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTNU_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTNU_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTNU  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTNU_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTNU  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTNU_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTNU  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTNU_64S_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTNU  <Xd>, <Sn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTNU_32D_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTNU  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVTNU_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTNU  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FCVTNU_advsimd" []
          [(Class "FCVTNU_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTNU_asisdmiscfp16_R" [] "FCVTNU  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTNU_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTNU_asisdmisc_R" [] "FCVTNU  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTNU_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTNU_asimdmiscfp16_R" [] "FCVTNU  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTNU_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTNU_asimdmisc_R" [] "FCVTNU  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTPS_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [O, I]),
                  Block (Just "opcode") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTPS_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTPS  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTPS_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTPS  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTPS_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTPS  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTPS_64S_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTPS  <Xd>, <Sn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTPS_32D_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTPS  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVTPS_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTPS  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FCVTPS_advsimd" []
          [(Class "FCVTPS_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTPS_asisdmiscfp16_R" [] "FCVTPS  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTPS_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTPS_asisdmisc_R" [] "FCVTPS  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTPS_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTPS_asimdmiscfp16_R" [] "FCVTPS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTPS_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTPS_asimdmisc_R" [] "FCVTPS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTPU_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [O, I]),
                  Block (Just "opcode") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTPU_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTPU  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTPU_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTPU  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTPU_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTPU  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTPU_64S_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTPU  <Xd>, <Sn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTPU_32D_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTPU  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVTPU_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTPU  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FCVTPU_advsimd" []
          [(Class "FCVTPU_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTPU_asisdmiscfp16_R" [] "FCVTPU  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTPU_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTPU_asisdmisc_R" [] "FCVTPU  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTPU_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTPU_asimdmiscfp16_R" [] "FCVTPU  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTPU_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTPU_asimdmisc_R" [] "FCVTPU  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTXN_advsimd" []
          [(Class "FCVTXN_asisdmisc_N" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/xtn/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, I, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTXN_asisdmisc_N" [] "FCVTXN  <Vb><d>, <Va><n>"
                 [Symbol "<Vb>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "RESERVED" [[O]] Nothing, TableRow "S" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Va>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "RESERVED" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/xtn/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz == '0' then ReservedValue();\ninteger esize = 32;\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;"]),
           (Class "FCVTXN_asimdmisc_N" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/xtn/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, I, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTXN_asimdmisc_N" [] "FCVTXN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "RESERVED" [[X], [O]] Nothing,
                           TableRow "2S" [[O], [I]] Nothing,
                           TableRow "4S" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "RESERVED" [[O]] Nothing,
                           TableRow "2D" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/xtn/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz == '0' then ReservedValue();\ninteger esize = 32;\ninteger datasize = 64;\ninteger elements = 2;\ninteger part = UInt(Q);"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/float/xtn/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR, FPRounding_ODD);\n\nVpart[d, part] = result;"]),
     Right
       (Page "FCVTZS_float_fix" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/fix"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "rmode") (BlockEq [I, I]),
                  Block (Just "opcode") (BlockEq [O, O, O]),
                  Block (Just "scale") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZS_32H_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTZS  <Wd>, <Hn>, #<fbits>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "FCVTZS_64H_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTZS  <Xd>, <Hn>, #<fbits>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "FCVTZS_32S_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTZS  <Wd>, <Sn>, #<fbits>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "FCVTZS_64S_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTZS  <Xd>, <Sn>, #<fbits>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "FCVTZS_32D_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTZS  <Wd>, <Dn>, #<fbits>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "FCVTZS_64D_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTZS  <Xd>, <Dn>, #<fbits>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing]],
            [Ps "aarch64/instrs/float/convert/fix" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/fix" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"]),
     Right
       (Page "FCVTZS_float_int" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [I, I]),
                  Block (Just "opcode") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZS_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTZS  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTZS_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTZS  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTZS_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTZS  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTZS_64S_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTZS  <Xd>, <Sn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTZS_32D_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTZS  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVTZS_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTZS  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FCVTZS_advsimd_fix" []
          [(Class "FCVTZS_asisdshf_C" Nothing
              (Diagram "aarch64/instrs/vector/shift/conv/float/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZS_asisdshf_C" [] "FCVTZS  <V><d>, <V><n>, #<fbits>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, X]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<fbits>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, X]] Nothing,
                           TableRow "(32-Uint(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/conv/float/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;"]),
           (Class "FCVTZS_asimdshf_C" Nothing
              (Diagram "aarch64/instrs/vector/shift/conv/float/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZS_asimdshf_C" []
                 "FCVTZS  <Vd>.<T>, <Vn>.<T>, #<fbits>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "RESERVED" [[X], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<fbits>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "RESERVED" [[O, O, O, I]] Nothing,
                           TableRow "(32-Uint(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/conv/float/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;"])]
          [Ps "aarch64/instrs/vector/shift/conv/float/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTZS_advsimd_int" []
          [(Class "FCVTZS_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZS_asisdmiscfp16_R" [] "FCVTZS  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTZS_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZS_asisdmisc_R" [] "FCVTZS  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTZS_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZS_asimdmiscfp16_R" [] "FCVTZS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTZS_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZS_asimdmisc_R" [] "FCVTZS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTZU_float_fix" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/fix"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "rmode") (BlockEq [I, I]),
                  Block (Just "opcode") (BlockEq [O, O, I]),
                  Block (Just "scale") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZU_32H_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTZU  <Wd>, <Hn>, #<fbits>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "FCVTZU_64H_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTZU  <Xd>, <Hn>, #<fbits>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "FCVTZU_32S_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTZU  <Wd>, <Sn>, #<fbits>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "FCVTZU_64S_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTZU  <Xd>, <Sn>, #<fbits>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "FCVTZU_32D_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTZU  <Wd>, <Dn>, #<fbits>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "FCVTZU_64D_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTZU  <Xd>, <Dn>, #<fbits>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing]],
            [Ps "aarch64/instrs/float/convert/fix" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/fix" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"]),
     Right
       (Page "FCVTZU_float_int" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [I, I]),
                  Block (Just "opcode") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZU_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "FCVTZU  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTZU_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "FCVTZU  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FCVTZU_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "FCVTZU  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTZU_64S_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "FCVTZU  <Xd>, <Sn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FCVTZU_32D_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "FCVTZU  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FCVTZU_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "FCVTZU  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FCVTZU_advsimd_fix" []
          [(Class "FCVTZU_asisdshf_C" Nothing
              (Diagram "aarch64/instrs/vector/shift/conv/float/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZU_asisdshf_C" [] "FCVTZU  <V><d>, <V><n>, #<fbits>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, X]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<fbits>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, X]] Nothing,
                           TableRow "(32-Uint(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/conv/float/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;"]),
           (Class "FCVTZU_asimdshf_C" Nothing
              (Diagram "aarch64/instrs/vector/shift/conv/float/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZU_asimdshf_C" []
                 "FCVTZU  <Vd>.<T>, <Vn>.<T>, #<fbits>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "RESERVED" [[X], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<fbits>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "RESERVED" [[O, O, O, I]] Nothing,
                           TableRow "(32-Uint(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/conv/float/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;"])]
          [Ps "aarch64/instrs/vector/shift/conv/float/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FCVTZU_advsimd_int" []
          [(Class "FCVTZU_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZU_asisdmiscfp16_R" [] "FCVTZU  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTZU_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZU_asisdmisc_R" [] "FCVTZU  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTZU_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZU_asimdmiscfp16_R" [] "FCVTZU  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"]),
           (Class "FCVTZU_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, I]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FCVTZU_asimdmisc_R" [] "FCVTZU  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "FDIV_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/div"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FDIV_H_floatdp2" [("type", BlockEq [I, I])]
                 "FDIV  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing],
               Encoding "FDIV_S_floatdp2" [("type", BlockEq [O, O])]
                 "FDIV  <Sd>, <Sn>, <Sm>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing],
               Encoding "FDIV_D_floatdp2" [("type", BlockEq [O, I])]
                 "FDIV  <Dd>, <Dn>, <Dm>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/div" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/arithmetic/div" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nresult = FPDiv(operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FDIV_advsimd" []
          [(Class "FDIV_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/div-fp16"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FDIV_asimdsamefp16_only" []
                 "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/div-fp16"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"]),
           (Class "FDIV_asimdsame_only" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/div"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FDIV_asimdsame_only" []
                 "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/div"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/div-fp16"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPDiv(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FJCVTZS" []
          [(Class "FJCVTZS_32D_float2int" (Just (ArchName "ARMv8.3"))
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [O, I]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [I, I]),
                  Block (Just "opcode") (BlockEq [I, I, O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FJCVTZS_32D_float2int" [] "FJCVTZS  <Wd>, <Dn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FMADD_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/mul/add-sub"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "type") (BlockEq [X, X]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMADD_H_floatdp3" [("type", BlockEq [I, I])]
                 "FMADD  <Hd>, <Hn>, <Hm>, <Ha>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing, Symbol "<Ha>" "Ra" Nothing],
               Encoding "FMADD_S_floatdp3" [("type", BlockEq [O, O])]
                 "FMADD  <Sd>, <Sn>, <Sm>, <Sa>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing, Symbol "<Sa>" "Ra" Nothing],
               Encoding "FMADD_D_floatdp3" [("type", BlockEq [O, I])]
                 "FMADD  <Dd>, <Dn>, <Dm>, <Da>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing, Symbol "<Da>" "Ra" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/mul/add-sub" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);"])]
          [Ps "aarch64/instrs/float/arithmetic/mul/add-sub" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMAX_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/max-min"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "op") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAX_H_floatdp2" [("type", BlockEq [I, I])]
                 "FMAX  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing],
               Encoding "FMAX_S_floatdp2" [("type", BlockEq [O, O])]
                 "FMAX  <Sd>, <Sn>, <Sm>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing],
               Encoding "FMAX_D_floatdp2" [("type", BlockEq [O, I])]
                 "FMAX  <Dd>, <Dn>, <Dm>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/max-min" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;"])]
          [Ps "aarch64/instrs/float/arithmetic/max-min" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMAX_advsimd" []
          [(Class "FMAX_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAX_asimdsamefp16_only" []
                 "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"]),
           (Class "FMAX_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAX_asimdsame_only" []
                 "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMAXNM_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/max-min"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "op") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXNM_H_floatdp2" [("type", BlockEq [I, I])]
                 "FMAXNM  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing],
               Encoding "FMAXNM_S_floatdp2" [("type", BlockEq [O, O])]
                 "FMAXNM  <Sd>, <Sn>, <Sm>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing],
               Encoding "FMAXNM_D_floatdp2" [("type", BlockEq [O, I])]
                 "FMAXNM  <Dd>, <Dn>, <Dm>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/max-min" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;"])]
          [Ps "aarch64/instrs/float/arithmetic/max-min" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMAXNM_advsimd" []
          [(Class "FMAXNM_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Op3") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXNM_asimdsamefp16_only" []
                 "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');"]),
           (Class "FMAXNM_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXNM_asimdsame_only" []
                 "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMAXNMP_advsimd_pair" []
          [(Class "FMAXNMP_asisdpair_only_H" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/reduce/fp16-maxnm/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block (Just "sz") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXNMP_asisdpair_only_H" [] "FMAXNMP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "H" [[O]] Nothing, TableRow "RESERVED" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "2H" [[O]] Nothing,
                           TableRow "RESERVED" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp16-maxnm/sisd" (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;"]),
           (Class "FMAXNMP_asisdpair_only_SD" Nothing
              (Diagram "aarch64/instrs/vector/reduce/fp-maxnm/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXNMP_asisdpair_only_SD" []
                 "FMAXNMP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "2S" [[O]] Nothing, TableRow "2D" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp-maxnm/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;"])]
          [Ps "aarch64/instrs/vector/reduce/fp16-maxnm/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "FMAXNMP_advsimd_vec" []
          [(Class "FMAXNMP_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Op3") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXNMP_asimdsamefp16_only" []
                 "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');"]),
           (Class "FMAXNMP_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXNMP_asimdsame_only" []
                 "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMAXNMV_advsimd" []
          [(Class "FMAXNMV_asimdall_only_H" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/reduce/fp16-maxnm/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXNMV_asimdall_only_H" [] "FMAXNMV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "" Nothing, Symbol "<d>" "Rd" Nothing,
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp16-maxnm/simd" (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;"]),
           (Class "FMAXNMV_asimdall_only_SD" Nothing
              (Diagram "aarch64/instrs/vector/reduce/fp-maxnm/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXNMV_asimdall_only_SD" [] "FMAXNMV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "RESERVED" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "Q:sz"
                    (Just
                       (Table ["sz", "Q"]
                          [TableRow "RESERVED" [[X], [O]] Nothing,
                           TableRow "4S" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp-maxnm/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q != '01' then ReservedValue();   // .4S only\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;"])]
          [Ps "aarch64/instrs/vector/reduce/fp16-maxnm/simd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "FMAXP_advsimd_pair" []
          [(Class "FMAXP_asisdpair_only_H" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/reduce/fp16-max/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block (Just "sz") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXP_asisdpair_only_H" [] "FMAXP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "H" [[O]] Nothing, TableRow "RESERVED" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "2H" [[O]] Nothing,
                           TableRow "RESERVED" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp16-max/sisd" (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;"]),
           (Class "FMAXP_asisdpair_only_SD" Nothing
              (Diagram "aarch64/instrs/vector/reduce/fp-max/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXP_asisdpair_only_SD" [] "FMAXP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "2S" [[O]] Nothing, TableRow "2D" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp-max/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;"])]
          [Ps "aarch64/instrs/vector/reduce/fp16-max/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "FMAXP_advsimd_vec" []
          [(Class "FMAXP_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXP_asimdsamefp16_only" []
                 "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"]),
           (Class "FMAXP_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXP_asimdsame_only" []
                 "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMAXV_advsimd" []
          [(Class "FMAXV_asimdall_only_H" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/reduce/fp16-max/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXV_asimdall_only_H" [] "FMAXV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "" Nothing, Symbol "<d>" "Rd" Nothing,
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp16-max/simd" (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;"]),
           (Class "FMAXV_asimdall_only_SD" Nothing
              (Diagram "aarch64/instrs/vector/reduce/fp-max/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMAXV_asimdall_only_SD" [] "FMAXV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "RESERVED" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "Q:sz"
                    (Just
                       (Table ["sz", "Q"]
                          [TableRow "RESERVED" [[X], [O]] Nothing,
                           TableRow "4S" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp-max/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q != '01' then ReservedValue();\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;"])]
          [Ps "aarch64/instrs/vector/reduce/fp16-max/simd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "FMIN_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/max-min"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "op") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMIN_H_floatdp2" [("type", BlockEq [I, I])]
                 "FMIN  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing],
               Encoding "FMIN_S_floatdp2" [("type", BlockEq [O, O])]
                 "FMIN  <Sd>, <Sn>, <Sm>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing],
               Encoding "FMIN_D_floatdp2" [("type", BlockEq [O, I])]
                 "FMIN  <Dd>, <Dn>, <Dm>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/max-min" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;"])]
          [Ps "aarch64/instrs/float/arithmetic/max-min" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMIN_advsimd" []
          [(Class "FMIN_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMIN_asimdsamefp16_only" []
                 "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"]),
           (Class "FMIN_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMIN_asimdsame_only" []
                 "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMINNM_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/max-min"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "op") (BlockEq [I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINNM_H_floatdp2" [("type", BlockEq [I, I])]
                 "FMINNM  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing],
               Encoding "FMINNM_S_floatdp2" [("type", BlockEq [O, O])]
                 "FMINNM  <Sd>, <Sn>, <Sm>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing],
               Encoding "FMINNM_D_floatdp2" [("type", BlockEq [O, I])]
                 "FMINNM  <Dd>, <Dn>, <Dm>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/max-min" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;"])]
          [Ps "aarch64/instrs/float/arithmetic/max-min" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMINNM_advsimd" []
          [(Class "FMINNM_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Op3") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINNM_asimdsamefp16_only" []
                 "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');"]),
           (Class "FMINNM_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINNM_asimdsame_only" []
                 "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMINNMP_advsimd_pair" []
          [(Class "FMINNMP_asisdpair_only_H" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/reduce/fp16-maxnm/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block (Just "sz") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINNMP_asisdpair_only_H" [] "FMINNMP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "H" [[O]] Nothing, TableRow "RESERVED" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "2H" [[O]] Nothing,
                           TableRow "RESERVED" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp16-maxnm/sisd" (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;"]),
           (Class "FMINNMP_asisdpair_only_SD" Nothing
              (Diagram "aarch64/instrs/vector/reduce/fp-maxnm/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINNMP_asisdpair_only_SD" []
                 "FMINNMP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "2S" [[O]] Nothing, TableRow "2D" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp-maxnm/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;"])]
          [Ps "aarch64/instrs/vector/reduce/fp16-maxnm/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "FMINNMP_advsimd_vec" []
          [(Class "FMINNMP_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Op3") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINNMP_asimdsamefp16_only" []
                 "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (a == '1');"]),
           (Class "FMINNMP_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINNMP_asimdsame_only" []
                 "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMINNMV_advsimd" []
          [(Class "FMINNMV_asimdall_only_H" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/reduce/fp16-maxnm/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINNMV_asimdall_only_H" [] "FMINNMV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "" Nothing, Symbol "<d>" "Rd" Nothing,
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp16-maxnm/simd" (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;"]),
           (Class "FMINNMV_asimdall_only_SD" Nothing
              (Diagram "aarch64/instrs/vector/reduce/fp-maxnm/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINNMV_asimdall_only_SD" [] "FMINNMV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "RESERVED" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "Q:sz"
                    (Just
                       (Table ["sz", "Q"]
                          [TableRow "RESERVED" [[X], [O]] Nothing,
                           TableRow "4S" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp-maxnm/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q != '01' then ReservedValue();   // .4S only\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;"])]
          [Ps "aarch64/instrs/vector/reduce/fp16-maxnm/simd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "FMINP_advsimd_pair" []
          [(Class "FMINP_asisdpair_only_H" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/reduce/fp16-max/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block (Just "sz") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINP_asisdpair_only_H" [] "FMINP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "H" [[O]] Nothing, TableRow "RESERVED" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "2H" [[O]] Nothing,
                           TableRow "RESERVED" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp16-max/sisd" (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;"]),
           (Class "FMINP_asisdpair_only_SD" Nothing
              (Diagram "aarch64/instrs/vector/reduce/fp-max/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINP_asisdpair_only_SD" [] "FMINP  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "2S" [[O]] Nothing, TableRow "2D" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp-max/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize * 2;\ninteger elements = 2;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;"])]
          [Ps "aarch64/instrs/vector/reduce/fp16-max/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "FMINP_advsimd_vec" []
          [(Class "FMINP_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINP_asimdsamefp16_only" []
                 "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"]),
           (Class "FMINP_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINP_asimdsame_only" []
                 "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMINV_advsimd" []
          [(Class "FMINV_asimdall_only_H" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/reduce/fp16-max/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINV_asimdall_only_H" [] "FMINV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "" Nothing, Symbol "<d>" "Rd" Nothing,
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp16-max/simd" (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;"]),
           (Class "FMINV_asimdall_only_SD" Nothing
              (Diagram "aarch64/instrs/vector/reduce/fp-max/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMINV_asimdall_only_SD" [] "FMINV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "RESERVED" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "Q:sz"
                    (Just
                       (Table ["sz", "Q"]
                          [TableRow "RESERVED" [[X], [O]] Nothing,
                           TableRow "4S" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/fp-max/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q != '01' then ReservedValue();\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;"])]
          [Ps "aarch64/instrs/vector/reduce/fp16-max/simd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);"]),
     Right
       (Page "FMLA_advsimd_elt" []
          [(Class "FMLA_asisdelem_RH_H" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLA_asisdelem_RH_H" []
                 "FMLA  <Hd>, <Hn>, <Vm>.H[<index>]"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<index>" "H:L:M" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');"]),
           (Class "FMLA_asisdelem_R_SD" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLA_asisdelem_R_SD" []
                 "FMLA  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "M:Rm" Nothing,
                  Symbol "<Ts>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<index>" "sz:L:H"
                    (Just
                       (Table ["L", "sz"]
                          [TableRow "H:L" [[X], [O]] Nothing,
                           TableRow "H" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/sisd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');"]),
           (Class "FMLA_asimdelem_RH_H" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLA_asimdelem_RH_H" []
                 "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<index>" "H:L:M" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');"]),
           (Class "FMLA_asimdelem_R_SD" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLA_asimdelem_R_SD" []
                 "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q:sz"
                    (Just
                       (Table ["sz", "Q"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "RESERVED" [[I], [O]] Nothing,
                           TableRow "4S" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "M:Rm" Nothing,
                  Symbol "<Ts>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<index>" "sz:L:H"
                    (Just
                       (Table ["L", "sz"]
                          [TableRow "H:L" [[X], [O]] Nothing,
                           TableRow "H" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/simd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\nV[d] = result;"]),
     Right
       (Page "FMLA_advsimd_vec" []
          [(Class "FMLA_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/fused"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLA_asimdsamefp16_only" []
                 "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/fused"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (a == '1');"]),
           (Class "FMLA_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/fused"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "op") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLA_asimdsame_only" []
                 "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/fused"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (op == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/fused"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMLS_advsimd_elt" []
          [(Class "FMLS_asisdelem_RH_H" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLS_asisdelem_RH_H" []
                 "FMLS  <Hd>, <Hn>, <Vm>.H[<index>]"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<index>" "H:L:M" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');"]),
           (Class "FMLS_asisdelem_R_SD" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLS_asisdelem_R_SD" []
                 "FMLS  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "M:Rm" Nothing,
                  Symbol "<Ts>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<index>" "sz:L:H"
                    (Just
                       (Table ["L", "sz"]
                          [TableRow "H:L" [[X], [O]] Nothing,
                           TableRow "H" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/sisd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');"]),
           (Class "FMLS_asimdelem_RH_H" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLS_asimdelem_RH_H" []
                 "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<index>" "H:L:M" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');"]),
           (Class "FMLS_asimdelem_R_SD" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLS_asimdelem_R_SD" []
                 "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q:sz"
                    (Just
                       (Table ["sz", "Q"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "RESERVED" [[I], [O]] Nothing,
                           TableRow "4S" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "M:Rm" Nothing,
                  Symbol "<Ts>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<index>" "sz:L:H"
                    (Just
                       (Table ["L", "sz"]
                          [TableRow "H:L" [[X], [O]] Nothing,
                           TableRow "H" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/simd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\nV[d] = result;"]),
     Right
       (Page "FMLS_advsimd_vec" []
          [(Class "FMLS_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/fused"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLS_asimdsamefp16_only" []
                 "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/fused"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (a == '1');"]),
           (Class "FMLS_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/fused"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "op") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMLS_asimdsame_only" []
                 "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/fused"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (op == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/fused"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMOV_float_gen" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [O, X]),
                  Block (Just "opcode") (BlockEq [I, I, X]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMOV_32H_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I]),
                  ("rmode", BlockEq [O, O]), ("opcode", BlockEq [I, I, O])]
                 "FMOV  <Wd>, <Hn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FMOV_64H_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I]),
                  ("rmode", BlockEq [O, O]), ("opcode", BlockEq [I, I, O])]
                 "FMOV  <Xd>, <Hn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FMOV_H32_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I]),
                  ("rmode", BlockEq [O, O]), ("opcode", BlockEq [I, I, I])]
                 "FMOV  <Hd>, <Wn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "FMOV_S32_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O]),
                  ("rmode", BlockEq [O, O]), ("opcode", BlockEq [I, I, I])]
                 "FMOV  <Sd>, <Wn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "FMOV_32S_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O]),
                  ("rmode", BlockEq [O, O]), ("opcode", BlockEq [I, I, O])]
                 "FMOV  <Wd>, <Sn>"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FMOV_H64_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I]),
                  ("rmode", BlockEq [O, O]), ("opcode", BlockEq [I, I, I])]
                 "FMOV  <Hd>, <Xn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing],
               Encoding "FMOV_D64_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I]),
                  ("rmode", BlockEq [O, O]), ("opcode", BlockEq [I, I, I])]
                 "FMOV  <Dd>, <Xn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing],
               Encoding "FMOV_V64I_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, O]),
                  ("rmode", BlockEq [O, I]), ("opcode", BlockEq [I, I, I])]
                 "FMOV  <Vd>.D[1], <Xn>"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing],
               Encoding "FMOV_64D_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I]),
                  ("rmode", BlockEq [O, O]), ("opcode", BlockEq [I, I, O])]
                 "FMOV  <Xd>, <Dn>"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing],
               Encoding "FMOV_64VX_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, O]),
                  ("rmode", BlockEq [O, I]), ("opcode", BlockEq [I, I, O])]
                 "FMOV  <Xd>, <Vn>.D[1]"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "FMOV_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/unary"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O]),
                  Block (Just "opc") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMOV_H_floatdp1" [("type", BlockEq [I, I])]
                 "FMOV  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FMOV_S_floatdp1" [("type", BlockEq [O, O])]
                 "FMOV  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FMOV_D_floatdp1" [("type", BlockEq [O, I])]
                 "FMOV  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/unary" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;"])]
          [Ps "aarch64/instrs/float/arithmetic/unary" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMOV_float_imm" []
          [(Class "imm8f" Nothing
              (Diagram "aarch64/instrs/float/move/fp/imm"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "imm8") (BlockEq [X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O, O]),
                  Block (Just "imm5") (BlockEq [O, O, O, O, O]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMOV_H_floatimm" [("type", BlockEq [I, I])]
                 "FMOV  <Hd>, #<imm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<imm>" "imm8" Nothing],
               Encoding "FMOV_S_floatimm" [("type", BlockEq [O, O])]
                 "FMOV  <Sd>, #<imm>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<imm>" "imm8" Nothing],
               Encoding "FMOV_D_floatimm" [("type", BlockEq [O, I])]
                 "FMOV  <Dd>, #<imm>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<imm>" "imm8" Nothing]],
            [Ps "aarch64/instrs/float/move/fp/imm" (Just PsDecode)
               "integer d = UInt(Rd);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nbits(datasize) imm = VFPExpandImm(imm8);"])]
          [Ps "aarch64/instrs/float/move/fp/imm" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nV[d] = imm;"]),
     Right
       (Page "FMOV_advsimd" []
          [(Class "FMOV_asimdimm_H_h" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/fp16_movi"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O, O, O, O, O]),
                  Block (Just "a") (BlockEq [X]), Block (Just "b") (BlockEq [X]),
                  Block (Just "c") (BlockEq [X]),
                  Block (Just "cmode") (BlockEq [I, I, I, I]),
                  Block (Just "o2") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "d") (BlockEq [X]), Block (Just "e") (BlockEq [X]),
                  Block (Just "f") (BlockEq [X]), Block (Just "g") (BlockEq [X]),
                  Block (Just "h") (BlockEq [X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMOV_asimdimm_H_h" [] "FMOV  <Vd>.<T>, #<imm>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<imm>" "a:b:c:d:e:f:g:h" Nothing]],
            [Ps "aarch64/instrs/vector/fp16_movi" (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\n\nimm8 = a:b:c:d:e:f:g:h;\nimm16 = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>,2):imm8<5:0>:Zeros(6);\n\nimm = Replicate(imm16, datasize DIV 16);"]),
           (Class "single_and_double" Nothing
              (Diagram "aarch64/instrs/vector/logical"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "op") (BlockEq [X]),
                  Block Nothing (BlockEq [O, I, I, I, I, O, O, O, O, O]),
                  Block (Just "a") (BlockEq [X]), Block (Just "b") (BlockEq [X]),
                  Block (Just "c") (BlockEq [X]),
                  Block (Just "cmode") (BlockEq [I, I, I, I]),
                  Block (Just "o2") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "d") (BlockEq [X]), Block (Just "e") (BlockEq [X]),
                  Block (Just "f") (BlockEq [X]), Block (Just "g") (BlockEq [X]),
                  Block (Just "h") (BlockEq [X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMOV_asimdimm_S_s" [("op", BlockEq [O])]
                 "FMOV  <Vd>.<T>, #<imm>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<imm>" "a:b:c:d:e:f:g:h" Nothing],
               Encoding "FMOV_asimdimm_D2_d"
                 [("Q", BlockEq [I]), ("op", BlockEq [I])]
                 "FMOV  <Vd>.2D, #<imm>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<imm>" "a:b:c:d:e:f:g:h" Nothing]],
            [Ps "aarch64/instrs/vector/logical" (Just PsDecode)
               "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);"])]
          [Ps "aarch64/instrs/vector/fp16_movi" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nV[rd] = imm;"]),
     Right
       (Page "FMSUB_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/mul/add-sub"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "type") (BlockEq [X, X]),
                  Block (Just "o1") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMSUB_H_floatdp3" [("type", BlockEq [I, I])]
                 "FMSUB  <Hd>, <Hn>, <Hm>, <Ha>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing, Symbol "<Ha>" "Ra" Nothing],
               Encoding "FMSUB_S_floatdp3" [("type", BlockEq [O, O])]
                 "FMSUB  <Sd>, <Sn>, <Sm>, <Sa>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing, Symbol "<Sa>" "Ra" Nothing],
               Encoding "FMSUB_D_floatdp3" [("type", BlockEq [O, I])]
                 "FMSUB  <Dd>, <Dn>, <Dm>, <Da>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing, Symbol "<Da>" "Ra" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/mul/add-sub" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);"])]
          [Ps "aarch64/instrs/float/arithmetic/mul/add-sub" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMUL_advsimd_elt" []
          [(Class "FMUL_asisdelem_RH_H" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMUL_asisdelem_RH_H" []
                 "FMUL  <Hd>, <Hn>, <Vm>.H[<index>]"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<index>" "H:L:M" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');"]),
           (Class "FMUL_asisdelem_R_SD" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/fp/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMUL_asisdelem_R_SD" []
                 "FMUL  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "M:Rm" Nothing,
                  Symbol "<Ts>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<index>" "sz:L:H"
                    (Just
                       (Table ["L", "sz"]
                          [TableRow "H:L" [[X], [O]] Nothing,
                           TableRow "H" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/fp/sisd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');"]),
           (Class "FMUL_asimdelem_RH_H" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMUL_asimdelem_RH_H" []
                 "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<index>" "H:L:M" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean mulx_op = (U == '1');"]),
           (Class "FMUL_asimdelem_R_SD" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMUL_asimdelem_R_SD" []
                 "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q:sz"
                    (Just
                       (Table ["sz", "Q"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "RESERVED" [[I], [O]] Nothing,
                           TableRow "4S" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "M:Rm" Nothing,
                  Symbol "<Ts>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<index>" "sz:L:H"
                    (Just
                       (Table ["L", "sz"]
                          [TableRow "H:L" [[X], [O]] Nothing,
                           TableRow "H" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/fp/simd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean mulx_op = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if mulx_op then\n        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMUL_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/mul/product"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMUL_H_floatdp2" [("type", BlockEq [I, I])]
                 "FMUL  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing],
               Encoding "FMUL_S_floatdp2" [("type", BlockEq [O, O])]
                 "FMUL  <Sd>, <Sn>, <Sm>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing],
               Encoding "FMUL_D_floatdp2" [("type", BlockEq [O, I])]
                 "FMUL  <Dd>, <Dn>, <Dm>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/mul/product" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean negated = (op == '1');"])]
          [Ps "aarch64/instrs/float/arithmetic/mul/product" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nresult = FPMul(operand1, operand2, FPCR);\n\nif negated then result = FPNeg(result);\n\nV[d] = result;"]),
     Right
       (Page "FMUL_advsimd_vec" []
          [(Class "FMUL_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/product"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMUL_asimdsamefp16_only" []
                 "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/product"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"]),
           (Class "FMUL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/product"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMUL_asimdsame_only" []
                 "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/product"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/product"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FMULX_advsimd_vec" []
          [(Class "FMULX_asisdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMULX_asisdsamefp16_only" [] "FMULX  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FMULX_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMULX_asisdsame_only" [] "FMULX  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FMULX_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMULX_asimdsamefp16_only" []
                 "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"]),
           (Class "FMULX_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMULX_asimdsame_only" []
                 "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\nV[d] = result;"]),
     Right
       (Page "FMULX_advsimd_elt" []
          [(Class "FMULX_asisdelem_RH_H" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMULX_asisdelem_RH_H" []
                 "FMULX  <Hd>, <Hn>, <Vm>.H[<index>]"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<index>" "H:L:M" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');"]),
           (Class "FMULX_asisdelem_R_SD" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/fp/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMULX_asisdelem_R_SD" []
                 "FMULX  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "M:Rm" Nothing,
                  Symbol "<Ts>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<index>" "sz:L:H"
                    (Just
                       (Table ["L", "sz"]
                          [TableRow "H:L" [[X], [O]] Nothing,
                           TableRow "H" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/fp/sisd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');"]),
           (Class "FMULX_asimdelem_RH_H" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMULX_asimdelem_RH_H" []
                 "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<index>" "H:L:M" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean mulx_op = (U == '1');"]),
           (Class "FMULX_asimdelem_R_SD" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FMULX_asimdelem_R_SD" []
                 "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q:sz"
                    (Just
                       (Table ["sz", "Q"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "RESERVED" [[I], [O]] Nothing,
                           TableRow "4S" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "M:Rm" Nothing,
                  Symbol "<Ts>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<index>" "sz:L:H"
                    (Just
                       (Table ["L", "sz"]
                          [TableRow "H:L" [[X], [O]] Nothing,
                           TableRow "H" [[O], [I]] Nothing,
                           TableRow "RESERVED" [[I], [I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/fp/simd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean mulx_op = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if mulx_op then\n        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FNEG_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/unary"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O]),
                  Block (Just "opc") (BlockEq [I, O]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FNEG_H_floatdp1" [("type", BlockEq [I, I])]
                 "FNEG  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FNEG_S_floatdp1" [("type", BlockEq [O, O])]
                 "FNEG  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FNEG_D_floatdp1" [("type", BlockEq [O, I])]
                 "FNEG  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/unary" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;"])]
          [Ps "aarch64/instrs/float/arithmetic/unary" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FNEG_advsimd" []
          [(Class "FNEG_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/fp16"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FNEG_asimdmiscfp16_R" [] "FNEG  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/fp16"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');"]),
           (Class "FNEG_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/float"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FNEG_asimdmisc_R" [] "FNEG  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/float"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/fp16"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    if neg then\n        element = FPNeg(element);\n    else\n        element = FPAbs(element);\n    Elem[result, e, esize] = element;\n\nV[d] = result;"]),
     Right
       (Page "FNMADD_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/mul/add-sub"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "type") (BlockEq [X, X]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [O]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FNMADD_H_floatdp3" [("type", BlockEq [I, I])]
                 "FNMADD  <Hd>, <Hn>, <Hm>, <Ha>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing, Symbol "<Ha>" "Ra" Nothing],
               Encoding "FNMADD_S_floatdp3" [("type", BlockEq [O, O])]
                 "FNMADD  <Sd>, <Sn>, <Sm>, <Sa>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing, Symbol "<Sa>" "Ra" Nothing],
               Encoding "FNMADD_D_floatdp3" [("type", BlockEq [O, I])]
                 "FNMADD  <Dd>, <Dn>, <Dm>, <Da>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing, Symbol "<Da>" "Ra" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/mul/add-sub" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);"])]
          [Ps "aarch64/instrs/float/arithmetic/mul/add-sub" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FNMSUB_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/mul/add-sub"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "type") (BlockEq [X, X]),
                  Block (Just "o1") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "o0") (BlockEq [I]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FNMSUB_H_floatdp3" [("type", BlockEq [I, I])]
                 "FNMSUB  <Hd>, <Hn>, <Hm>, <Ha>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing, Symbol "<Ha>" "Ra" Nothing],
               Encoding "FNMSUB_S_floatdp3" [("type", BlockEq [O, O])]
                 "FNMSUB  <Sd>, <Sn>, <Sm>, <Sa>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing, Symbol "<Sa>" "Ra" Nothing],
               Encoding "FNMSUB_D_floatdp3" [("type", BlockEq [O, I])]
                 "FNMSUB  <Dd>, <Dn>, <Dm>, <Da>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing, Symbol "<Da>" "Ra" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/mul/add-sub" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);"])]
          [Ps "aarch64/instrs/float/arithmetic/mul/add-sub" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FNMUL_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/mul/product"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FNMUL_H_floatdp2" [("type", BlockEq [I, I])]
                 "FNMUL  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing],
               Encoding "FNMUL_S_floatdp2" [("type", BlockEq [O, O])]
                 "FNMUL  <Sd>, <Sn>, <Sm>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing],
               Encoding "FNMUL_D_floatdp2" [("type", BlockEq [O, I])]
                 "FNMUL  <Dd>, <Dn>, <Dm>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/mul/product" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean negated = (op == '1');"])]
          [Ps "aarch64/instrs/float/arithmetic/mul/product" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nresult = FPMul(operand1, operand2, FPCR);\n\nif negated then result = FPNeg(result);\n\nV[d] = result;"]),
     Right
       (Page "FRECPE_advsimd" []
          [(Class "FRECPE_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size<1>") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRECPE_asisdmiscfp16_R" [] "FRECPE  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FRECPE_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/special/recip/float/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRECPE_asisdmisc_R" [] "FRECPE  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/special/recip/float/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FRECPE_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRECPE_asimdmiscfp16_R" [] "FRECPE  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"]),
           (Class "FRECPE_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/special/recip/float/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRECPE_asimdmisc_R" [] "FRECPE  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/special/recip/float/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecipEstimate(element, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FRECPS_advsimd" []
          [(Class "FRECPS_asisdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRECPS_asisdsamefp16_only" [] "FRECPS  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FRECPS_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/recps/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRECPS_asisdsame_only" []
                 "FRECPS  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/recps/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FRECPS_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRECPS_asimdsamefp16_only" []
                 "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"]),
           (Class "FRECPS_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/recps/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRECPS_asimdsame_only" []
                 "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/recps/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRecipStepFused(element1, element2);\n\nV[d] = result;"]),
     Right
       (Page "FRECPX_advsimd" []
          [(Class "FRECPX_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/special/frecpx-fp16"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRECPX_asisdmiscfp16_R" [] "FRECPX  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/special/frecpx-fp16"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FRECPX_asisdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/special/frecpx"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRECPX_asisdmisc_R" [] "FRECPX  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/special/frecpx"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/special/frecpx-fp16"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecpX(element, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FRINTA_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/round"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, I]),
                  Block (Just "rmode") (BlockEq [I, O, O]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTA_H_floatdp1" [("type", BlockEq [I, I])]
                 "FRINTA  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FRINTA_S_floatdp1" [("type", BlockEq [O, O])]
                 "FRINTA  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FRINTA_D_floatdp1" [("type", BlockEq [O, I])]
                 "FRINTA  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/round" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/float/arithmetic/round" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTA_advsimd" []
          [(Class "FRINTA_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/unary/fp16/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTA_asimdmiscfp16_R" [] "FRINTA  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"]),
           (Class "FRINTA_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTA_asimdmisc_R" [] "FRINTA  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/round"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTI_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/round"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, I]),
                  Block (Just "rmode") (BlockEq [I, I, I]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTI_H_floatdp1" [("type", BlockEq [I, I])]
                 "FRINTI  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FRINTI_S_floatdp1" [("type", BlockEq [O, O])]
                 "FRINTI  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FRINTI_D_floatdp1" [("type", BlockEq [O, I])]
                 "FRINTI  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/round" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/float/arithmetic/round" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTI_advsimd" []
          [(Class "FRINTI_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/unary/fp16/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTI_asimdmiscfp16_R" [] "FRINTI  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"]),
           (Class "FRINTI_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTI_asimdmisc_R" [] "FRINTI  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/round"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTM_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/round"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, I]),
                  Block (Just "rmode") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTM_H_floatdp1" [("type", BlockEq [I, I])]
                 "FRINTM  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FRINTM_S_floatdp1" [("type", BlockEq [O, O])]
                 "FRINTM  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FRINTM_D_floatdp1" [("type", BlockEq [O, I])]
                 "FRINTM  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/round" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/float/arithmetic/round" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTM_advsimd" []
          [(Class "FRINTM_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/unary/fp16/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTM_asimdmiscfp16_R" [] "FRINTM  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"]),
           (Class "FRINTM_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTM_asimdmisc_R" [] "FRINTM  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/round"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTN_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/round"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, I]),
                  Block (Just "rmode") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTN_H_floatdp1" [("type", BlockEq [I, I])]
                 "FRINTN  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FRINTN_S_floatdp1" [("type", BlockEq [O, O])]
                 "FRINTN  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FRINTN_D_floatdp1" [("type", BlockEq [O, I])]
                 "FRINTN  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/round" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/float/arithmetic/round" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTN_advsimd" []
          [(Class "FRINTN_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/unary/fp16/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTN_asimdmiscfp16_R" [] "FRINTN  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"]),
           (Class "FRINTN_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTN_asimdmisc_R" [] "FRINTN  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/round"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTP_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/round"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, I]),
                  Block (Just "rmode") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTP_H_floatdp1" [("type", BlockEq [I, I])]
                 "FRINTP  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FRINTP_S_floatdp1" [("type", BlockEq [O, O])]
                 "FRINTP  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FRINTP_D_floatdp1" [("type", BlockEq [O, I])]
                 "FRINTP  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/round" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/float/arithmetic/round" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTP_advsimd" []
          [(Class "FRINTP_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/unary/fp16/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTP_asimdmiscfp16_R" [] "FRINTP  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"]),
           (Class "FRINTP_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTP_asimdmisc_R" [] "FRINTP  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/round"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTX_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/round"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, I]),
                  Block (Just "rmode") (BlockEq [I, I, O]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTX_H_floatdp1" [("type", BlockEq [I, I])]
                 "FRINTX  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FRINTX_S_floatdp1" [("type", BlockEq [O, O])]
                 "FRINTX  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FRINTX_D_floatdp1" [("type", BlockEq [O, I])]
                 "FRINTX  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/round" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/float/arithmetic/round" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTX_advsimd" []
          [(Class "FRINTX_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/unary/fp16/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTX_asimdmiscfp16_R" [] "FRINTX  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"]),
           (Class "FRINTX_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTX_asimdmisc_R" [] "FRINTX  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/round"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTZ_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/round"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, I]),
                  Block (Just "rmode") (BlockEq [O, I, I]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTZ_H_floatdp1" [("type", BlockEq [I, I])]
                 "FRINTZ  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FRINTZ_S_floatdp1" [("type", BlockEq [O, O])]
                 "FRINTZ  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FRINTZ_D_floatdp1" [("type", BlockEq [O, I])]
                 "FRINTZ  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/round" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/float/arithmetic/round" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\nresult = FPRoundInt(operand, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRINTZ_advsimd" []
          [(Class "FRINTZ_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/unary/fp16/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTZ_asimdmiscfp16_R" [] "FRINTZ  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"]),
           (Class "FRINTZ_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/float/round"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "o2") (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I, I, O, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRINTZ_asimdmisc_R" [] "FRINTZ  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/round"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/round"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\n\nV[d] = result;"]),
     Right
       (Page "FRSQRTE_advsimd" []
          [(Class "FRSQRTE_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRSQRTE_asisdmiscfp16_R" [] "FRSQRTE  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FRSQRTE_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRSQRTE_asisdmisc_R" [] "FRSQRTE  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FRSQRTE_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRSQRTE_asimdmiscfp16_R" []
                 "FRSQRTE  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"]),
           (Class "FRSQRTE_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRSQRTE_asimdmisc_R" [] "FRSQRTE  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FRSQRTS_advsimd" []
          [(Class "FRSQRTS_asisdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRSQRTS_asisdsamefp16_only" []
                 "FRSQRTS  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FRSQRTS_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRSQRTS_asisdsame_only" []
                 "FRSQRTS  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;"]),
           (Class "FRSQRTS_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRSQRTS_asimdsamefp16_only" []
                 "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"]),
           (Class "FRSQRTS_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FRSQRTS_asimdsame_only" []
                 "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);\n\nV[d] = result;"]),
     Right
       (Page "FSQRT_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/unary"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O]),
                  Block (Just "opc") (BlockEq [I, I]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FSQRT_H_floatdp1" [("type", BlockEq [I, I])]
                 "FSQRT  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing],
               Encoding "FSQRT_S_floatdp1" [("type", BlockEq [O, O])]
                 "FSQRT  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing],
               Encoding "FSQRT_D_floatdp1" [("type", BlockEq [O, I])]
                 "FSQRT  <Dd>, <Dn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/unary" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;"])]
          [Ps "aarch64/instrs/float/arithmetic/unary" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize) result;\nbits(datasize) operand = V[n];\n\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FSQRT_advsimd" []
          [(Class "FSQRT_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/unary/special/sqrt-fp16"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FSQRT_asimdmiscfp16_R" [] "FSQRT  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/special/sqrt-fp16"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"]),
           (Class "FSQRT_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/special/sqrt"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FSQRT_asimdmisc_R" [] "FSQRT  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/special/sqrt"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/special/sqrt-fp16"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPSqrt(element, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FSUB_float" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/arithmetic/add-sub"
                 [Block (Just "M") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O, I]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FSUB_H_floatdp2" [("type", BlockEq [I, I])]
                 "FSUB  <Hd>, <Hn>, <Hm>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing,
                  Symbol "<Hm>" "Rm" Nothing],
               Encoding "FSUB_S_floatdp2" [("type", BlockEq [O, O])]
                 "FSUB  <Sd>, <Sn>, <Sm>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Sm>" "Rm" Nothing],
               Encoding "FSUB_D_floatdp2" [("type", BlockEq [O, I])]
                 "FSUB  <Dd>, <Dn>, <Dm>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Dn>" "Rn" Nothing,
                  Symbol "<Dm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/float/arithmetic/add-sub" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n\nboolean sub_op = (op == '1');"])]
          [Ps "aarch64/instrs/float/arithmetic/add-sub" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nif sub_op then\n    result = FPSub(operand1, operand2, FPCR);\nelse\n    result = FPAdd(operand1, operand2, FPCR);\n\nV[d] = result;"]),
     Right
       (Page "FSUB_advsimd" []
          [(Class "FSUB_asimdsamefp16_only" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FSUB_asimdsamefp16_only" []
                 "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean abs = (U == '1');"]),
           (Class "FSUB_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "FSUB_asimdsame_only" []
                 "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean abs = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) diff;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    diff = FPSub(element1, element2, FPCR);\n    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;\n\nV[d] = result;"]),
     Right
       (Page "INS_advsimd_elt" ["MOV_INS_advsimd_elt"]
          [(Class "INS_asimdins_IV_v" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/insert"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [I]),
                  Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O, O, O, O]),
                  Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "imm4") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "INS_asimdins_IV_v" []
                 "INS  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ts>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "B" [[X, X, X, X, I]] Nothing,
                           TableRow "H" [[X, X, X, I, O]] Nothing,
                           TableRow "S" [[X, X, I, O, O]] Nothing,
                           TableRow "D" [[X, I, O, O, O]] Nothing])),
                  Symbol "<index1>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "imm5<4:1>" [[X, X, X, X, I]] Nothing,
                           TableRow "imm5<4:2>" [[X, X, X, I, O]] Nothing,
                           TableRow "imm5<4:3>" [[X, X, I, O, O]] Nothing,
                           TableRow "imm5<4>" [[X, I, O, O, O]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<index2>" "imm5:imm4"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "imm4<3:0>" [[X, X, X, X, I]] Nothing,
                           TableRow "imm4<3:1>" [[X, X, X, I, O]] Nothing,
                           TableRow "imm4<3:2>" [[X, X, I, O, O]] Nothing,
                           TableRow "imm4<3>" [[X, I, O, O, O]] Nothing]))]],
            [Ps "aarch64/instrs/vector/transfer/vector/insert" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\n\ninteger dst_index = UInt(imm5<4:size+1>);\ninteger src_index = UInt(imm4<3:size>);\ninteger idxdsize = if imm4<3> == '1' then 128 else 64; \n// imm4<size-1:0> is IGNORED \n\ninteger esize = 8 << size;"])]
          [Ps "aarch64/instrs/vector/transfer/vector/insert" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nbits(128) result;\n\nresult = V[d];\nElem[result, dst_index, esize] = Elem[operand, src_index, esize];\nV[d] = result;"]),
     Right
       (Page "INS_advsimd_gen" ["MOV_INS_advsimd_gen"]
          [(Class "INS_asimdins_IR_r" Nothing
              (Diagram "aarch64/instrs/vector/transfer/integer/insert"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [I]),
                  Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O, O, O, O]),
                  Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "imm4") (BlockEq [O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "INS_asimdins_IR_r" [] "INS  <Vd>.<Ts>[<index>], <R><n>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ts>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "B" [[X, X, X, X, I]] Nothing,
                           TableRow "H" [[X, X, X, I, O]] Nothing,
                           TableRow "S" [[X, X, I, O, O]] Nothing,
                           TableRow "D" [[X, I, O, O, O]] Nothing])),
                  Symbol "<index>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "imm5<4:1>" [[X, X, X, X, I]] Nothing,
                           TableRow "imm5<4:2>" [[X, X, X, I, O]] Nothing,
                           TableRow "imm5<4:3>" [[X, X, I, O, O]] Nothing,
                           TableRow "imm5<4>" [[X, I, O, O, O]] Nothing])),
                  Symbol "<R>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "W" [[X, X, X, X, I]] Nothing,
                           TableRow "W" [[X, X, X, I, O]] Nothing,
                           TableRow "W" [[X, X, I, O, O]] Nothing,
                           TableRow "X" [[X, I, O, O, O]] Nothing])),
                  Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/integer/insert" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size = LowestSetBit(imm5);\n\nif size > 3 then UnallocatedEncoding();\ninteger index = UInt(imm5<4:size+1>);\n\ninteger esize = 8 << size;\ninteger datasize = 128;"])]
          [Ps "aarch64/instrs/vector/transfer/integer/insert"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(esize) element = X[n];\nbits(datasize) result;\n\nresult = V[d];\nElem[result, index, esize] = element;\nV[d] = result;"]),
     Right
       (Page "LD1_advsimd_mult" []
          [(Class "as_no_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, O]),
                  Block (Just "L") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [X, X, I, X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD1_asisdlse_R1_1v" [("opcode", BlockEq [O, I, I, I])]
                 "LD1  { <Vt>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD1_asisdlse_R2_2v" [("opcode", BlockEq [I, O, I, O])]
                 "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD1_asisdlse_R3_3v" [("opcode", BlockEq [O, I, I, O])]
                 "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD1_asisdlse_R4_4v" [("opcode", BlockEq [O, O, I, O])]
                 "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, I]),
                  Block (Just "L") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [X, X, I, X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD1_asisdlsep_I1_i1"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I, I])]
                 "LD1  { <Vt>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#8" [[O]] Nothing, TableRow "#16" [[I]] Nothing]))],
               Encoding "LD1_asisdlsep_R1_r1"
                 [("Rm", BlockNeq [I, I, I, I, I]),
                  ("opcode", BlockEq [O, I, I, I])]
                 "LD1  { <Vt>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD1_asisdlsep_I2_i2"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I, O])]
                 "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#16" [[O]] Nothing, TableRow "#32" [[I]] Nothing]))],
               Encoding "LD1_asisdlsep_R2_r2"
                 [("Rm", BlockNeq [I, I, I, I, I]),
                  ("opcode", BlockEq [I, O, I, O])]
                 "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD1_asisdlsep_I3_i3"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I, O])]
                 "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#24" [[O]] Nothing, TableRow "#48" [[I]] Nothing]))],
               Encoding "LD1_asisdlsep_R3_r3"
                 [("Rm", BlockNeq [I, I, I, I, I]),
                  ("opcode", BlockEq [O, I, I, O])]
                 "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD1_asisdlsep_I4_i4"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, O, I, O])]
                 "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#32" [[O]] Nothing, TableRow "#64" [[I]] Nothing]))],
               Encoding "LD1_asisdlsep_R4_r4"
                 [("Rm", BlockNeq [I, I, I, I, I]),
                  ("opcode", BlockEq [O, O, I, O])]
                 "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/post-inc"
               (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/multiple/no-wb"
             (Just PsPostDecode)
             "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UnallocatedEncoding();\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then ReservedValue();",
           Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD1_advsimd_sngl" []
          [(Class "as_no_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [X, X, O]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD1_asisdlso_B1_1b" [("opcode", BlockEq [O, O, O])]
                 "LD1  { <Vt>.B }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD1_asisdlso_H1_1h"
                 [("opcode", BlockEq [O, I, O]), ("size", BlockEq [X, O])]
                 "LD1  { <Vt>.H }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD1_asisdlso_S1_1s"
                 [("opcode", BlockEq [I, O, O]), ("size", BlockEq [O, O])]
                 "LD1  { <Vt>.S }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD1_asisdlso_D1_1d"
                 [("opcode", BlockEq [I, O, O]), ("S", BlockEq [O]),
                  ("size", BlockEq [O, I])]
                 "LD1  { <Vt>.D }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [X, X, O]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD1_asisdlsop_B1_i1b"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, O, O])]
                 "LD1  { <Vt>.B }[<index>], [<Xn|SP>], #1"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD1_asisdlsop_BX1_r1b"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, O, O])]
                 "LD1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD1_asisdlsop_H1_i1h"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, O]),
                  ("size", BlockEq [X, O])]
                 "LD1  { <Vt>.H }[<index>], [<Xn|SP>], #2"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD1_asisdlsop_HX1_r1h"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, I, O]),
                  ("size", BlockEq [X, O])]
                 "LD1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD1_asisdlsop_S1_i1s"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("size", BlockEq [O, O])]
                 "LD1  { <Vt>.S }[<index>], [<Xn|SP>], #4"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD1_asisdlsop_SX1_r1s"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("size", BlockEq [O, O])]
                 "LD1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD1_asisdlsop_D1_i1d"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "LD1  { <Vt>.D }[<index>], [<Xn|SP>], #8"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD1_asisdlsop_DX1_r1d"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "LD1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD1R_advsimd" []
          [(Class "LD1R_asisdlso_R1" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, O]),
                  Block (Just "S") (BlockEq [O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD1R_asisdlso_R1" [] "LD1R  { <Vt>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O]),
                  Block (Just "S") (BlockEq [O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD1R_asisdlsop_R1_i" [("Rm", BlockEq [I, I, I, I, I])]
                 "LD1R  { <Vt>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "#1" [[O, O]] Nothing, TableRow "#2" [[O, I]] Nothing,
                           TableRow "#4" [[I, O]] Nothing, TableRow "#8" [[I, I]] Nothing]))],
               Encoding "LD1R_asisdlsop_RX1_r" [("Rm", BlockNeq [I, I, I, I, I])]
                 "LD1R  { <Vt>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD2_advsimd_mult" []
          [(Class "LD2_asisdlse_R2" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, O]),
                  Block (Just "L") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD2_asisdlse_R2" []
                 "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, I]),
                  Block (Just "L") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD2_asisdlsep_I2_i" [("Rm", BlockEq [I, I, I, I, I])]
                 "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#16" [[O]] Nothing, TableRow "#32" [[I]] Nothing]))],
               Encoding "LD2_asisdlsep_R2_r" [("Rm", BlockNeq [I, I, I, I, I])]
                 "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/post-inc"
               (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/multiple/no-wb"
             (Just PsPostDecode)
             "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UnallocatedEncoding();\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then ReservedValue();",
           Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD2_advsimd_sngl" []
          [(Class "as_no_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [X, X, O]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD2_asisdlso_B2_2b" [("opcode", BlockEq [O, O, O])]
                 "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD2_asisdlso_H2_2h"
                 [("opcode", BlockEq [O, I, O]), ("size", BlockEq [X, O])]
                 "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD2_asisdlso_S2_2s"
                 [("opcode", BlockEq [I, O, O]), ("size", BlockEq [O, O])]
                 "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD2_asisdlso_D2_2d"
                 [("opcode", BlockEq [I, O, O]), ("S", BlockEq [O]),
                  ("size", BlockEq [O, I])]
                 "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [X, X, O]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD2_asisdlsop_B2_i2b"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, O, O])]
                 "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD2_asisdlsop_BX2_r2b"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, O, O])]
                 "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD2_asisdlsop_H2_i2h"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, O]),
                  ("size", BlockEq [X, O])]
                 "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD2_asisdlsop_HX2_r2h"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, I, O]),
                  ("size", BlockEq [X, O])]
                 "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD2_asisdlsop_S2_i2s"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("size", BlockEq [O, O])]
                 "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD2_asisdlsop_SX2_r2s"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("size", BlockEq [O, O])]
                 "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD2_asisdlsop_D2_i2d"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD2_asisdlsop_DX2_r2d"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD2R_advsimd" []
          [(Class "LD2R_asisdlso_R2" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, O]),
                  Block (Just "S") (BlockEq [O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD2R_asisdlso_R2" []
                 "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O]),
                  Block (Just "S") (BlockEq [O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD2R_asisdlsop_R2_i" [("Rm", BlockEq [I, I, I, I, I])]
                 "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "#2" [[O, O]] Nothing, TableRow "#4" [[O, I]] Nothing,
                           TableRow "#8" [[I, O]] Nothing,
                           TableRow "#16" [[I, I]] Nothing]))],
               Encoding "LD2R_asisdlsop_RX2_r" [("Rm", BlockNeq [I, I, I, I, I])]
                 "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD3_advsimd_mult" []
          [(Class "LD3_asisdlse_R3" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, O]),
                  Block (Just "L") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD3_asisdlse_R3" []
                 "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, I]),
                  Block (Just "L") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, I, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD3_asisdlsep_I3_i" [("Rm", BlockEq [I, I, I, I, I])]
                 "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#24" [[O]] Nothing, TableRow "#48" [[I]] Nothing]))],
               Encoding "LD3_asisdlsep_R3_r" [("Rm", BlockNeq [I, I, I, I, I])]
                 "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/post-inc"
               (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/multiple/no-wb"
             (Just PsPostDecode)
             "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UnallocatedEncoding();\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then ReservedValue();",
           Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD3_advsimd_sngl" []
          [(Class "as_no_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [X, X, I]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD3_asisdlso_B3_3b" [("opcode", BlockEq [O, O, I])]
                 "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD3_asisdlso_H3_3h"
                 [("opcode", BlockEq [O, I, I]), ("size", BlockEq [X, O])]
                 "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD3_asisdlso_S3_3s"
                 [("opcode", BlockEq [I, O, I]), ("size", BlockEq [O, O])]
                 "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD3_asisdlso_D3_3d"
                 [("opcode", BlockEq [I, O, I]), ("S", BlockEq [O]),
                  ("size", BlockEq [O, I])]
                 "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [X, X, I]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD3_asisdlsop_B3_i3b"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, O, I])]
                 "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD3_asisdlsop_BX3_r3b"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, O, I])]
                 "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD3_asisdlsop_H3_i3h"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I]),
                  ("size", BlockEq [X, O])]
                 "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD3_asisdlsop_HX3_r3h"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I]),
                  ("size", BlockEq [X, O])]
                 "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD3_asisdlsop_S3_i3s"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("size", BlockEq [O, O])]
                 "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD3_asisdlsop_SX3_r3s"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("size", BlockEq [O, O])]
                 "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD3_asisdlsop_D3_i3d"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD3_asisdlsop_DX3_r3d"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD3R_advsimd" []
          [(Class "LD3R_asisdlso_R3" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I]),
                  Block (Just "S") (BlockEq [O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD3R_asisdlso_R3" []
                 "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I]),
                  Block (Just "S") (BlockEq [O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD3R_asisdlsop_R3_i" [("Rm", BlockEq [I, I, I, I, I])]
                 "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "#3" [[O, O]] Nothing, TableRow "#6" [[O, I]] Nothing,
                           TableRow "#12" [[I, O]] Nothing,
                           TableRow "#24" [[I, I]] Nothing]))],
               Encoding "LD3R_asisdlsop_RX3_r" [("Rm", BlockNeq [I, I, I, I, I])]
                 "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD4_advsimd_mult" []
          [(Class "LD4_asisdlse_R4" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, O]),
                  Block (Just "L") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD4_asisdlse_R4" []
                 "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, I]),
                  Block (Just "L") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD4_asisdlsep_I4_i" [("Rm", BlockEq [I, I, I, I, I])]
                 "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#32" [[O]] Nothing, TableRow "#64" [[I]] Nothing]))],
               Encoding "LD4_asisdlsep_R4_r" [("Rm", BlockNeq [I, I, I, I, I])]
                 "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/post-inc"
               (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/multiple/no-wb"
             (Just PsPostDecode)
             "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UnallocatedEncoding();\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then ReservedValue();",
           Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD4_advsimd_sngl" []
          [(Class "as_no_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [X, X, I]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD4_asisdlso_B4_4b" [("opcode", BlockEq [O, O, I])]
                 "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD4_asisdlso_H4_4h"
                 [("opcode", BlockEq [O, I, I]), ("size", BlockEq [X, O])]
                 "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD4_asisdlso_S4_4s"
                 [("opcode", BlockEq [I, O, I]), ("size", BlockEq [O, O])]
                 "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD4_asisdlso_D4_4d"
                 [("opcode", BlockEq [I, O, I]), ("S", BlockEq [O]),
                  ("size", BlockEq [O, I])]
                 "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [X, X, I]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD4_asisdlsop_B4_i4b"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, O, I])]
                 "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD4_asisdlsop_BX4_r4b"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, O, I])]
                 "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD4_asisdlsop_H4_i4h"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I]),
                  ("size", BlockEq [X, O])]
                 "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD4_asisdlsop_HX4_r4h"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I]),
                  ("size", BlockEq [X, O])]
                 "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD4_asisdlsop_S4_i4s"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("size", BlockEq [O, O])]
                 "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD4_asisdlsop_SX4_r4s"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("size", BlockEq [O, O])]
                 "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "LD4_asisdlsop_D4_i4d"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "LD4_asisdlsop_DX4_r4d"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LD4R_advsimd" []
          [(Class "LD4R_asisdlso_R4" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I]),
                  Block (Just "S") (BlockEq [O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD4R_asisdlso_R4" []
                 "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [I]), Block (Just "R") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I]),
                  Block (Just "S") (BlockEq [O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LD4R_asisdlsop_R4_i" [("Rm", BlockEq [I, I, I, I, I])]
                 "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "#4" [[O, O]] Nothing, TableRow "#8" [[O, I]] Nothing,
                           TableRow "#16" [[I, O]] Nothing,
                           TableRow "#32" [[I, I]] Nothing]))],
               Encoding "LD4R_asisdlsop_RX4_r" [("Rm", BlockNeq [I, I, I, I, I])]
                 "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "LDNP_fpsimd" []
          [(Class "signed_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/pair/simdfp/no-alloc"
                 [Block (Just "opc") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDNP_S_ldstnapair_offs" [("opc", BlockEq [O, O])]
                 "LDNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<St1>" "Rt" Nothing, Symbol "<St2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDNP_D_ldstnapair_offs" [("opc", BlockEq [O, I])]
                 "LDNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Dt1>" "Rt" Nothing, Symbol "<Dt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDNP_Q_ldstnapair_offs" [("opc", BlockEq [I, O])]
                 "LDNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Qt1>" "Rt" Nothing, Symbol "<Qt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/simdfp/no-alloc" (Just PsDecode)
               "boolean wback  = FALSE;\nboolean postindex = FALSE;"])]
          [Ps "aarch64/instrs/memory/pair/simdfp/no-alloc"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VECSTREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);",
           Ps "aarch64/instrs/memory/pair/simdfp/no-alloc" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        V[t]  = data1;\n        V[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDP_fpsimd" []
          [(Class "post_indexed" Nothing
              (Diagram "aarch64/instrs/memory/pair/simdfp/post-idx"
                 [Block (Just "opc") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDP_S_ldstpair_post" [("opc", BlockEq [O, O])]
                 "LDP  <St1>, <St2>, [<Xn|SP>], #<imm>"
                 [Symbol "<St1>" "Rt" Nothing, Symbol "<St2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDP_D_ldstpair_post" [("opc", BlockEq [O, I])]
                 "LDP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>"
                 [Symbol "<Dt1>" "Rt" Nothing, Symbol "<Dt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDP_Q_ldstpair_post" [("opc", BlockEq [I, O])]
                 "LDP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>"
                 [Symbol "<Qt1>" "Rt" Nothing, Symbol "<Qt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/simdfp/post-idx" (Just PsDecode)
               "boolean wback  = TRUE;\nboolean postindex = TRUE;"]),
           (Class "pre_indexed" Nothing
              (Diagram "aarch64/instrs/memory/pair/simdfp/pre-idx"
                 [Block (Just "opc") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDP_S_ldstpair_pre" [("opc", BlockEq [O, O])]
                 "LDP  <St1>, <St2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<St1>" "Rt" Nothing, Symbol "<St2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDP_D_ldstpair_pre" [("opc", BlockEq [O, I])]
                 "LDP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<Dt1>" "Rt" Nothing, Symbol "<Dt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDP_Q_ldstpair_pre" [("opc", BlockEq [I, O])]
                 "LDP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<Qt1>" "Rt" Nothing, Symbol "<Qt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/simdfp/pre-idx" (Just PsDecode)
               "boolean wback  = TRUE;\nboolean postindex = FALSE;"]),
           (Class "signed_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/pair/simdfp/offset"
                 [Block (Just "opc") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "L") (BlockEq [I]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDP_S_ldstpair_off" [("opc", BlockEq [O, O])]
                 "LDP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<St1>" "Rt" Nothing, Symbol "<St2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDP_D_ldstpair_off" [("opc", BlockEq [O, I])]
                 "LDP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Dt1>" "Rt" Nothing, Symbol "<Dt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "LDP_Q_ldstpair_off" [("opc", BlockEq [I, O])]
                 "LDP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Qt1>" "Rt" Nothing, Symbol "<Qt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/simdfp/offset" (Just PsDecode)
               "boolean wback  = FALSE;\nboolean postindex = FALSE;"])]
          [Ps "aarch64/instrs/memory/pair/simdfp/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VEC;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);",
           Ps "aarch64/instrs/memory/pair/simdfp/post-idx" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        V[t]  = data1;\n        V[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDR_imm_fpsimd" []
          [(Class "post_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [X, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDR_B_ldst_immpost"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, I])]
                 "LDR  <Bt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDR_H_ldst_immpost"
                 [("size", BlockEq [O, I]), ("opc", BlockEq [O, I])]
                 "LDR  <Ht>, [<Xn|SP>], #<simm>"
                 [Symbol "<Ht>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDR_S_ldst_immpost"
                 [("size", BlockEq [I, O]), ("opc", BlockEq [O, I])]
                 "LDR  <St>, [<Xn|SP>], #<simm>"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDR_D_ldst_immpost"
                 [("size", BlockEq [I, I]), ("opc", BlockEq [O, I])]
                 "LDR  <Dt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDR_Q_ldst_immpost"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [I, I])]
                 "LDR  <Qt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "pre_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/simdfp/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [X, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDR_B_ldst_immpre"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, I])]
                 "LDR  <Bt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDR_H_ldst_immpre"
                 [("size", BlockEq [O, I]), ("opc", BlockEq [O, I])]
                 "LDR  <Ht>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Ht>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDR_S_ldst_immpre"
                 [("size", BlockEq [I, O]), ("opc", BlockEq [O, I])]
                 "LDR  <St>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDR_D_ldst_immpre"
                 [("size", BlockEq [I, I]), ("opc", BlockEq [O, I])]
                 "LDR  <Dt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDR_Q_ldst_immpre"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [I, I])]
                 "LDR  <Qt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/simdfp/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "unsigned_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/single/simdfp/immediate/unsigned"
                 [Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [X, I]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDR_B_ldst_pos"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, I])]
                 "LDR  <Bt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "LDR_H_ldst_pos"
                 [("size", BlockEq [O, I]), ("opc", BlockEq [O, I])]
                 "LDR  <Ht>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Ht>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "LDR_S_ldst_pos"
                 [("size", BlockEq [I, O]), ("opc", BlockEq [O, I])]
                 "LDR  <St>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "LDR_D_ldst_pos"
                 [("size", BlockEq [I, I]), ("opc", BlockEq [O, I])]
                 "LDR  <Dt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "LDR_Q_ldst_pos"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [I, I])]
                 "LDR  <Qt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/simdfp/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps "aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDR_lit_fpsimd" []
          [(Class "literal" Nothing
              (Diagram "aarch64/instrs/memory/literal/simdfp"
                 [Block (Just "opc") (BlockEq [X, X]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "imm19")
                    (BlockEq
                       [X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDR_S_loadlit" [("opc", BlockEq [O, O])]
                 "LDR  <St>, <label>"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<label>" "imm19" Nothing],
               Encoding "LDR_D_loadlit" [("opc", BlockEq [O, I])]
                 "LDR  <Dt>, <label>"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<label>" "imm19" Nothing],
               Encoding "LDR_Q_loadlit" [("opc", BlockEq [I, O])]
                 "LDR  <Qt>, <label>"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<label>" "imm19" Nothing]],
            [Ps "aarch64/instrs/memory/literal/simdfp" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger size;\nbits(64) offset;\n\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 16;\n    when '11'\n        UnallocatedEncoding();\n\noffset = SignExtend(imm19:'00', 64);"])]
          [Ps "aarch64/instrs/memory/literal/simdfp" (Just PsExecute)
             "bits(64) address = PC[] + offset;\nbits(size*8) data;\n\nCheckFPAdvSIMDEnabled64();\n\ndata = Mem[address, size, AccType_VEC];\nV[t] = data;"]),
     Right
       (Page "LDR_reg_fpsimd" []
          [(Class "fpsimd" Nothing
              (Diagram "aarch64/instrs/memory/single/simdfp/register"
                 [Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [X, I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDR_B_ldst_regoff"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, I]),
                  ("option", BlockNeq [O, I, I])]
                 "LDR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S" Nothing],
               Encoding "LDR_BL_ldst_regoff"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, I]),
                  ("option", BlockEq [O, I, I])]
                 "LDR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<amount>" "S" Nothing],
               Encoding "LDR_H_ldst_regoff"
                 [("size", BlockEq [O, I]), ("opc", BlockEq [O, I])]
                 "LDR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Ht>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#1" [[I]] Nothing]))],
               Encoding "LDR_S_ldst_regoff"
                 [("size", BlockEq [I, O]), ("opc", BlockEq [O, I])]
                 "LDR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#2" [[I]] Nothing]))],
               Encoding "LDR_D_ldst_regoff"
                 [("size", BlockEq [I, I]), ("opc", BlockEq [O, I])]
                 "LDR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#3" [[I]] Nothing]))],
               Encoding "LDR_Q_ldst_regoff"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [I, I])]
                 "LDR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#4" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/memory/single/simdfp/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/simdfp/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/simdfp/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nCheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "LDUR_fpsimd" []
          [(Class "base_plus_offset" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [X, I]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "LDUR_B_ldst_unscaled"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, I])]
                 "LDUR  <Bt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDUR_H_ldst_unscaled"
                 [("size", BlockEq [O, I]), ("opc", BlockEq [O, I])]
                 "LDUR  <Ht>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Ht>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDUR_S_ldst_unscaled"
                 [("size", BlockEq [I, O]), ("opc", BlockEq [O, I])]
                 "LDUR  <St>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDUR_D_ldst_unscaled"
                 [("size", BlockEq [I, I]), ("opc", BlockEq [O, I])]
                 "LDUR  <Dt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "LDUR_Q_ldst_unscaled"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [I, I])]
                 "LDUR  <Qt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "MLA_advsimd_elt" []
          [(Class "MLA_asimdelem_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/int"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MLA_asimdelem_R" []
                 "MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/int"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o2 == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/int"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\n\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\nV[d] = result;"]),
     Right
       (Page "MLA_advsimd_vec" []
          [(Class "MLA_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/accum"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MLA_asimdsame_only" []
                 "MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/accum"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/accum"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n\nV[d] = result;"]),
     Right
       (Page "MLS_advsimd_elt" []
          [(Class "MLS_asimdelem_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/int"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MLS_asimdelem_R" []
                 "MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/int"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o2 == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/int"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\n\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\nV[d] = result;"]),
     Right
       (Page "MLS_advsimd_vec" []
          [(Class "MLS_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/accum"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MLS_asimdsame_only" []
                 "MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/accum"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/accum"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n\nV[d] = result;"]),
     Left
       (AliasPage "MOV_INS_advsimd_elt" "INS_advsimd_elt"
          (Class "INS_asimdins_IV_v" Nothing
             (Diagram "aarch64/instrs/vector/transfer/vector/insert"
                [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [I]),
                 Block (Just "op") (BlockEq [I]),
                 Block Nothing (BlockEq [O, I, I, I, O, O, O, O]),
                 Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                 Block Nothing (BlockEq [O]),
                 Block (Just "imm4") (BlockEq [X, X, X, X]),
                 Block Nothing (BlockEq [I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MOV_INS_asimdins_IV_v" []
                "MOV  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"
                [Symbol "<Vd>" "Rd" Nothing,
                 Symbol "<Ts>" "imm5"
                   (Just
                      (Table ["imm5"]
                         [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                          TableRow "B" [[X, X, X, X, I]] Nothing,
                          TableRow "H" [[X, X, X, I, O]] Nothing,
                          TableRow "S" [[X, X, I, O, O]] Nothing,
                          TableRow "D" [[X, I, O, O, O]] Nothing])),
                 Symbol "<index1>" "imm5"
                   (Just
                      (Table ["imm5"]
                         [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                          TableRow "imm5<4:1>" [[X, X, X, X, I]] Nothing,
                          TableRow "imm5<4:2>" [[X, X, X, I, O]] Nothing,
                          TableRow "imm5<4:3>" [[X, X, I, O, O]] Nothing,
                          TableRow "imm5<4>" [[X, I, O, O, O]] Nothing])),
                 Symbol "<Vn>" "Rn" Nothing,
                 Symbol "<index2>" "imm5:imm4"
                   (Just
                      (Table ["imm5"]
                         [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                          TableRow "imm4<3:0>" [[X, X, X, X, I]] Nothing,
                          TableRow "imm4<3:1>" [[X, X, X, I, O]] Nothing,
                          TableRow "imm4<3:2>" [[X, X, I, O, O]] Nothing,
                          TableRow "imm4<3>" [[X, I, O, O, O]] Nothing]))]])),
     Left
       (AliasPage "MOV_INS_advsimd_gen" "INS_advsimd_gen"
          (Class "INS_asimdins_IR_r" Nothing
             (Diagram "aarch64/instrs/vector/transfer/integer/insert"
                [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [I]),
                 Block (Just "op") (BlockEq [O]),
                 Block Nothing (BlockEq [O, I, I, I, O, O, O, O]),
                 Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                 Block Nothing (BlockEq [O]),
                 Block (Just "imm4") (BlockEq [O, O, I, I]),
                 Block Nothing (BlockEq [I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MOV_INS_asimdins_IR_r" []
                "MOV  <Vd>.<Ts>[<index>], <R><n>"
                [Symbol "<Vd>" "Rd" Nothing,
                 Symbol "<Ts>" "imm5"
                   (Just
                      (Table ["imm5"]
                         [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                          TableRow "B" [[X, X, X, X, I]] Nothing,
                          TableRow "H" [[X, X, X, I, O]] Nothing,
                          TableRow "S" [[X, X, I, O, O]] Nothing,
                          TableRow "D" [[X, I, O, O, O]] Nothing])),
                 Symbol "<index>" "imm5"
                   (Just
                      (Table ["imm5"]
                         [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                          TableRow "imm5<4:1>" [[X, X, X, X, I]] Nothing,
                          TableRow "imm5<4:2>" [[X, X, X, I, O]] Nothing,
                          TableRow "imm5<4:3>" [[X, X, I, O, O]] Nothing,
                          TableRow "imm5<4>" [[X, I, O, O, O]] Nothing])),
                 Symbol "<R>" "imm5"
                   (Just
                      (Table ["imm5"]
                         [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                          TableRow "W" [[X, X, X, X, I]] Nothing,
                          TableRow "W" [[X, X, X, I, O]] Nothing,
                          TableRow "W" [[X, X, I, O, O]] Nothing,
                          TableRow "X" [[X, I, O, O, O]] Nothing])),
                 Symbol "<n>" "Rn" Nothing]])),
     Left
       (AliasPage "MOV_DUP_advsimd_elt" "DUP_advsimd_elt"
          (Class "DUP_asisdone_only" Nothing
             (Diagram "aarch64/instrs/vector/transfer/vector/cpy-dup/sisd"
                [Block Nothing (BlockEq [O, I]), Block (Just "op") (BlockEq [O]),
                 Block Nothing (BlockEq [I, I, I, I, O, O, O, O]),
                 Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                 Block Nothing (BlockEq [O]),
                 Block (Just "imm4") (BlockEq [O, O, O, O]),
                 Block Nothing (BlockEq [I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MOV_DUP_asisdone_only" []
                "MOV  <V><d>, <Vn>.<T>[<index>]"
                [Symbol "<V>" "imm5"
                   (Just
                      (Table ["imm5"]
                         [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                          TableRow "B" [[X, X, X, X, I]] Nothing,
                          TableRow "H" [[X, X, X, I, O]] Nothing,
                          TableRow "S" [[X, X, I, O, O]] Nothing,
                          TableRow "D" [[X, I, O, O, O]] Nothing])),
                 Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                 Symbol "<T>" "imm5"
                   (Just
                      (Table ["imm5"]
                         [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                          TableRow "B" [[X, X, X, X, I]] Nothing,
                          TableRow "H" [[X, X, X, I, O]] Nothing,
                          TableRow "S" [[X, X, I, O, O]] Nothing,
                          TableRow "D" [[X, I, O, O, O]] Nothing])),
                 Symbol "<index>" "imm5"
                   (Just
                      (Table ["imm5"]
                         [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                          TableRow "imm5<4:1>" [[X, X, X, X, I]] Nothing,
                          TableRow "imm5<4:2>" [[X, X, X, I, O]] Nothing,
                          TableRow "imm5<4:3>" [[X, X, I, O, O]] Nothing,
                          TableRow "imm5<4>" [[X, I, O, O, O]] Nothing]))]])),
     Left
       (AliasPage "MOV_UMOV_advsimd" "UMOV_advsimd"
          (Class "advsimd" Nothing
             (Diagram "aarch64/instrs/vector/transfer/integer/move/unsigned"
                [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                 Block (Just "op") (BlockEq [O]),
                 Block Nothing (BlockEq [O, I, I, I, O, O, O, O]),
                 Block (Just "imm5") (BlockEq [X, X, X, O, O]),
                 Block Nothing (BlockEq [O]),
                 Block (Just "imm4<3:2>") (BlockEq [O, I]),
                 Block (Just "imm4<1>") (BlockEq [I]),
                 Block (Just "imm4<0>") (BlockEq [I]), Block Nothing (BlockEq [I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MOV_UMOV_asimdins_W_w"
                [("Q", BlockEq [O]), ("imm5", BlockEq [X, X, I, O, O])]
                "MOV  <Wd>, <Vn>.S[<index>]"
                [Symbol "<Wd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                 Symbol "<index>" "imm5" Nothing],
              Encoding "MOV_UMOV_asimdins_X_x"
                [("Q", BlockEq [I]), ("imm5", BlockEq [X, I, O, O, O])]
                "MOV  <Xd>, <Vn>.D[<index>]"
                [Symbol "<Xd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                 Symbol "<index>" "imm5" Nothing]])),
     Left
       (AliasPage "MOV_ORR_advsimd_reg" "ORR_advsimd_reg"
          (Class "ORR_asimdsame_only" Nothing
             (Diagram
                "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
                [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                 Block (Just "U") (BlockEq [O]),
                 Block Nothing (BlockEq [O, I, I, I, O]),
                 Block (Just "size") (BlockEq [I, O]), Block Nothing (BlockEq [I]),
                 Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                 Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                 Block Nothing (BlockEq [I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MOV_ORR_asimdsame_only" [] "MOV  <Vd>.<T>, <Vn>.<T>"
                [Symbol "<Vd>" "Rd" Nothing,
                 Symbol "<T>" "Q"
                   (Just
                      (Table ["Q"]
                         [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                 Symbol "<Vn>" "Rn" Nothing]])),
     Right
       (Page "MOVI_advsimd" []
          [(Class "advsimd" Nothing
              (Diagram "aarch64/instrs/vector/logical"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "op") (BlockEq [X]),
                  Block Nothing (BlockEq [O, I, I, I, I, O, O, O, O, O]),
                  Block (Just "a") (BlockEq [X]), Block (Just "b") (BlockEq [X]),
                  Block (Just "c") (BlockEq [X]),
                  Block (Just "cmode") (BlockEq [X, X, X, X]),
                  Block (Just "o2") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "d") (BlockEq [X]), Block (Just "e") (BlockEq [X]),
                  Block (Just "f") (BlockEq [X]), Block (Just "g") (BlockEq [X]),
                  Block (Just "h") (BlockEq [X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MOVI_asimdimm_N_b"
                 [("op", BlockEq [O]), ("cmode", BlockEq [I, I, I, O])]
                 "MOVI  <Vd>.<T>, #<imm8>{, LSL #0}"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing],
               Encoding "MOVI_asimdimm_L_hl"
                 [("op", BlockEq [O]), ("cmode", BlockEq [I, O, X, O])]
                 "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing,
                  Symbol "<amount>" "cmode<1>"
                    (Just
                       (Table ["cmode<1>"]
                          [TableRow "0" [[O]] Nothing, TableRow "8" [[I]] Nothing]))],
               Encoding "MOVI_asimdimm_L_sl"
                 [("op", BlockEq [O]), ("cmode", BlockEq [O, X, X, O])]
                 "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing,
                  Symbol "<amount>" "cmode<2:1>"
                    (Just
                       (Table ["cmode<2:1>"]
                          [TableRow "0" [[O, O]] Nothing, TableRow "8" [[O, I]] Nothing,
                           TableRow "16" [[I, O]] Nothing, TableRow "24" [[I, I]] Nothing]))],
               Encoding "MOVI_asimdimm_M_sm"
                 [("op", BlockEq [O]), ("cmode", BlockEq [I, I, O, X])]
                 "MOVI  <Vd>.<T>, #<imm8>, MSL #<amount>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing,
                  Symbol "<amount>" "cmode<0>"
                    (Just
                       (Table ["cmode<0>"]
                          [TableRow "8" [[O]] Nothing, TableRow "16" [[I]] Nothing]))],
               Encoding "MOVI_asimdimm_D_ds"
                 [("Q", BlockEq [O]), ("op", BlockEq [I]),
                  ("cmode", BlockEq [I, I, I, O])]
                 "MOVI  <Dd>, #<imm>"
                 [Symbol "<Dd>" "Rd" Nothing,
                  Symbol "<imm>" "a:b:c:d:e:f:g:h" Nothing],
               Encoding "MOVI_asimdimm_D2_d"
                 [("Q", BlockEq [I]), ("op", BlockEq [I]),
                  ("cmode", BlockEq [I, I, I, O])]
                 "MOVI  <Vd>.2D, #<imm>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<imm>" "a:b:c:d:e:f:g:h" Nothing]],
            [Ps "aarch64/instrs/vector/logical" (Just PsDecode)
               "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);"])]
          [Ps "aarch64/instrs/vector/logical" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"]),
     Right
       (Page "MUL_advsimd_elt" []
          [(Class "MUL_asimdelem_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/element/mul/int"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MUL_asimdelem_R" []
                 "MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/int"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/int"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\n\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    Elem[result, e, esize] = product;\n\nV[d] = result;"]),
     Right
       (Page "MUL_advsimd_vec" []
          [(Class "MUL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/product"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MUL_asimdsame_only" []
                 "MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/product"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif U == '1' && size != '00' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean poly = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/product"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if poly then\n        product = PolynomialMult(element1, element2)<esize-1:0>;\n    else\n        product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    Elem[result, e, esize] = product;\n\nV[d] = result;"]),
     Left
       (AliasPage "MVN_NOT_advsimd" "NOT_advsimd"
          (Class "NOT_asimdmisc_R" Nothing
             (Diagram "aarch64/instrs/vector/arithmetic/unary/not"
                [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                 Block (Just "U") (BlockEq [I]),
                 Block Nothing (BlockEq [O, I, I, I, O]),
                 Block (Just "size") (BlockEq [O, O]),
                 Block Nothing (BlockEq [I, O, O, O, O]),
                 Block (Just "opcode") (BlockEq [O, O, I, O, I]),
                 Block Nothing (BlockEq [I, O]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "MVN_NOT_asimdmisc_R" [] "MVN  <Vd>.<T>, <Vn>.<T>"
                [Symbol "<Vd>" "Rd" Nothing,
                 Symbol "<T>" "Q"
                   (Just
                      (Table ["Q"]
                         [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                 Symbol "<Vn>" "Rn" Nothing]])),
     Right
       (Page "MVNI_advsimd" []
          [(Class "advsimd" Nothing
              (Diagram "aarch64/instrs/vector/logical"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O, O, O, O, O]),
                  Block (Just "a") (BlockEq [X]), Block (Just "b") (BlockEq [X]),
                  Block (Just "c") (BlockEq [X]),
                  Block (Just "cmode") (BlockEq [X, X, X, X]),
                  Block (Just "o2") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "d") (BlockEq [X]), Block (Just "e") (BlockEq [X]),
                  Block (Just "f") (BlockEq [X]), Block (Just "g") (BlockEq [X]),
                  Block (Just "h") (BlockEq [X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "MVNI_asimdimm_L_hl" [("cmode", BlockEq [I, O, X, O])]
                 "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing,
                  Symbol "<amount>" "cmode<1>"
                    (Just
                       (Table ["cmode<1>"]
                          [TableRow "0" [[O]] Nothing, TableRow "8" [[I]] Nothing]))],
               Encoding "MVNI_asimdimm_L_sl" [("cmode", BlockEq [O, X, X, O])]
                 "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing,
                  Symbol "<amount>" "cmode<2:1>"
                    (Just
                       (Table ["cmode<2:1>"]
                          [TableRow "0" [[O, O]] Nothing, TableRow "8" [[O, I]] Nothing,
                           TableRow "16" [[I, O]] Nothing, TableRow "24" [[I, I]] Nothing]))],
               Encoding "MVNI_asimdimm_M_sm" [("cmode", BlockEq [I, I, O, X])]
                 "MVNI  <Vd>.<T>, #<imm8>, MSL #<amount>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing,
                  Symbol "<amount>" "cmode<0>"
                    (Just
                       (Table ["cmode<0>"]
                          [TableRow "8" [[O]] Nothing, TableRow "16" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/logical" (Just PsDecode)
               "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);"])]
          [Ps "aarch64/instrs/vector/logical" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"]),
     Right
       (Page "NEG_advsimd" []
          [(Class "NEG_asisdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "NEG_asisdmisc_R" [] "NEG  <V><d>, <V><n>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/int/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');"]),
           (Class "NEG_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "NEG_asimdmisc_R" [] "NEG  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/int/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/int/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    Elem[result, e, esize] = element<esize-1:0>;                \n\nV[d] = result;"]),
     Right
       (Page "NOT_advsimd" ["MVN_NOT_advsimd"]
          [(Class "NOT_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/not"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "NOT_asimdmisc_R" [] "NOT  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/not" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/not" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = NOT(element);\n\nV[d] = result;"]),
     Right
       (Page "ORN_advsimd" []
          [(Class "ORN_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [I, I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ORN_asimdsame_only" []
                 "ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"]),
     Right
       (Page "ORR_advsimd_imm" []
          [(Class "shifted_immediate" Nothing
              (Diagram "aarch64/instrs/vector/logical"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O, O, O, O, O]),
                  Block (Just "a") (BlockEq [X]), Block (Just "b") (BlockEq [X]),
                  Block (Just "c") (BlockEq [X]),
                  Block (Just "cmode") (BlockEq [X, X, X, I]),
                  Block (Just "o2") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "d") (BlockEq [X]), Block (Just "e") (BlockEq [X]),
                  Block (Just "f") (BlockEq [X]), Block (Just "g") (BlockEq [X]),
                  Block (Just "h") (BlockEq [X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ORR_asimdimm_L_hl" [("cmode", BlockEq [I, O, X, I])]
                 "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing,
                  Symbol "<amount>" "cmode<1>"
                    (Just
                       (Table ["cmode<1>"]
                          [TableRow "0" [[O]] Nothing, TableRow "8" [[I]] Nothing]))],
               Encoding "ORR_asimdimm_L_sl" [("cmode", BlockEq [O, X, X, I])]
                 "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<imm8>" "a:b:c:d:e:f:g:h" Nothing,
                  Symbol "<amount>" "cmode<2:1>"
                    (Just
                       (Table ["cmode<2:1>"]
                          [TableRow "0" [[O, O]] Nothing, TableRow "8" [[O, I]] Nothing,
                           TableRow "16" [[I, O]] Nothing,
                           TableRow "24" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/logical" (Just PsDecode)
               "integer rd = UInt(Rd);\n\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\n\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        // FMOV Dn,#imm is in main FP instruction set\n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\n\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);"])]
          [Ps "aarch64/instrs/vector/logical" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\n\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\n\nV[rd] = result;"]),
     Right
       (Page "ORR_advsimd_reg" ["MOV_ORR_advsimd_reg"]
          [(Class "ORR_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [I, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ORR_asimdsame_only" []
                 "ORR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;"]),
     Right
       (Page "PMUL_advsimd" []
          [(Class "PMUL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/product"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, I, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "PMUL_asimdsame_only" []
                 "PMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "RESERVED" [[X], [O, I]] Nothing,
                           TableRow "RESERVED" [[X], [I, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/product"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif U == '1' && size != '00' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean poly = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/product"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if poly then\n        product = PolynomialMult(element1, element2)<esize-1:0>;\n    else\n        product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    Elem[result, e, esize] = product;\n\nV[d] = result;"]),
     Right
       (Page "PMULL_advsimd" []
          [(Class "PMULL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/poly"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "PMULL_asimddiff_L" []
                 "PMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing,
                           TableRow "RESERVED" [[O, I]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "1Q" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "RESERVED" [[X], [O, I]] Nothing,
                           TableRow "RESERVED" [[X], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/poly"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '01' || size == '10' then ReservedValue();\nif size == '11' && ! HaveCryptoExt() then UnallocatedEncoding();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/poly"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, 2*esize] = PolynomialMult(element1, element2);\n\nV[d] = result;"]),
     Right
       (Page "RADDHN_advsimd" []
          [(Class "RADDHN_asimddiff_N" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "o1") (BlockEq [O]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "RADDHN_asimddiff_N" []
                 "RADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"]),
     Right
       (Page "RAX1_advsimd" []
          [(Class "RAX1_VVV2_cryptosha512_3" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sha3/rax1"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "O") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "RAX1_VVV2_cryptosha512_3" []
                 "RAX1  <Vd>.2D, <Vn>.2D, <Vm>.2D"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3/rax1" (Just PsDecode)
               "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);"])]
          [Ps "aarch64/instrs/vector/crypto/sha3/rax1" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nV[d] = Vn EOR (ROL(Vm<127:64>,1):ROL(Vm<63:0>, 1));"]),
     Right
       (Page "RBIT_advsimd" []
          [(Class "RBIT_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/rbit"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, I]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "RBIT_asimdmisc_R" [] "RBIT  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/rbit" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/rbit" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nbits(esize) rev;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    for i = 0 to esize-1\n        rev<esize-1-i> = element<i>;\n    Elem[result, e, esize] = rev;\n\nV[d] = result;"]),
     Right
       (Page "REV16_advsimd" []
          [(Class "REV16_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/rev"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, O, O, O]),
                  Block (Just "o0") (BlockEq [I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "REV16_asimdmisc_R" [] "REV16  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "RESERVED" [[X], [O, I]] Nothing,
                           TableRow "RESERVED" [[X], [I, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/rev" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\n// size=esize:   B(0),  H(1),  S(1), D(S)\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\n\n// op=REVx: 64(0), 32(1), 16(2)\nbits(2) op = o0:U; \n\n// => op+size: \n//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X\n//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X\n//    16+B = 2, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n// => 3-(op+size) (index bits in group)\n//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X\n//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X\n//    16+B = 1, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n\n// index bits within group: 1, 2, 3\nif UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();\n\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/rev" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n\nV[d] = result;"]),
     Right
       (Page "REV32_advsimd" []
          [(Class "REV32_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/rev"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, O, O, O]),
                  Block (Just "o0") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "REV32_asimdmisc_R" [] "REV32  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "RESERVED" [[X], [I, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/rev" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\n// size=esize:   B(0),  H(1),  S(1), D(S)\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\n\n// op=REVx: 64(0), 32(1), 16(2)\nbits(2) op = o0:U; \n\n// => op+size: \n//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X\n//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X\n//    16+B = 2, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n// => 3-(op+size) (index bits in group)\n//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X\n//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X\n//    16+B = 1, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n\n// index bits within group: 1, 2, 3\nif UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();\n\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/rev" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n\nV[d] = result;"]),
     Right
       (Page "REV64_advsimd" []
          [(Class "REV64_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/rev"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, O, O, O]),
                  Block (Just "o0") (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "REV64_asimdmisc_R" [] "REV64  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/rev" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\n// size=esize:   B(0),  H(1),  S(1), D(S)\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\n\n// op=REVx: 64(0), 32(1), 16(2)\nbits(2) op = o0:U; \n\n// => op+size: \n//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X\n//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X\n//    16+B = 2, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n// => 3-(op+size) (index bits in group)\n//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X\n//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X\n//    16+B = 1, 16+H = X, 16+S = X, 16+D = X\n//     8+B = X,  8+H = X,  8+S = X,  8+D = X\n\n// index bits within group: 1, 2, 3\nif UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();\n\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\n\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/rev" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n\nV[d] = result;"]),
     Right
       (Page "RSHRN_advsimd" []
          [(Class "RSHRN_asimdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/logical"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "RSHRN_asimdshf_N" []
                 "RSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[X], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "8H" [[O, O, O, I]] Nothing,
                           TableRow "4S" [[O, O, I, X]] Nothing,
                           TableRow "2D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/logical"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right-narrow/logical"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\nfor e = 0 to elements-1\n    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    Elem[result, e, esize] = element<esize-1:0>;\n\nVpart[d, part] = result;"]),
     Right
       (Page "RSUBHN_advsimd" []
          [(Class "RSUBHN_asimddiff_N" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "o1") (BlockEq [I]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "RSUBHN_asimddiff_N" []
                 "RSUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"]),
     Right
       (Page "SABA_advsimd" []
          [(Class "SABA_asimdsame_only" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, I, I]),
                  Block (Just "ac") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SABA_asimdsame_only" []
                 "SABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"]),
     Right
       (Page "SABAL_advsimd" []
          [(Class "SABAL_asimddiff_L" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SABAL_asimddiff_L" []
                 "SABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"]),
     Right
       (Page "SABD_advsimd" []
          [(Class "SABD_asimdsame_only" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, I, I]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SABD_asimdsame_only" []
                 "SABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"]),
     Right
       (Page "SABDL_advsimd" []
          [(Class "SABDL_asimddiff_L" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SABDL_asimddiff_L" []
                 "SABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"]),
     Right
       (Page "SADALP_advsimd" []
          [(Class "SADALP_asimdmisc_P" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [I, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SADALP_asimdmisc_P" [] "SADALP  <Vd>.<Ta>, <Vn>.<Tb>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "4H" [[O], [O, O]] Nothing,
                           TableRow "8H" [[I], [O, O]] Nothing,
                           TableRow "2S" [[O], [O, I]] Nothing,
                           TableRow "4S" [[I], [O, I]] Nothing,
                           TableRow "1D" [[O], [I, O]] Nothing,
                           TableRow "2D" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n\nV[d] = result;"]),
     Right
       (Page "SADDL_advsimd" []
          [(Class "SADDL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SADDL_asimddiff_L" []
                 "SADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SADDLP_advsimd" []
          [(Class "SADDLP_asimdmisc_P" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [I, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SADDLP_asimdmisc_P" [] "SADDLP  <Vd>.<Ta>, <Vn>.<Tb>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "4H" [[O], [O, O]] Nothing,
                           TableRow "8H" [[I], [O, O]] Nothing,
                           TableRow "2S" [[O], [O, I]] Nothing,
                           TableRow "4S" [[I], [O, I]] Nothing,
                           TableRow "1D" [[O], [I, O]] Nothing,
                           TableRow "2D" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n\nV[d] = result;"]),
     Right
       (Page "SADDLV_advsimd" []
          [(Class "SADDLV_asimdall_only" Nothing
              (Diagram "aarch64/instrs/vector/reduce/add-long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SADDLV_asimdall_only" [] "SADDLV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "H" [[O, O]] Nothing, TableRow "S" [[O, I]] Nothing,
                           TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "RESERVED" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/add-long" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/reduce/add-long" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger sum;\n\nsum = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    sum = sum + Int(Elem[operand, e, esize], unsigned);\n\nV[d] = sum<2*esize-1:0>;"]),
     Right
       (Page "SADDW_advsimd" []
          [(Class "SADDW_asimddiff_W" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SADDW_asimddiff_W" []
                 "SADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SCVTF_float_fix" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/fix"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "rmode") (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O]),
                  Block (Just "scale") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SCVTF_H32_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "SCVTF  <Hd>, <Wn>, #<fbits>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "SCVTF_S32_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "SCVTF  <Sd>, <Wn>, #<fbits>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "SCVTF_D32_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "SCVTF  <Dd>, <Wn>, #<fbits>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "SCVTF_H64_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "SCVTF  <Hd>, <Xn>, #<fbits>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "SCVTF_S64_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "SCVTF  <Sd>, <Xn>, #<fbits>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "SCVTF_D64_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "SCVTF  <Dd>, <Xn>, #<fbits>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing]],
            [Ps "aarch64/instrs/float/convert/fix" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/fix" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"]),
     Right
       (Page "SCVTF_float_int" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SCVTF_H32_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "SCVTF  <Hd>, <Wn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "SCVTF_S32_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "SCVTF  <Sd>, <Wn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "SCVTF_D32_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "SCVTF  <Dd>, <Wn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "SCVTF_H64_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "SCVTF  <Hd>, <Xn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing],
               Encoding "SCVTF_S64_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "SCVTF  <Sd>, <Xn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing],
               Encoding "SCVTF_D64_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "SCVTF  <Dd>, <Xn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "SCVTF_advsimd_fix" []
          [(Class "SCVTF_asisdshf_C" Nothing
              (Diagram "aarch64/instrs/vector/shift/conv/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SCVTF_asisdshf_C" [] "SCVTF  <V><d>, <V><n>, #<fbits>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, X]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<fbits>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, X]] Nothing,
                           TableRow "(32-Uint(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/conv/int/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);"]),
           (Class "SCVTF_asimdshf_C" Nothing
              (Diagram "aarch64/instrs/vector/shift/conv/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SCVTF_asimdshf_C" []
                 "SCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "RESERVED" [[X], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<fbits>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "RESERVED" [[O, O, O, I]] Nothing,
                           TableRow "(32-Uint(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/conv/int/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/vector/shift/conv/int/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "SCVTF_advsimd_int" []
          [(Class "SCVTF_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SCVTF_asisdmiscfp16_R" [] "SCVTF  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');"]),
           (Class "SCVTF_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SCVTF_asisdmisc_R" [] "SCVTF  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/conv/int/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');"]),
           (Class "SCVTF_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SCVTF_asimdmiscfp16_R" [] "SCVTF  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"]),
           (Class "SCVTF_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SCVTF_asimdmisc_R" [] "SCVTF  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/conv/int/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nFPRounding rounding = FPRoundingMode(FPCR);\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "SDOT_advsimd_elt" []
          [(Class "SDOT_asimdelem_D" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/binary/element/dotp"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, O]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SDOT_asimdelem_D" []
                 "SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vm>" "M:Rm" Nothing, Symbol "<index>" "H:L" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/dotp"
               (Just PsDecode)
               "if !HaveDOTPExt() then UNDEFINED;\nif size  != '10' then ReservedValue();\nboolean signed = (U=='0');\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\ninteger index = UInt(H:L);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/dotp"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(datasize) result = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3\n        if signed then  \n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        res = res + element1 * element2; \n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nV[d] = result;"]),
     Right
       (Page "SDOT_advsimd_vec" []
          [(Class "SDOT_asimdsame2_D" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/dotp"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "opcode") (BlockEq [O, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SDOT_asimdsame2_D" []
                 "SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/dotp"
               (Just PsDecode)
               "if !HaveDOTPExt() then UNDEFINED;\nif size!= '10' then ReservedValue();\nboolean signed = (U=='0');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/dotp"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nresult = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3 \n        if signed then\n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        res = res + element1 * element2; \n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nV[d] = result;"]),
     Right
       (Page "SHA1C_advsimd" []
          [(Class "SHA1C_QSV_cryptosha3" Nothing
              (Diagram "aarch64/instrs/vector/crypto/sha3op/sha1-hash/choose"
                 [Block Nothing (BlockEq [O, I, O, I, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "opcode") (BlockEq [O, O, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA1C_QSV_cryptosha3" [] "SHA1C  <Qd>, <Sn>, <Vm>.4S"
                 [Symbol "<Qd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3op/sha1-hash/choose"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/crypto/sha3op/sha1-hash/choose"
             (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;"]),
     Right
       (Page "SHA1H_advsimd" []
          [(Class "SHA1H_SS_cryptosha2" Nothing
              (Diagram "aarch64/instrs/vector/crypto/sha2op/sha1-hash"
                 [Block Nothing (BlockEq [O, I, O, I, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, I, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA1H_SS_cryptosha2" [] "SHA1H  <Sd>, <Sn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha2op/sha1-hash" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/crypto/sha2op/sha1-hash"
             (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(32) operand = V[n];        // read element [0] only,  [1-3] zeroed\nV[d] = ROL(operand, 30);"]),
     Right
       (Page "SHA1M_advsimd" []
          [(Class "SHA1M_QSV_cryptosha3" Nothing
              (Diagram "aarch64/instrs/vector/crypto/sha3op/sha1-hash/majority"
                 [Block Nothing (BlockEq [O, I, O, I, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "opcode") (BlockEq [O, I, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA1M_QSV_cryptosha3" [] "SHA1M  <Qd>, <Sn>, <Vm>.4S"
                 [Symbol "<Qd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3op/sha1-hash/majority"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/crypto/sha3op/sha1-hash/majority"
             (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;"]),
     Right
       (Page "SHA1P_advsimd" []
          [(Class "SHA1P_QSV_cryptosha3" Nothing
              (Diagram "aarch64/instrs/vector/crypto/sha3op/sha1-hash/parity"
                 [Block Nothing (BlockEq [O, I, O, I, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "opcode") (BlockEq [O, O, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA1P_QSV_cryptosha3" [] "SHA1P  <Qd>, <Sn>, <Vm>.4S"
                 [Symbol "<Qd>" "Rd" Nothing, Symbol "<Sn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3op/sha1-hash/parity"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/crypto/sha3op/sha1-hash/parity"
             (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAparity(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;"]),
     Right
       (Page "SHA1SU0_advsimd" []
          [(Class "SHA1SU0_VVV_cryptosha3" Nothing
              (Diagram "aarch64/instrs/vector/crypto/sha3op/sha1-sched0"
                 [Block Nothing (BlockEq [O, I, O, I, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "opcode") (BlockEq [O, I, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA1SU0_VVV_cryptosha3" []
                 "SHA1SU0  <Vd>.4S, <Vn>.4S, <Vm>.4S"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3op/sha1-sched0"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/crypto/sha3op/sha1-sched0"
             (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) operand3 = V[m];\nbits(128) result;\n\nresult = operand2<63:0> : operand1<127:64>;\nresult = result EOR operand1 EOR operand3;\nV[d] = result;"]),
     Right
       (Page "SHA1SU1_advsimd" []
          [(Class "SHA1SU1_VV_cryptosha2" Nothing
              (Diagram "aarch64/instrs/vector/crypto/sha2op/sha1-sched1"
                 [Block Nothing (BlockEq [O, I, O, I, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, I, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA1SU1_VV_cryptosha2" [] "SHA1SU1  <Vd>.4S, <Vn>.4S"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha2op/sha1-sched1"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/crypto/sha2op/sha1-sched1"
             (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nbits(128) T = operand1 EOR LSR(operand2, 32);\nresult<31:0>   = ROL(T<31:0>,   1);\nresult<63:32>  = ROL(T<63:32>,  1);\nresult<95:64>  = ROL(T<95:64>,  1);\nresult<127:96> = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);\nV[d] = result;"]),
     Right
       (Page "SHA256H_advsimd" []
          [(Class "SHA256H_QQV_cryptosha3" Nothing
              (Diagram "aarch64/instrs/vector/crypto/sha3op/sha256-hash"
                 [Block Nothing (BlockEq [O, I, O, I, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "P") (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA256H_QQV_cryptosha3" []
                 "SHA256H  <Qd>, <Qn>, <Vm>.4S"
                 [Symbol "<Qd>" "Rd" Nothing, Symbol "<Qn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3op/sha256-hash"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean part1 = (P == '0');"])]
          [Ps "aarch64/instrs/vector/crypto/sha3op/sha256-hash"
             (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) result;\nif part1 then\n    result = SHA256hash(V[d], V[n], V[m], TRUE);\nelse\n    result = SHA256hash(V[n], V[d], V[m], FALSE);\nV[d] = result;"]),
     Right
       (Page "SHA256H2_advsimd" []
          [(Class "SHA256H2_QQV_cryptosha3" Nothing
              (Diagram "aarch64/instrs/vector/crypto/sha3op/sha256-hash"
                 [Block Nothing (BlockEq [O, I, O, I, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "P") (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA256H2_QQV_cryptosha3" []
                 "SHA256H2  <Qd>, <Qn>, <Vm>.4S"
                 [Symbol "<Qd>" "Rd" Nothing, Symbol "<Qn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3op/sha256-hash"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean part1 = (P == '0');"])]
          [Ps "aarch64/instrs/vector/crypto/sha3op/sha256-hash"
             (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) result;\nif part1 then\n    result = SHA256hash(V[d], V[n], V[m], TRUE);\nelse\n    result = SHA256hash(V[n], V[d], V[m], FALSE);\nV[d] = result;"]),
     Right
       (Page "SHA256SU0_advsimd" []
          [(Class "SHA256SU0_VV_cryptosha2" Nothing
              (Diagram "aarch64/instrs/vector/crypto/sha2op/sha256-sched0"
                 [Block Nothing (BlockEq [O, I, O, I, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]),
                  Block Nothing (BlockEq [I, O, I, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA256SU0_VV_cryptosha2" []
                 "SHA256SU0  <Vd>.4S, <Vn>.4S"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha2op/sha256-sched0"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/crypto/sha2op/sha256-sched0"
             (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nbits(128) T = operand2<31:0> : operand1<127:32>;\nbits(32) elt;\n\nfor e = 0 to 3\n    elt = Elem[T, e, 32];\n    elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);\n    Elem[result, e, 32] = elt + Elem[operand1, e, 32];\nV[d] = result;"]),
     Right
       (Page "SHA256SU1_advsimd" []
          [(Class "SHA256SU1_VVV_cryptosha3" Nothing
              (Diagram "aarch64/instrs/vector/crypto/sha3op/sha256-sched1"
                 [Block Nothing (BlockEq [O, I, O, I, I, I, I, O]),
                  Block (Just "size") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "opcode") (BlockEq [I, I, O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA256SU1_VVV_cryptosha3" []
                 "SHA256SU1  <Vd>.4S, <Vn>.4S, <Vm>.4S"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3op/sha256-sched1"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/vector/crypto/sha3op/sha256-sched1"
             (Just PsExecute)
             "CheckCryptoEnabled64();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) operand3 = V[m];\nbits(128) result;\nbits(128) T0 = operand3<31:0> : operand2<127:32>;\nbits(64) T1;\nbits(32) elt;\n\nT1 = operand3<127:64>;\nfor e = 0 to 1\n    elt = Elem[T1, e, 32];\n    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];\n    Elem[result, e, 32] = elt;\n\nT1 = result<63:0>;\nfor e = 2 to 3\n    elt = Elem[T1, e - 2, 32];\n    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];\n    Elem[result, e, 32] = elt;\n\nV[d] = result;"]),
     Right
       (Page "SHA512H_advsimd" []
          [(Class "SHA512H_QQV_cryptosha512_3" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sha512/sha512h"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "O") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA512H_QQV_cryptosha512_3" []
                 "SHA512H  <Qd>, <Qn>, <Vm>.2D"
                 [Symbol "<Qd>" "Rd" Nothing, Symbol "<Qn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha512/sha512h" (Just PsDecode)
               "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);"])]
          [Ps "aarch64/instrs/vector/crypto/sha512/sha512h" (Just PsExecute)
             "bits(128) Vtmp;  \nbits(64)  MSigma1;\nbits(64)  tmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\n\nMSigma1 =  ROR(Y<127:64>, 14) EOR ROR(Y<127:64>,18) EOR ROR(Y<127:64>,41);\nVtmp<127:64> =  (Y<127:64> AND X<63:0>) EOR (NOT(Y<127:64>) AND X<127:64>);\nVtmp<127:64> = (Vtmp<127:64> + MSigma1 +  W<127:64>);\ntmp = Vtmp<127:64> + Y<63:0>;\nMSigma1 = ROR(tmp, 14) EOR ROR(tmp,18) EOR ROR(tmp,41);\nVtmp<63:0> = (tmp AND Y<127:64>) EOR (NOT(tmp) AND X<63:0>);\nVtmp<63:0> = (Vtmp<63:0> + MSigma1 + W<63:0>);\nV[d] =  Vtmp;"]),
     Right
       (Page "SHA512H2_advsimd" []
          [(Class "SHA512H2_QQV_cryptosha512_3" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sha512/sha512h2"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "O") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA512H2_QQV_cryptosha512_3" []
                 "SHA512H2  <Qd>, <Qn>, <Vm>.2D"
                 [Symbol "<Qd>" "Rd" Nothing, Symbol "<Qn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha512/sha512h2" (Just PsDecode)
               "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);"])]
          [Ps "aarch64/instrs/vector/crypto/sha512/sha512h2" (Just PsExecute)
             "bits(128) Vtmp;  \nbits(64) NSigma0;\nbits(64) tmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\n\nNSigma0 =  ROR(Y<63:0>, 28) EOR ROR(Y<63:0>,34) EOR ROR(Y<63:0>,39);\nVtmp<127:64> = (X<63:0> AND Y<127:64>) EOR (X<63:0> AND Y<63:0>) EOR (Y<127:64> AND Y<63:0>);\nVtmp<127:64> = (Vtmp<127:64> + NSigma0 +  W<127:64>);\nNSigma0 =  ROR(Vtmp<127:64>, 28) EOR ROR(Vtmp<127:64>,34) EOR ROR(Vtmp<127:64>,39);\nVtmp<63:0> =   (Vtmp<127:64> AND Y<63:0>) EOR (Vtmp<127:64> AND Y<127:64>) EOR (Y<127:64> AND Y<63:0>);\nVtmp<63:0> =   (Vtmp<63:0> + NSigma0 + W<63:0>);\n\nV[d] = Vtmp;"]),
     Right
       (Page "SHA512SU0_advsimd" []
          [(Class "SHA512SU0_VV2_cryptosha512_2" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sha512/sha512su0"
                 [Block Nothing
                    (BlockEq
                       [I, I, O, O, I, I, I, O, I, I, O, O, O, O, O, O, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA512SU0_VV2_cryptosha512_2" []
                 "SHA512SU0  <Vd>.2D, <Vn>.2D"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha512/sha512su0" (Just PsDecode)
               "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);"])]
          [Ps "aarch64/instrs/vector/crypto/sha512/sha512su0"
             (Just PsExecute)
             "bits(64) sig0;\nbits(128) Vtmp;\nbits(128) X = V[n];\nbits(128) W = V[d]; \nsig0 = ROR(W<127:64>, 1) EOR ROR(W<127:64>, 8) EOR '0000000':W<127:71>; \nVtmp<63:0> = W<63:0> + sig0;\nsig0 = ROR(X<63:0>, 1) EOR ROR(X<63:0>, 8) EOR '0000000':X<63:7>; \nVtmp<127:64> = W<127:64> + sig0;\nV[d] = Vtmp;"]),
     Right
       (Page "SHA512SU1_advsimd" []
          [(Class "SHA512SU1_VVV2_cryptosha512_3" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sha512/sha512su1"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "O") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHA512SU1_VVV2_cryptosha512_3" []
                 "SHA512SU1  <Vd>.2D, <Vn>.2D, <Vm>.2D"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha512/sha512su1" (Just PsDecode)
               "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);"])]
          [Ps "aarch64/instrs/vector/crypto/sha512/sha512su1"
             (Just PsExecute)
             "bits(64) sig1;\nbits(128) Vtmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\n\nsig1 = ROR(X<127:64>, 19) EOR ROR(X<127:64>,61) EOR '000000':X<127:70>; \nVtmp<127:64> = W<127:64> + sig1 + Y<127:64>;\nsig1 = ROR(X<63:0>, 19) EOR ROR(X<63:0>,61) EOR '000000':X<63:6>; \nVtmp<63:0> = W<63:0> + sig1 + Y<63:0>;\nV[d] = Vtmp;"]),
     Right
       (Page "SHADD_advsimd" []
          [(Class "SHADD_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/truncating"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHADD_asimdsame_only" []
                 "SHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/truncating"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/truncating"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    Elem[result, e, esize] = sum<esize:1>;\n\nV[d] = result;"]),
     Right
       (Page "SHL_advsimd" []
          [(Class "SHL_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/left/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [O, I, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHL_asisdshf_R" [] "SHL  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(UInt(immh:immb)-64)" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;"]),
           (Class "SHL_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/left/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [O, I, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHL_asimdshf_R" [] "SHL  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(UInt(immh:immb)-8)" [[O, O, O, I]] Nothing,
                           TableRow "(UInt(immh:immb)-16)" [[O, O, I, X]] Nothing,
                           TableRow "(UInt(immh:immb)-32)" [[O, I, X, X]] Nothing,
                           TableRow "(UInt(immh:immb)-64)" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;"])]
          [Ps "aarch64/instrs/vector/shift/left/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift);\n\nV[d] = result;"]),
     Right
       (Page "SHLL_advsimd" []
          [(Class "SHLL_asimdmisc_S" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/shift"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHLL_asimdmisc_S" []
                 "SHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<shift>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8" [[O, O]] Nothing, TableRow "16" [[O, I]] Nothing,
                           TableRow "32" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/shift" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = esize;\nboolean unsigned = FALSE; // Or TRUE without change of functionality"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/shift" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(2*datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SHRN_advsimd" []
          [(Class "SHRN_asimdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/logical"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHRN_asimdshf_N" []
                 "SHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[X], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "8H" [[O, O, O, I]] Nothing,
                           TableRow "4S" [[O, O, I, X]] Nothing,
                           TableRow "2D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/logical"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right-narrow/logical"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\nfor e = 0 to elements-1\n    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    Elem[result, e, esize] = element<esize-1:0>;\n\nVpart[d, part] = result;"]),
     Right
       (Page "SHSUB_advsimd" []
          [(Class "SHSUB_asimdsame_only" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/sub/int"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SHSUB_asimdsame_only" []
                 "SHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/int"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/int"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    Elem[result, e, esize] = diff<esize:1>;\n\nV[d] = result;"]),
     Right
       (Page "SLI_advsimd" []
          [(Class "SLI_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/left-insert/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [O, I, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SLI_asisdshf_R" [] "SLI  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(UInt(immh:immb)-64)" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left-insert/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;"]),
           (Class "SLI_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/left-insert/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [O, I, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SLI_asimdshf_R" [] "SLI  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(UInt(immh:immb)-8)" [[O, O, O, I]] Nothing,
                           TableRow "(UInt(immh:immb)-16)" [[O, O, I, X]] Nothing,
                           TableRow "(UInt(immh:immb)-32)" [[O, I, X, X]] Nothing,
                           TableRow "(UInt(immh:immb)-64)" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left-insert/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;"])]
          [Ps "aarch64/instrs/vector/shift/left-insert/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2 = V[d];\nbits(datasize) result;\nbits(esize) mask = LSL(Ones(esize), shift);\nbits(esize) shifted;\n\nfor e = 0 to elements-1\n    shifted = LSL(Elem[operand, e, esize], shift);\n    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;\nV[d] = result;"]),
     Right
       (Page "SM3PARTW1_advsimd" []
          [(Class "SM3PARTW1_VVV4_cryptosha512_3" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sm3/sm3partw1"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "O") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SM3PARTW1_VVV4_cryptosha512_3" []
                 "SM3PARTW1  <Vd>.4S, <Vn>.4S, <Vm>.4S"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sm3/sm3partw1" (Just PsDecode)
               "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);"])]
          [Ps "aarch64/instrs/vector/crypto/sm3/sm3partw1" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) result; \n\nresult<95:0> = (Vd EOR Vn)<95:0> EOR (ROL(Vm<127:96>,15):ROL(Vm<95:64>,15):ROL(Vm<63:32>,15));\n\nfor i = 0 to 3\n    if i == 3 then \n        result<127:96> = (Vd EOR Vn)<127:96> EOR (ROL(result<31:0>,15));\n    result<(32*i)+31:(32*i)> = result<(32*i)+31:(32*i)> EOR ROL(result<(32*i)+31:(32*i)>,15) EOR ROL(result<(32*i)+31:(32*i)>,23);\nV[d] = result;"]),
     Right
       (Page "SM3PARTW2_advsimd" []
          [(Class "SM3PARTW2_VVV4_cryptosha512_3" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sm3/sm3partw2"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "O") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SM3PARTW2_VVV4_cryptosha512_3" []
                 "SM3PARTW2  <Vd>.4S, <Vn>.4S, <Vm>.4S"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sm3/sm3partw2" (Just PsDecode)
               "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);"])]
          [Ps "aarch64/instrs/vector/crypto/sm3/sm3partw2" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) result; \nbits(128) tmp;\nbits(32) tmp2;\ntmp<127:0> = Vn EOR (ROL(Vm<127:96>,7):ROL(Vm<95:64>,7):ROL(Vm<63:32>,7):ROL(Vm<31:0>,7)); \nresult<127:0> = Vd<127:0> EOR tmp<127:0>;\ntmp2 = ROL(tmp<31:0>,15);\ntmp2 = tmp2 EOR ROL(tmp2,15) EOR ROL(tmp2,23);\nresult<127:96> = result<127:96> EOR tmp2;\nV[d]= result;"]),
     Right
       (Page "SM3SS1_advsimd" []
          [(Class "SM3SS1_VVV4_crypto4" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sm3/sm3ss1"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O]),
                  Block (Just "Op0") (BlockEq [I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Ra") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SM3SS1_VVV4_crypto4" []
                 "SM3SS1  <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<Va>" "Ra" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sm3/sm3ss1" (Just PsDecode)
               "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger a = UInt(Ra);"])]
          [Ps "aarch64/instrs/vector/crypto/sm3/sm3ss1" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) Va = V[a];\nVd<127:96> = ROL((ROL(Vn<127:96>,12) + Vm<127:96> + Va<127:96>) , 7);\nVd<95:0> = Zeros();\nV[d] = Vd;"]),
     Right
       (Page "SM3TT1A_advsimd" []
          [(Class "SM3TT1A_VVV4_crypto3_imm2" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sm3/sm3tt1a"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "imm2") (BlockEq [X, X]),
                  Block (Just "opcode") (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SM3TT1A_VVV4_crypto3_imm2" []
                 "SM3TT1A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<imm2>" "imm2" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sm3/sm3tt1a" (Just PsDecode)
               "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger i = UInt(imm2);"])]
          [Ps "aarch64/instrs/vector/crypto/sm3/sm3tt1a" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) WjPrime;\nbits(128) result; \nbits(32) TT1;\nbits(32) SS2;\n\nWjPrime = Elem[Vm,i,32];\nSS2 = Vn<127:96> EOR ROL(Vd<127:96>,12); \nTT1 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);\nTT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>;\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,9); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT1; \nV[d] = result;"]),
     Right
       (Page "SM3TT1B_advsimd" []
          [(Class "SM3TT1B_VVV4_crypto3_imm2" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sm3/sm3tt1b"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "imm2") (BlockEq [X, X]),
                  Block (Just "opcode") (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SM3TT1B_VVV4_crypto3_imm2" []
                 "SM3TT1B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<imm2>" "imm2" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sm3/sm3tt1b" (Just PsDecode)
               "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger i = UInt(imm2);"])]
          [Ps "aarch64/instrs/vector/crypto/sm3/sm3tt1b" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) WjPrime;\nbits(128) result; \nbits(32) TT1;\nbits(32) SS2;\n\nWjPrime = Elem[Vm,i,32];\nSS2 = Vn<127:96> EOR ROL(Vd<127:96>,12); \nTT1 = (Vd<127:96> AND Vd<63:32>) OR (Vd<127:96> AND Vd<95:64>) OR (Vd<63:32> AND Vd<95:64>); \nTT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>;\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,9); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT1; \nV[d] = result;"]),
     Right
       (Page "SM3TT2A_advsimd" []
          [(Class "SM3TT2A_VVV4_crypto3_imm2" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sm3/sm3tt2a"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "imm2") (BlockEq [X, X]),
                  Block (Just "opcode") (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SM3TT2A_VVV4_crypto3_imm2" []
                 "SM3TT2A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<imm2>" "imm2" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sm3/sm3tt2a" (Just PsDecode)
               "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger i = UInt(imm2);"])]
          [Ps "aarch64/instrs/vector/crypto/sm3/sm3tt2a" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) Wj;\nbits(128) result; \nbits(32) TT1;\n\nWj = Elem[Vm,i,32];\nTT2 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);\nTT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>;\n\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,19); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); \nV[d] = result;"]),
     Right
       (Page "SM3TT2B_advsimd" []
          [(Class "SM3TT2B_VVV_crypto3_imm2" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sm3/sm3tt2b"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "imm2") (BlockEq [X, X]),
                  Block (Just "opcode") (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SM3TT2B_VVV_crypto3_imm2" []
                 "SM3TT2B  <Vd>.S, <Vn>.S, <Vm>.S[<imm2>]"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<imm2>" "imm2" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sm3/sm3tt2b" (Just PsDecode)
               "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger i = UInt(imm2);"])]
          [Ps "aarch64/instrs/vector/crypto/sm3/sm3tt2b" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) Wj;\nbits(128) result; \nbits(32) TT2;\n\nWj = Elem[Vm,i,32];\nTT2 = (Vd<127:96> AND Vd<95:64>) OR (NOT(Vd<127:96>) AND Vd<63:32>); \nTT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>;\n\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,19); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); \nV[d] = result;"]),
     Right
       (Page "SM4E_advsimd" []
          [(Class "SM4E_VV4_cryptosha512_2" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sm4/sm4enc"
                 [Block Nothing
                    (BlockEq
                       [I, I, O, O, I, I, I, O, I, I, O, O, O, O, O, O, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SM4E_VV4_cryptosha512_2" [] "SM4E  <Vd>.4S, <Vn>.4S"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sm4/sm4enc" (Just PsDecode)
               "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);"])]
          [Ps "aarch64/instrs/vector/crypto/sm4/sm4enc" (Just PsExecute)
             "bits(128) Vn = V[n];\nbits(32) intval; \nbits(8) sboxout;\nbits(128) roundresult;\nbits(32) roundkey;\ninteger index;\n\nroundresult=V[d];\nfor index = 0 to 3\n    roundkey = Elem[Vn,index,32];\n\n    intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR roundkey; \n\n    for i = 0 to 3  \n        Elem[intval,i,8]  = Sbox(Elem[intval,i,8]); \n\n    intval = intval EOR ROL(intval,2) EOR ROL(intval,10) EOR ROL(intval,18) EOR ROL(intval,24);\n    intval = intval EOR roundresult<31:0>; \n\n    roundresult<31:0> = roundresult<63:32>;\n    roundresult<63:32> = roundresult<95:64>;\n    roundresult<95:64> = roundresult<127:96>;\n    roundresult<127:96> = intval; \nV[d] = roundresult;"]),
     Right
       (Page "SM4EKEY_advsimd" []
          [(Class "SM4EKEY_VVV4_cryptosha512_3" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sm4/sm4enckey"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, O, I, I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block (Just "O") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SM4EKEY_VVV4_cryptosha512_3" []
                 "SM4EKEY  <Vd>.4S, <Vn>.4S, <Vm>.4S"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sm4/sm4enckey" (Just PsDecode)
               "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);"])]
          [Ps "aarch64/instrs/vector/crypto/sm4/sm4enckey" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(32) intval; \nbits(8) sboxout;\nbits(128) result;\nbits(32) const;\nbits(128) roundresult;\ninteger index;\n\nroundresult = V[n];\nfor index = 0 to 3 \n    const = Elem[Vm,index,32];\n\n    intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR const; \n\n    for i = 0 to 3  \n        Elem[intval,i,8] = Sbox(Elem[intval,i,8]); \n\n    intval = intval EOR ROL(intval,13) EOR ROL(intval,23);\n    intval = intval EOR roundresult<31:0>; \n\n    roundresult<31:0> = roundresult<63:32>;\n    roundresult<63:32> = roundresult<95:64>;\n    roundresult<95:64> = roundresult<127:96>;\n    roundresult<127:96> = intval; \nV[d] = roundresult;"]),
     Right
       (Page "SMAX_advsimd" []
          [(Class "SMAX_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMAX_asimdsame_only" []
                 "SMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SMAXP_advsimd" []
          [(Class "SMAXP_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMAXP_asimdsame_only" []
                 "SMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SMAXV_advsimd" []
          [(Class "SMAXV_asimdall_only" Nothing
              (Diagram "aarch64/instrs/vector/reduce/int-max"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [I, O, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMAXV_asimdall_only" [] "SMAXV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "RESERVED" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/int-max" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');"])]
          [Ps "aarch64/instrs/vector/reduce/int-max" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"]),
     Right
       (Page "SMIN_advsimd" []
          [(Class "SMIN_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMIN_asimdsame_only" []
                 "SMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SMINP_advsimd" []
          [(Class "SMINP_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMINP_asimdsame_only" []
                 "SMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SMINV_advsimd" []
          [(Class "SMINV_asimdall_only" Nothing
              (Diagram "aarch64/instrs/vector/reduce/int-max"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [I, O, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMINV_asimdall_only" [] "SMINV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "RESERVED" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/int-max" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');"])]
          [Ps "aarch64/instrs/vector/reduce/int-max" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"]),
     Right
       (Page "SMLAL_advsimd_elt" []
          [(Class "SMLAL_asimdelem_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, O]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMLAL_asimdelem_L" []
                 "SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"]),
     Right
       (Page "SMLAL_advsimd_vec" []
          [(Class "SMLAL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]), Block (Just "o1") (BlockEq [O]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMLAL_asimddiff_L" []
                 "SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"]),
     Right
       (Page "SMLSL_advsimd_elt" []
          [(Class "SMLSL_asimdelem_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, O]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMLSL_asimdelem_L" []
                 "SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"]),
     Right
       (Page "SMLSL_advsimd_vec" []
          [(Class "SMLSL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]), Block (Just "o1") (BlockEq [I]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMLSL_asimddiff_L" []
                 "SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"]),
     Right
       (Page "SMOV_advsimd" []
          [(Class "advsimd" Nothing
              (Diagram "aarch64/instrs/vector/transfer/integer/move/signed"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O, O, O, O]),
                  Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "imm4<3:2>") (BlockEq [O, I]),
                  Block (Just "imm4<1>") (BlockEq [O]),
                  Block (Just "imm4<0>") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMOV_asimdins_W_w" [("Q", BlockEq [O])]
                 "SMOV  <Wd>, <Vn>.<Ts>[<index>]"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ts>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, X, X, O, O]] Nothing,
                           TableRow "B" [[X, X, X, X, I]] Nothing,
                           TableRow "H" [[X, X, X, I, O]] Nothing])),
                  Symbol "<index>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, X, X, O, O]] Nothing,
                           TableRow "imm5<4:1>" [[X, X, X, X, I]] Nothing,
                           TableRow "imm5<4:2>" [[X, X, X, I, O]] Nothing]))],
               Encoding "SMOV_asimdins_X_x" [("Q", BlockEq [I])]
                 "SMOV  <Xd>, <Vn>.<Ts>[<index>]"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ts>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, X, O, O, O]] Nothing,
                           TableRow "B" [[X, X, X, X, I]] Nothing,
                           TableRow "H" [[X, X, X, I, O]] Nothing,
                           TableRow "S" [[X, X, I, O, O]] Nothing])),
                  Symbol "<index>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, X, O, O, O]] Nothing,
                           TableRow "imm5<4:1>" [[X, X, X, X, I]] Nothing,
                           TableRow "imm5<4:2>" [[X, X, X, I, O]] Nothing,
                           TableRow "imm5<4:3>" [[X, X, I, O, O]] Nothing]))]],
            [Ps "aarch64/instrs/vector/transfer/integer/move/signed"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size;\ncase Q:imm5 of\n    when 'xxxxx1' size = 0;     // SMOV [WX]d, Vn.B\n    when 'xxxx10' size = 1;     // SMOV [WX]d, Vn.H\n    when '1xx100' size = 2;     // SMOV Xd, Vn.S\n    otherwise     UnallocatedEncoding();\n\ninteger idxdsize = if imm5<4> == '1' then 128 else 64;\ninteger index = UInt(imm5<4:size+1>);\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 64 else 32;"])]
          [Ps "aarch64/instrs/vector/transfer/integer/move/signed"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\n\nX[d] = SignExtend(Elem[operand, index, esize], datasize);"]),
     Right
       (Page "SMULL_advsimd_elt" []
          [(Class "SMULL_asimdelem_L" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/element/mul/long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, O]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMULL_asimdelem_L" []
                 "SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/long"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/long"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = product;\n\nV[d] = result;"]),
     Right
       (Page "SMULL_advsimd_vec" []
          [(Class "SMULL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/product"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode<3>") (BlockEq [I]),
                  Block (Just "opcode<2>") (BlockEq [I]),
                  Block (Just "opcode<1>") (BlockEq [O]),
                  Block (Just "opcode<0>") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SMULL_asimddiff_L" []
                 "SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/product"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/product"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SQABS_advsimd" []
          [(Class "SQABS_asisdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQABS_asisdmisc_R" [] "SQABS  <V><d>, <V><n>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');"]),
           (Class "SQABS_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQABS_asimdmisc_R" [] "SQABS  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         \n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQADD_advsimd" []
          [(Class "SQADD_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQADD_asisdsame_only" [] "SQADD  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');"]),
           (Class "SQADD_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQADD_asimdsame_only" []
                 "SQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQDMLAL_advsimd_elt" []
          [(Class "SQDMLAL_asisdelem_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMLAL_asisdelem_L" []
                 "SQDMLAL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Va>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "S" [[O, I]] Nothing, TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Vb>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/sisd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o2 == '1');"]),
           (Class "SQDMLAL_asimdelem_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMLAL_asimdelem_L" []
                 "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/simd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o2 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQDMLAL_advsimd_vec" []
          [(Class "SQDMLAL_asisddiff_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]), Block (Just "o1") (BlockEq [O]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMLAL_asisddiff_only" []
                 "SQDMLAL  <Va><d>, <Vb><n>, <Vb><m>"
                 [Symbol "<Va>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "S" [[O, I]] Nothing, TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Vb>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<n>" "Rn" Nothing, Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o1 == '1');"]),
           (Class "SQDMLAL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]), Block (Just "o1") (BlockEq [O]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMLAL_asimddiff_L" []
                 "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQDMLSL_advsimd_elt" []
          [(Class "SQDMLSL_asisdelem_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMLSL_asisdelem_L" []
                 "SQDMLSL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Va>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "S" [[O, I]] Nothing, TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Vb>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/sisd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o2 == '1');"]),
           (Class "SQDMLSL_asimdelem_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMLSL_asimdelem_L" []
                 "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/simd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o2 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQDMLSL_advsimd_vec" []
          [(Class "SQDMLSL_asisddiff_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]), Block (Just "o1") (BlockEq [I]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMLSL_asisddiff_only" []
                 "SQDMLSL  <Va><d>, <Vb><n>, <Vb><m>"
                 [Symbol "<Va>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "S" [[O, I]] Nothing, TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Vb>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<n>" "Rn" Nothing, Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\nboolean sub_op = (o1 == '1');"]),
           (Class "SQDMLSL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]), Block (Just "o1") (BlockEq [I]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMLSL_asimddiff_L" []
                 "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQDMULH_advsimd_elt" []
          [(Class "SQDMULH_asisdelem_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/high/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I, I, O]), Block (Just "op") (BlockEq [O]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMULH_asisdelem_R" []
                 "SQDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/high/sisd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean round = (op == '1');"]),
           (Class "SQDMULH_asimdelem_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/high/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I, I, O]), Block (Just "op") (BlockEq [O]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMULH_asimdelem_R" []
                 "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/high/simd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean round = (op == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/high/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    // The following only saturates if element1 and element2 equal -(2^(esize-1))\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQDMULH_advsimd_vec" []
          [(Class "SQDMULH_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMULH_asisdsame_only" []
                 "SQDMULH  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = (U == '1');"]),
           (Class "SQDMULH_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMULH_asimdsame_only" []
                 "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean rounding = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQDMULL_advsimd_elt" []
          [(Class "SQDMULL_asisdelem_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/double/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMULL_asisdelem_L" []
                 "SQDMULL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Va>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "S" [[O, I]] Nothing, TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Vb>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul/double/sisd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;"]),
           (Class "SQDMULL_asimdelem_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/double/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMULL_asimdelem_L" []
                 "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul/double/simd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/element/mul/double/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);\n    Elem[result, e, 2*esize] = product;\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQDMULL_advsimd_vec" []
          [(Class "SQDMULL_asisddiff_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMULL_asisddiff_only" []
                 "SQDMULL  <Va><d>, <Vb><n>, <Vb><m>"
                 [Symbol "<Va>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "S" [[O, I]] Nothing, TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Vb>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<n>" "Rn" Nothing, Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;"]),
           (Class "SQDMULL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, O, I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQDMULL_asimddiff_L" []
                 "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);\n    Elem[result, e, 2*esize] = product;\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQNEG_advsimd" []
          [(Class "SQNEG_asisdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQNEG_asisdmisc_R" [] "SQNEG  <V><d>, <V><n>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');"]),
           (Class "SQNEG_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, I, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQNEG_asimdmisc_R" [] "SQNEG  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         \n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQRDMLAH_advsimd_elt" []
          [(Class "SQRDMLAH_asisdelem_R" (Just (ArchName "ARMv8.1"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I, I]), Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMLAH_asisdelem_R" []
                 "SQRDMLAH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/sisd"
               (Just PsDecode)
               "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');"]),
           (Class "SQRDMLAH_asimdelem_R" (Just (ArchName "ARMv8.1"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I, I]), Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMLAH_asimdelem_R" []
                 "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/simd"
               (Just PsDecode)
               "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQRDMLAH_advsimd_vec" []
          [(Class "SQRDMLAH_asisdsame2_only" (Just (ArchName "ARMv8.1"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O, O]),
                  Block (Just "S") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMLAH_asisdsame2_only" []
                 "SQRDMLAH  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd"
               (Just PsDecode)
               "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');"]),
           (Class "SQRDMLAH_asimdsame2_only" (Just (ArchName "ARMv8.1"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O, O]),
                  Block (Just "S") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMLAH_asimdsame2_only" []
                 "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/simd"
               (Just PsDecode)
               "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQRDMLSH_advsimd_elt" []
          [(Class "SQRDMLSH_asisdelem_R" (Just (ArchName "ARMv8.1"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I, I]), Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMLSH_asisdelem_R" []
                 "SQRDMLSH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/sisd"
               (Just PsDecode)
               "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');"]),
           (Class "SQRDMLSH_asimdelem_R" (Just (ArchName "ARMv8.1"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I, I]), Block (Just "S") (BlockEq [I]),
                  Block Nothing (BlockEq [I]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMLSH_asimdelem_R" []
                 "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/simd"
               (Just PsDecode)
               "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQRDMLSH_advsimd_vec" []
          [(Class "SQRDMLSH_asisdsame2_only" (Just (ArchName "ARMv8.1"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O, O]),
                  Block (Just "S") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMLSH_asisdsame2_only" []
                 "SQRDMLSH  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd"
               (Just PsDecode)
               "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');"]),
           (Class "SQRDMLSH_asimdsame2_only" (Just (ArchName "ARMv8.1"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O, O]),
                  Block (Just "S") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMLSH_asimdsame2_only" []
                 "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/simd"
               (Just PsDecode)
               "if !HaveQRDMLAHExt() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQRDMULH_advsimd_elt" []
          [(Class "SQRDMULH_asisdelem_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/high/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I, I, O]), Block (Just "op") (BlockEq [I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMULH_asisdelem_R" []
                 "SQRDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/high/sisd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean round = (op == '1');"]),
           (Class "SQRDMULH_asimdelem_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul/high/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [I, I, O]), Block (Just "op") (BlockEq [I]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMULH_asimdelem_R" []
                 "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/high/simd"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean round = (op == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/high/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    // The following only saturates if element1 and element2 equal -(2^(esize-1))\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQRDMULH_advsimd_vec" []
          [(Class "SQRDMULH_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMULH_asisdsame_only" []
                 "SQRDMULH  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = (U == '1');"]),
           (Class "SQRDMULH_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRDMULH_asimdsame_only" []
                 "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean rounding = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQRSHL_advsimd" []
          [(Class "SQRSHL_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [I]),
                  Block (Just "S") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRSHL_asisdsame_only" []
                 "SQRSHL  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();"]),
           (Class "SQRSHL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [I]),
                  Block (Just "S") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRSHL_asimdsame_only" []
                 "SQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SQRSHRN_advsimd" []
          [(Class "SQRSHRN_asisdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, I]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRSHRN_asisdshf_N" []
                 "SQRSHRN  <Vb><d>, <Va><n>, #<shift>"
                 [Symbol "<Vb>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "B" [[O, O, O, I]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Va>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "H" [[O, O, O, I]] Nothing,
                           TableRow "S" [[O, O, I, X]] Nothing,
                           TableRow "D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');"]),
           (Class "SQRSHRN_asimdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/uniform/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, I]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRSHRN_asimdshf_N" []
                 "SQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[X], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "8H" [[O, O, O, I]] Nothing,
                           TableRow "4S" [[O, O, I, X]] Nothing,
                           TableRow "2D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"]),
     Right
       (Page "SQRSHRUN_advsimd" []
          [(Class "SQRSHRUN_asisdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/nonuniform/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRSHRUN_asisdshf_N" []
                 "SQRSHRUN  <Vb><d>, <Va><n>, #<shift>"
                 [Symbol "<Vb>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "B" [[O, O, O, I]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Va>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "H" [[O, O, O, I]] Nothing,
                           TableRow "S" [[O, O, I, X]] Nothing,
                           TableRow "D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/nonuniform/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');"]),
           (Class "SQRSHRUN_asimdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/nonuniform/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, O]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQRSHRUN_asimdshf_N" []
                 "SQRSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[X], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "8H" [[O, O, O, I]] Nothing,
                           TableRow "4S" [[O, O, I, X]] Nothing,
                           TableRow "2D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/nonuniform/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right-narrow/nonuniform/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"]),
     Right
       (Page "SQSHL_advsimd_imm" []
          [(Class "SQSHL_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/left-sat/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSHL_asisdshf_R" [] "SQSHL  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "B" [[O, O, O, I]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "(UInt(immh:immb)-8)" [[O, O, O, I]] Nothing,
                           TableRow "(UInt(immh:immb)-16)" [[O, O, I, X]] Nothing,
                           TableRow "(UInt(immh:immb)-32)" [[O, I, X, X]] Nothing,
                           TableRow "(UInt(immh:immb)-64)" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left-sat/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;"]),
           (Class "SQSHL_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/left-sat/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSHL_asimdshf_R" []
                 "SQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(UInt(immh:immb)-8)" [[O, O, O, I]] Nothing,
                           TableRow "(UInt(immh:immb)-16)" [[O, O, I, X]] Nothing,
                           TableRow "(UInt(immh:immb)-32)" [[O, I, X, X]] Nothing,
                           TableRow "(UInt(immh:immb)-64)" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left-sat/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;"])]
          [Ps "aarch64/instrs/vector/shift/left-sat/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQSHL_advsimd_reg" []
          [(Class "SQSHL_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [O]),
                  Block (Just "S") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSHL_asisdsame_only" [] "SQSHL  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();"]),
           (Class "SQSHL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [O]),
                  Block (Just "S") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSHL_asimdsame_only" []
                 "SQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SQSHLU_advsimd" []
          [(Class "SQSHLU_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/left-sat/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSHLU_asisdshf_R" [] "SQSHLU  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "B" [[O, O, O, I]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "(UInt(immh:immb)-8)" [[O, O, O, I]] Nothing,
                           TableRow "(UInt(immh:immb)-16)" [[O, O, I, X]] Nothing,
                           TableRow "(UInt(immh:immb)-32)" [[O, I, X, X]] Nothing,
                           TableRow "(UInt(immh:immb)-64)" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left-sat/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;"]),
           (Class "SQSHLU_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/left-sat/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSHLU_asimdshf_R" []
                 "SQSHLU  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(UInt(immh:immb)-8)" [[O, O, O, I]] Nothing,
                           TableRow "(UInt(immh:immb)-16)" [[O, O, I, X]] Nothing,
                           TableRow "(UInt(immh:immb)-32)" [[O, I, X, X]] Nothing,
                           TableRow "(UInt(immh:immb)-64)" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left-sat/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;"])]
          [Ps "aarch64/instrs/vector/shift/left-sat/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQSHRN_advsimd" []
          [(Class "SQSHRN_asisdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, I]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSHRN_asisdshf_N" []
                 "SQSHRN  <Vb><d>, <Va><n>, #<shift>"
                 [Symbol "<Vb>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "B" [[O, O, O, I]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Va>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "H" [[O, O, O, I]] Nothing,
                           TableRow "S" [[O, O, I, X]] Nothing,
                           TableRow "D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');"]),
           (Class "SQSHRN_asimdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/uniform/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, I]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSHRN_asimdshf_N" []
                 "SQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[X], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "8H" [[O, O, O, I]] Nothing,
                           TableRow "4S" [[O, O, I, X]] Nothing,
                           TableRow "2D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"]),
     Right
       (Page "SQSHRUN_advsimd" []
          [(Class "SQSHRUN_asisdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/nonuniform/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSHRUN_asisdshf_N" []
                 "SQSHRUN  <Vb><d>, <Va><n>, #<shift>"
                 [Symbol "<Vb>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "B" [[O, O, O, I]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Va>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "H" [[O, O, O, I]] Nothing,
                           TableRow "S" [[O, O, I, X]] Nothing,
                           TableRow "D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/nonuniform/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');"]),
           (Class "SQSHRUN_asimdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/nonuniform/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, O]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSHRUN_asimdshf_N" []
                 "SQSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[X], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "8H" [[O, O, O, I]] Nothing,
                           TableRow "4S" [[O, O, I, X]] Nothing,
                           TableRow "2D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/nonuniform/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right-narrow/nonuniform/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"]),
     Right
       (Page "SQSUB_advsimd" []
          [(Class "SQSUB_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSUB_asisdsame_only" [] "SQSUB  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');"]),
           (Class "SQSUB_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQSUB_asimdsame_only" []
                 "SQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "SQXTN_advsimd" []
          [(Class "SQXTN_asisdmisc_N" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/extract/sat/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQXTN_asisdmisc_N" [] "SQXTN  <Vb><d>, <Va><n>"
                 [Symbol "<Vb>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Va>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "H" [[O, O]] Nothing, TableRow "S" [[O, I]] Nothing,
                           TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/extract/sat/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');"]),
           (Class "SQXTN_asimdmisc_N" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/extract/sat/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQXTN_asimdmisc_N" [] "SQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/extract/sat/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/extract/sat/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"]),
     Right
       (Page "SQXTUN_advsimd" []
          [(Class "SQXTUN_asisdmisc_N" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, O, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQXTUN_asisdmisc_N" [] "SQXTUN  <Vb><d>, <Va><n>"
                 [Symbol "<Vb>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Va>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "H" [[O, O]] Nothing, TableRow "S" [[O, I]] Nothing,
                           TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;"]),
           (Class "SQXTUN_asimdmisc_N" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, O, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SQXTUN_asimdmisc_N" [] "SQXTUN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = UnsignedSatQ(SInt(element), esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"]),
     Right
       (Page "SRHADD_advsimd" []
          [(Class "SRHADD_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/rounding"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SRHADD_asimdsame_only" []
                 "SRHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/rounding"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/rounding"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;\n\nV[d] = result;"]),
     Right
       (Page "SRI_advsimd" []
          [(Class "SRI_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-insert/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [O, I, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SRI_asisdshf_R" [] "SRI  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-insert/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);"]),
           (Class "SRI_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-insert/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [O, I, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SRI_asimdshf_R" [] "SRI  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-insert/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = (esize * 2) - UInt(immh:immb);"])]
          [Ps "aarch64/instrs/vector/shift/right-insert/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2 = V[d];\nbits(datasize) result;\nbits(esize) mask = LSR(Ones(esize), shift);\nbits(esize) shifted;\n\nfor e = 0 to elements-1\n    shifted = LSR(Elem[operand, e, esize], shift);\n    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;\nV[d] = result;"]),
     Right
       (Page "SRSHL_advsimd" []
          [(Class "SRSHL_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SRSHL_asisdsame_only" [] "SRSHL  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();"]),
           (Class "SRSHL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SRSHL_asimdsame_only" []
                 "SRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SRSHR_advsimd" []
          [(Class "SRSHR_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block (Just "o0") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SRSHR_asisdshf_R" [] "SRSHR  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"]),
           (Class "SRSHR_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block (Just "o0") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SRSHR_asimdshf_R" []
                 "SRSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SRSRA_advsimd" []
          [(Class "SRSRA_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block (Just "o0") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SRSRA_asisdshf_R" [] "SRSRA  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"]),
           (Class "SRSRA_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block (Just "o0") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SRSRA_asimdshf_R" []
                 "SRSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SSHL_advsimd" []
          [(Class "SSHL_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SSHL_asisdsame_only" [] "SSHL  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();"]),
           (Class "SSHL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SSHL_asimdsame_only" []
                 "SSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SSHLL_advsimd" ["SXTL_SSHLL_advsimd"]
          [(Class "SSHLL_asimdshf_L" Nothing
              (Diagram "aarch64/instrs/vector/shift/left-long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SSHLL_asimdshf_L" []
                 "SSHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "8H" [[O, O, O, I]] Nothing,
                           TableRow "4S" [[O, O, I, X]] Nothing,
                           TableRow "2D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[X], [I, X, X, X]] Nothing])),
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(UInt(immh:immb)-8)" [[O, O, O, I]] Nothing,
                           TableRow "(UInt(immh:immb)-16)" [[O, O, I, X]] Nothing,
                           TableRow "(UInt(immh:immb)-32)" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left-long" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/shift/left-long" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(datasize*2) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SSHR_advsimd" []
          [(Class "SSHR_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block (Just "o0") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SSHR_asisdshf_R" [] "SSHR  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"]),
           (Class "SSHR_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block (Just "o0") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SSHR_asimdshf_R" [] "SSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SSRA_advsimd" []
          [(Class "SSRA_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block (Just "o0") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SSRA_asisdshf_R" [] "SSRA  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"]),
           (Class "SSRA_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block (Just "o0") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SSRA_asimdshf_R" [] "SSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SSUBL_advsimd" []
          [(Class "SSUBL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SSUBL_asimddiff_L" []
                 "SSUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "SSUBW_advsimd" []
          [(Class "SSUBW_asimddiff_W" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SSUBW_asimddiff_W" []
                 "SSUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "ST1_advsimd_mult" []
          [(Class "as_no_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [X, X, I, X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST1_asisdlse_R1_1v" [("opcode", BlockEq [O, I, I, I])]
                 "ST1  { <Vt>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST1_asisdlse_R2_2v" [("opcode", BlockEq [I, O, I, O])]
                 "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST1_asisdlse_R3_3v" [("opcode", BlockEq [O, I, I, O])]
                 "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST1_asisdlse_R4_4v" [("opcode", BlockEq [O, O, I, O])]
                 "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, I]),
                  Block (Just "L") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [X, X, I, X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST1_asisdlsep_I1_i1"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I, I])]
                 "ST1  { <Vt>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#8" [[O]] Nothing, TableRow "#16" [[I]] Nothing]))],
               Encoding "ST1_asisdlsep_R1_r1"
                 [("Rm", BlockNeq [I, I, I, I, I]),
                  ("opcode", BlockEq [O, I, I, I])]
                 "ST1  { <Vt>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST1_asisdlsep_I2_i2"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I, O])]
                 "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#16" [[O]] Nothing, TableRow "#32" [[I]] Nothing]))],
               Encoding "ST1_asisdlsep_R2_r2"
                 [("Rm", BlockNeq [I, I, I, I, I]),
                  ("opcode", BlockEq [I, O, I, O])]
                 "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST1_asisdlsep_I3_i3"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I, O])]
                 "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#24" [[O]] Nothing, TableRow "#48" [[I]] Nothing]))],
               Encoding "ST1_asisdlsep_R3_r3"
                 [("Rm", BlockNeq [I, I, I, I, I]),
                  ("opcode", BlockEq [O, I, I, O])]
                 "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST1_asisdlsep_I4_i4"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, O, I, O])]
                 "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#32" [[O]] Nothing, TableRow "#64" [[I]] Nothing]))],
               Encoding "ST1_asisdlsep_R4_r4"
                 [("Rm", BlockNeq [I, I, I, I, I]),
                  ("opcode", BlockEq [O, O, I, O])]
                 "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "1D" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/post-inc"
               (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/multiple/no-wb"
             (Just PsPostDecode)
             "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UnallocatedEncoding();\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then ReservedValue();",
           Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "ST1_advsimd_sngl" []
          [(Class "as_no_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [O]), Block (Just "R") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [X, X, O]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST1_asisdlso_B1_1b" [("opcode", BlockEq [O, O, O])]
                 "ST1  { <Vt>.B }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST1_asisdlso_H1_1h"
                 [("opcode", BlockEq [O, I, O]), ("size", BlockEq [X, O])]
                 "ST1  { <Vt>.H }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST1_asisdlso_S1_1s"
                 [("opcode", BlockEq [I, O, O]), ("size", BlockEq [O, O])]
                 "ST1  { <Vt>.S }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST1_asisdlso_D1_1d"
                 [("opcode", BlockEq [I, O, O]), ("S", BlockEq [O]),
                  ("size", BlockEq [O, I])]
                 "ST1  { <Vt>.D }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [O]), Block (Just "R") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [X, X, O]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST1_asisdlsop_B1_i1b"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, O, O])]
                 "ST1  { <Vt>.B }[<index>], [<Xn|SP>], #1"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST1_asisdlsop_BX1_r1b"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, O, O])]
                 "ST1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST1_asisdlsop_H1_i1h"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, O]),
                  ("size", BlockEq [X, O])]
                 "ST1  { <Vt>.H }[<index>], [<Xn|SP>], #2"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST1_asisdlsop_HX1_r1h"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, I, O]),
                  ("size", BlockEq [X, O])]
                 "ST1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST1_asisdlsop_S1_i1s"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("size", BlockEq [O, O])]
                 "ST1  { <Vt>.S }[<index>], [<Xn|SP>], #4"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST1_asisdlsop_SX1_r1s"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("size", BlockEq [O, O])]
                 "ST1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST1_asisdlsop_D1_i1d"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "ST1  { <Vt>.D }[<index>], [<Xn|SP>], #8"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST1_asisdlsop_DX1_r1d"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "ST1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "ST2_advsimd_mult" []
          [(Class "ST2_asisdlse_R2" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST2_asisdlse_R2" []
                 "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, I]),
                  Block (Just "L") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST2_asisdlsep_I2_i" [("Rm", BlockEq [I, I, I, I, I])]
                 "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#16" [[O]] Nothing, TableRow "#32" [[I]] Nothing]))],
               Encoding "ST2_asisdlsep_R2_r" [("Rm", BlockNeq [I, I, I, I, I])]
                 "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/post-inc"
               (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/multiple/no-wb"
             (Just PsPostDecode)
             "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UnallocatedEncoding();\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then ReservedValue();",
           Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "ST2_advsimd_sngl" []
          [(Class "as_no_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [O]), Block (Just "R") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [X, X, O]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST2_asisdlso_B2_2b" [("opcode", BlockEq [O, O, O])]
                 "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST2_asisdlso_H2_2h"
                 [("opcode", BlockEq [O, I, O]), ("size", BlockEq [X, O])]
                 "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST2_asisdlso_S2_2s"
                 [("opcode", BlockEq [I, O, O]), ("size", BlockEq [O, O])]
                 "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST2_asisdlso_D2_2d"
                 [("opcode", BlockEq [I, O, O]), ("S", BlockEq [O]),
                  ("size", BlockEq [O, I])]
                 "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [O]), Block (Just "R") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [X, X, O]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST2_asisdlsop_B2_i2b"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, O, O])]
                 "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST2_asisdlsop_BX2_r2b"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, O, O])]
                 "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST2_asisdlsop_H2_i2h"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, O]),
                  ("size", BlockEq [X, O])]
                 "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST2_asisdlsop_HX2_r2h"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, I, O]),
                  ("size", BlockEq [X, O])]
                 "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST2_asisdlsop_S2_i2s"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("size", BlockEq [O, O])]
                 "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST2_asisdlsop_SX2_r2s"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("size", BlockEq [O, O])]
                 "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST2_asisdlsop_D2_i2d"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST2_asisdlsop_DX2_r2d"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, O]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "ST3_advsimd_mult" []
          [(Class "ST3_asisdlse_R3" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, I, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST3_asisdlse_R3" []
                 "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, I]),
                  Block (Just "L") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, I, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST3_asisdlsep_I3_i" [("Rm", BlockEq [I, I, I, I, I])]
                 "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#24" [[O]] Nothing, TableRow "#48" [[I]] Nothing]))],
               Encoding "ST3_asisdlsep_R3_r" [("Rm", BlockNeq [I, I, I, I, I])]
                 "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/post-inc"
               (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/multiple/no-wb"
             (Just PsPostDecode)
             "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UnallocatedEncoding();\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then ReservedValue();",
           Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "ST3_advsimd_sngl" []
          [(Class "as_no_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [O]), Block (Just "R") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [X, X, I]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST3_asisdlso_B3_3b" [("opcode", BlockEq [O, O, I])]
                 "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST3_asisdlso_H3_3h"
                 [("opcode", BlockEq [O, I, I]), ("size", BlockEq [X, O])]
                 "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST3_asisdlso_S3_3s"
                 [("opcode", BlockEq [I, O, I]), ("size", BlockEq [O, O])]
                 "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST3_asisdlso_D3_3d"
                 [("opcode", BlockEq [I, O, I]), ("S", BlockEq [O]),
                  ("size", BlockEq [O, I])]
                 "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [O]), Block (Just "R") (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [X, X, I]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST3_asisdlsop_B3_i3b"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, O, I])]
                 "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST3_asisdlsop_BX3_r3b"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, O, I])]
                 "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST3_asisdlsop_H3_i3h"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I]),
                  ("size", BlockEq [X, O])]
                 "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST3_asisdlsop_HX3_r3h"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I]),
                  ("size", BlockEq [X, O])]
                 "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST3_asisdlsop_S3_i3s"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("size", BlockEq [O, O])]
                 "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST3_asisdlsop_SX3_r3s"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("size", BlockEq [O, O])]
                 "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q:S" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST3_asisdlsop_D3_i3d"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST3_asisdlsop_DX3_r3d"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<index>" "Q" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "ST4_advsimd_mult" []
          [(Class "ST4_asisdlse_R4" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, O]),
                  Block (Just "L") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST4_asisdlse_R4" []
                 "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/multiple/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, O, I]),
                  Block (Just "L") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST4_asisdlsep_I4_i" [("Rm", BlockEq [I, I, I, I, I])]
                 "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<imm>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "#32" [[O]] Nothing, TableRow "#64" [[I]] Nothing]))],
               Encoding "ST4_asisdlsep_R4_r" [("Rm", BlockNeq [I, I, I, I, I])]
                 "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vt2>" "Rt" Nothing, Symbol "<Vt3>" "Rt" Nothing,
                  Symbol "<Vt4>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/multiple/post-inc"
               (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/multiple/no-wb"
             (Just PsPostDecode)
             "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\n\ninteger rpt;    // number of iterations\ninteger selem;  // structure elements \n\ncase opcode of\n    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)\n    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)\n    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)\n    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)\n    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)\n    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)\n    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)\n    otherwise UnallocatedEncoding();\n\n// .1D format only permitted with LD1 & ST1\nif size:Q == '110' && selem != 1 then ReservedValue();",
           Ps "aarch64/instrs/memory/vector/multiple/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "ST4_advsimd_sngl" []
          [(Class "as_no_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/no-wb"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, O]),
                  Block (Just "L") (BlockEq [O]), Block (Just "R") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [X, X, I]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST4_asisdlso_B4_4b" [("opcode", BlockEq [O, O, I])]
                 "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST4_asisdlso_H4_4h"
                 [("opcode", BlockEq [O, I, I]), ("size", BlockEq [X, O])]
                 "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST4_asisdlso_S4_4s"
                 [("opcode", BlockEq [I, O, I]), ("size", BlockEq [O, O])]
                 "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST4_asisdlso_D4_4d"
                 [("opcode", BlockEq [I, O, I]), ("S", BlockEq [O]),
                  ("size", BlockEq [O, I])]
                 "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = integer UNKNOWN;\nboolean wback = FALSE;"]),
           (Class "as_post_index" Nothing
              (Diagram "aarch64/instrs/memory/vector/single/post-inc"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, O, I, I]),
                  Block (Just "L") (BlockEq [O]), Block (Just "R") (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [X, X, I]),
                  Block (Just "S") (BlockEq [X]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "ST4_asisdlsop_B4_i4b"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, O, I])]
                 "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST4_asisdlsop_BX4_r4b"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, O, I])]
                 "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST4_asisdlsop_H4_i4h"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I]),
                  ("size", BlockEq [X, O])]
                 "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST4_asisdlsop_HX4_r4h"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [O, I, I]),
                  ("size", BlockEq [X, O])]
                 "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S:size" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST4_asisdlsop_S4_i4s"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("size", BlockEq [O, O])]
                 "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST4_asisdlsop_SX4_r4s"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("size", BlockEq [O, O])]
                 "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q:S" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing],
               Encoding "ST4_asisdlsop_D4_i4d"
                 [("Rm", BlockEq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing],
               Encoding "ST4_asisdlsop_DX4_r4d"
                 [("Rm", BlockNeq [I, I, I, I, I]), ("opcode", BlockEq [I, O, I]),
                  ("S", BlockEq [O]), ("size", BlockEq [O, I])]
                 "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>"
                 [Symbol "<Vt>" "Rt" Nothing, Symbol "<Vt2>" "Rt" Nothing,
                  Symbol "<Vt3>" "Rt" Nothing, Symbol "<Vt4>" "Rt" Nothing,
                  Symbol "<index>" "Q" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/memory/vector/single/post-inc" (Just PsDecode)
               "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;"])]
          [Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsPostDecode)
             "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\n\ncase scale of\n    when 3\n        // load and replicate\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         // B[0-15]\n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      // H[0-7]\n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          // S[0-3]\n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            // D[0-1]\n            scale = 3;\n\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;",
           Ps "aarch64/instrs/memory/vector/single/no-wb" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;"]),
     Right
       (Page "STNP_fpsimd" []
          [(Class "signed_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/pair/simdfp/no-alloc"
                 [Block (Just "opc") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STNP_S_ldstnapair_offs" [("opc", BlockEq [O, O])]
                 "STNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<St1>" "Rt" Nothing, Symbol "<St2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STNP_D_ldstnapair_offs" [("opc", BlockEq [O, I])]
                 "STNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Dt1>" "Rt" Nothing, Symbol "<Dt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STNP_Q_ldstnapair_offs" [("opc", BlockEq [I, O])]
                 "STNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Qt1>" "Rt" Nothing, Symbol "<Qt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/simdfp/no-alloc" (Just PsDecode)
               "boolean wback  = FALSE;\nboolean postindex = FALSE;"])]
          [Ps "aarch64/instrs/memory/pair/simdfp/no-alloc"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VECSTREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);",
           Ps "aarch64/instrs/memory/pair/simdfp/no-alloc" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        V[t]  = data1;\n        V[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STP_fpsimd" []
          [(Class "post_indexed" Nothing
              (Diagram "aarch64/instrs/memory/pair/simdfp/post-idx"
                 [Block (Just "opc") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O, I]), Block (Just "L") (BlockEq [O]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STP_S_ldstpair_post" [("opc", BlockEq [O, O])]
                 "STP  <St1>, <St2>, [<Xn|SP>], #<imm>"
                 [Symbol "<St1>" "Rt" Nothing, Symbol "<St2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STP_D_ldstpair_post" [("opc", BlockEq [O, I])]
                 "STP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>"
                 [Symbol "<Dt1>" "Rt" Nothing, Symbol "<Dt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STP_Q_ldstpair_post" [("opc", BlockEq [I, O])]
                 "STP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>"
                 [Symbol "<Qt1>" "Rt" Nothing, Symbol "<Qt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/simdfp/post-idx" (Just PsDecode)
               "boolean wback  = TRUE;\nboolean postindex = TRUE;"]),
           (Class "pre_indexed" Nothing
              (Diagram "aarch64/instrs/memory/pair/simdfp/pre-idx"
                 [Block (Just "opc") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "L") (BlockEq [O]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STP_S_ldstpair_pre" [("opc", BlockEq [O, O])]
                 "STP  <St1>, <St2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<St1>" "Rt" Nothing, Symbol "<St2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STP_D_ldstpair_pre" [("opc", BlockEq [O, I])]
                 "STP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<Dt1>" "Rt" Nothing, Symbol "<Dt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STP_Q_ldstpair_pre" [("opc", BlockEq [I, O])]
                 "STP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!"
                 [Symbol "<Qt1>" "Rt" Nothing, Symbol "<Qt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/simdfp/pre-idx" (Just PsDecode)
               "boolean wback  = TRUE;\nboolean postindex = FALSE;"]),
           (Class "signed_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/pair/simdfp/offset"
                 [Block (Just "opc") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "L") (BlockEq [O]),
                  Block (Just "imm7") (BlockEq [X, X, X, X, X, X, X]),
                  Block (Just "Rt2") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STP_S_ldstpair_off" [("opc", BlockEq [O, O])]
                 "STP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<St1>" "Rt" Nothing, Symbol "<St2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STP_D_ldstpair_off" [("opc", BlockEq [O, I])]
                 "STP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Dt1>" "Rt" Nothing, Symbol "<Dt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing],
               Encoding "STP_Q_ldstpair_off" [("opc", BlockEq [I, O])]
                 "STP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
                 [Symbol "<Qt1>" "Rt" Nothing, Symbol "<Qt2>" "Rt2" Nothing,
                  Symbol "<Xn|SP>" "Rn" Nothing, Symbol "<imm>" "imm7" Nothing]],
            [Ps "aarch64/instrs/memory/pair/simdfp/offset" (Just PsDecode)
               "boolean wback  = FALSE;\nboolean postindex = FALSE;"])]
          [Ps "aarch64/instrs/memory/pair/simdfp/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VEC;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);",
           Ps "aarch64/instrs/memory/pair/simdfp/post-idx" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\n\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN\n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        V[t]  = data1;\n        V[t2] = data2;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STR_imm_fpsimd" []
          [(Class "post_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx"
                 [Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [X, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STR_B_ldst_immpost"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, O])]
                 "STR  <Bt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STR_H_ldst_immpost"
                 [("size", BlockEq [O, I]), ("opc", BlockEq [O, O])]
                 "STR  <Ht>, [<Xn|SP>], #<simm>"
                 [Symbol "<Ht>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STR_S_ldst_immpost"
                 [("size", BlockEq [I, O]), ("opc", BlockEq [O, O])]
                 "STR  <St>, [<Xn|SP>], #<simm>"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STR_D_ldst_immpost"
                 [("size", BlockEq [I, I]), ("opc", BlockEq [O, O])]
                 "STR  <Dt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STR_Q_ldst_immpost"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [I, O])]
                 "STR  <Qt>, [<Xn|SP>], #<simm>"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "pre_indexed" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/simdfp/immediate/signed/pre-idx"
                 [Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [X, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [I, I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STR_B_ldst_immpre"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, O])]
                 "STR  <Bt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STR_H_ldst_immpre"
                 [("size", BlockEq [O, I]), ("opc", BlockEq [O, O])]
                 "STR  <Ht>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Ht>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STR_S_ldst_immpre"
                 [("size", BlockEq [I, O]), ("opc", BlockEq [O, O])]
                 "STR  <St>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STR_D_ldst_immpre"
                 [("size", BlockEq [I, I]), ("opc", BlockEq [O, O])]
                 "STR  <Dt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STR_Q_ldst_immpre"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [I, O])]
                 "STR  <Qt>, [<Xn|SP>, #<simm>]!"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps "aarch64/instrs/memory/single/simdfp/immediate/signed/pre-idx"
               (Just PsDecode)
               "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);"]),
           (Class "unsigned_scaled_offset" Nothing
              (Diagram "aarch64/instrs/memory/single/simdfp/immediate/unsigned"
                 [Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I]),
                  Block (Just "opc") (BlockEq [X, O]),
                  Block (Just "imm12")
                    (BlockEq [X, X, X, X, X, X, X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STR_B_ldst_pos"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, O])]
                 "STR  <Bt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "STR_H_ldst_pos"
                 [("size", BlockEq [O, I]), ("opc", BlockEq [O, O])]
                 "STR  <Ht>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Ht>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "STR_S_ldst_pos"
                 [("size", BlockEq [I, O]), ("opc", BlockEq [O, O])]
                 "STR  <St>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "STR_D_ldst_pos"
                 [("size", BlockEq [I, I]), ("opc", BlockEq [O, O])]
                 "STR  <Dt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing],
               Encoding "STR_Q_ldst_pos"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [I, O])]
                 "STR  <Qt>, [<Xn|SP>{, #<pimm>}]"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<pimm>" "imm12" Nothing]],
            [Ps "aarch64/instrs/memory/single/simdfp/immediate/unsigned"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);"])]
          [Ps "aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STR_reg_fpsimd" []
          [(Class "fpsimd" Nothing
              (Diagram "aarch64/instrs/memory/single/simdfp/register"
                 [Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [X, O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "option") (BlockEq [X, X, X]),
                  Block (Just "S") (BlockEq [X]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STR_B_ldst_regoff"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, O]),
                  ("option", BlockNeq [O, I, I])]
                 "STR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S" Nothing],
               Encoding "STR_BL_ldst_regoff"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, O]),
                  ("option", BlockEq [O, I, I])]
                 "STR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Xm>" "Rm" Nothing, Symbol "<amount>" "S" Nothing],
               Encoding "STR_H_ldst_regoff"
                 [("size", BlockEq [O, I]), ("opc", BlockEq [O, O])]
                 "STR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Ht>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#1" [[I]] Nothing]))],
               Encoding "STR_S_ldst_regoff"
                 [("size", BlockEq [I, O]), ("opc", BlockEq [O, O])]
                 "STR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#2" [[I]] Nothing]))],
               Encoding "STR_D_ldst_regoff"
                 [("size", BlockEq [I, I]), ("opc", BlockEq [O, O])]
                 "STR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#3" [[I]] Nothing]))],
               Encoding "STR_Q_ldst_regoff"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [I, O])]
                 "STR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<Wm>" "Rm" Nothing, Symbol "<Xm>" "Rm" Nothing,
                  Symbol "<extend>" "option"
                    (Just
                       (Table ["option"]
                          [TableRow "UXTW" [[O, I, O]] Nothing,
                           TableRow "LSL" [[O, I, I]] Nothing,
                           TableRow "SXTW" [[I, I, O]] Nothing,
                           TableRow "SXTX" [[I, I, I]] Nothing])),
                  Symbol "<amount>" "S"
                    (Just
                       (Table ["S"]
                          [TableRow "#0" [[O]] Nothing, TableRow "#4" [[I]] Nothing]))]],
            [Ps "aarch64/instrs/memory/single/simdfp/register" (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nif option<1> == '0' then UnallocatedEncoding(); // sub-word index\nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;"])]
          [Ps "aarch64/instrs/memory/single/simdfp/register"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;",
           Ps "aarch64/instrs/memory/single/simdfp/register" (Just PsExecute)
             "bits(64) offset = ExtendReg(m, extend_type, shift);\nCheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "STUR_fpsimd" []
          [(Class "base_plus_offset" Nothing
              (Diagram
                 "aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal"
                 [Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, I]), Block (Just "V") (BlockEq [I]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "opc") (BlockEq [X, O]), Block Nothing (BlockEq [O]),
                  Block (Just "imm9") (BlockEq [X, X, X, X, X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rt") (BlockEq [X, X, X, X, X])])
              [Encoding "STUR_B_ldst_unscaled"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [O, O])]
                 "STUR  <Bt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Bt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STUR_H_ldst_unscaled"
                 [("size", BlockEq [O, I]), ("opc", BlockEq [O, O])]
                 "STUR  <Ht>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Ht>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STUR_S_ldst_unscaled"
                 [("size", BlockEq [I, O]), ("opc", BlockEq [O, O])]
                 "STUR  <St>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<St>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STUR_D_ldst_unscaled"
                 [("size", BlockEq [I, I]), ("opc", BlockEq [O, O])]
                 "STUR  <Dt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Dt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing],
               Encoding "STUR_Q_ldst_unscaled"
                 [("size", BlockEq [O, O]), ("opc", BlockEq [I, O])]
                 "STUR  <Qt>, [<Xn|SP>{, #<simm>}]"
                 [Symbol "<Qt>" "Rt" Nothing, Symbol "<Xn|SP>" "Rn" Nothing,
                  Symbol "<simm>" "imm9" Nothing]],
            [Ps
               "aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal"
               (Just PsDecode)
               "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);"])]
          [Ps
             "aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal"
             (Just PsPostDecode)
             "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;",
           Ps
             "aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;"]),
     Right
       (Page "SUB_advsimd" []
          [(Class "SUB_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUB_asisdsame_only" [] "SUB  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (U == '1');"]),
           (Class "SUB_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUB_asimdsame_only" []
                 "SUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then\n        Elem[result, e, esize] = element1 - element2;\n    else\n        Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;"]),
     Right
       (Page "SUBHN_advsimd" []
          [(Class "SUBHN_asimddiff_N" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "o1") (BlockEq [I]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUBHN_asimddiff_N" []
                 "SUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;"]),
     Right
       (Page "SUQADD_advsimd" []
          [(Class "SUQADD_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/add/saturating/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUQADD_asisdmisc_R" [] "SUQADD  <V><d>, <V><n>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/add/saturating/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');"]),
           (Class "SUQADD_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/add/saturating/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "SUQADD_asimdmisc_R" [] "SUQADD  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/add/saturating/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/add/saturating/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(datasize) operand2 = V[d];\ninteger op1;\ninteger op2;\nboolean sat;\n\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, e, esize], !unsigned);\n    op2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);\n    if sat then FPSR.QC = '1';\nV[d] = result;"]),
     Left
       (AliasPage "SXTL_SSHLL_advsimd" "SSHLL_advsimd"
          (Class "SSHLL_asimdshf_L" Nothing
             (Diagram "aarch64/instrs/vector/shift/left-long"
                [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                 Block (Just "U") (BlockEq [O]),
                 Block Nothing (BlockEq [O, I, I, I, I, O]),
                 Block (Just "immh") (BlockNeq [O, O, O, O]),
                 Block (Just "immb") (BlockEq [O, O, O]),
                 Block (Just "opcode") (BlockEq [I, O, I, O, O]),
                 Block Nothing (BlockEq [I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "SXTL_SSHLL_asimdshf_L" []
                "SXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"
                [Symbol "2" "Q"
                   (Just
                      (Table ["Q"]
                         [TableRow "[absent]" [[O]] Nothing,
                          TableRow "[present]" [[I]] Nothing])),
                 Symbol "<Vd>" "Rd" Nothing,
                 Symbol "<Ta>" "immh"
                   (Just
                      (Table ["immh"]
                         [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                            Nothing,
                          TableRow "8H" [[O, O, O, I]] Nothing,
                          TableRow "4S" [[O, O, I, X]] Nothing,
                          TableRow "2D" [[O, I, X, X]] Nothing,
                          TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                 Symbol "<Vn>" "Rn" Nothing,
                 Symbol "<Tb>" "immh:Q"
                   (Just
                      (Table ["Q", "immh"]
                         [TableRow "SEE Advanced SIMD modified immediate"
                            [[X], [O, O, O, O]]
                            Nothing,
                          TableRow "8B" [[O], [O, O, O, I]] Nothing,
                          TableRow "16B" [[I], [O, O, O, I]] Nothing,
                          TableRow "4H" [[O], [O, O, I, X]] Nothing,
                          TableRow "8H" [[I], [O, O, I, X]] Nothing,
                          TableRow "2S" [[O], [O, I, X, X]] Nothing,
                          TableRow "4S" [[I], [O, I, X, X]] Nothing,
                          TableRow "RESERVED" [[X], [I, X, X, X]] Nothing]))]])),
     Right
       (Page "TBL_advsimd" []
          [(Class "advsimd" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/table"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, I, O]),
                  Block (Just "op2") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "len") (BlockEq [X, X]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "TBL_asimdtbl_L2_2" [("len", BlockEq [O, I])]
                 "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vn+1>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing],
               Encoding "TBL_asimdtbl_L3_3" [("len", BlockEq [I, O])]
                 "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vn+1>" "Rn" Nothing,
                  Symbol "<Vn+2>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing],
               Encoding "TBL_asimdtbl_L4_4" [("len", BlockEq [I, I])]
                 "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vn+1>" "Rn" Nothing,
                  Symbol "<Vn+2>" "Rn" Nothing, Symbol "<Vn+3>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing],
               Encoding "TBL_asimdtbl_L1_1" [("len", BlockEq [O, O])]
                 "TBL  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/vector/table" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\ninteger regs = UInt(len) + 1;\nboolean is_tbl = (op == '0');"])]
          [Ps "aarch64/instrs/vector/transfer/vector/table" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) indices = V[m];\nbits(128*regs) table = Zeros();\nbits(datasize) result;\ninteger index;\ninteger i;\n\n// Create table from registers\nfor i = 0 to regs - 1\n    table<128*i+127:128*i> = V[n];\n    n = (n + 1) MOD 32;\n\nresult = if is_tbl then Zeros() else V[d];\nfor i = 0 to elements - 1\n    index = UInt(Elem[indices, i, 8]);\n    if index < 16 * regs then\n        Elem[result, i, 8] = Elem[table, index, 8];\n\nV[d] = result;"]),
     Right
       (Page "TBX_advsimd" []
          [(Class "advsimd" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/table"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, I, O]),
                  Block (Just "op2") (BlockEq [O, O]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "len") (BlockEq [X, X]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "TBX_asimdtbl_L2_2" [("len", BlockEq [O, I])]
                 "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vn+1>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing],
               Encoding "TBX_asimdtbl_L3_3" [("len", BlockEq [I, O])]
                 "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vn+1>" "Rn" Nothing,
                  Symbol "<Vn+2>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing],
               Encoding "TBX_asimdtbl_L4_4" [("len", BlockEq [I, I])]
                 "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vn+1>" "Rn" Nothing,
                  Symbol "<Vn+2>" "Rn" Nothing, Symbol "<Vn+3>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing],
               Encoding "TBX_asimdtbl_L1_1" [("len", BlockEq [O, O])]
                 "TBX  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/vector/table" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\ninteger regs = UInt(len) + 1;\nboolean is_tbl = (op == '0');"])]
          [Ps "aarch64/instrs/vector/transfer/vector/table" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) indices = V[m];\nbits(128*regs) table = Zeros();\nbits(datasize) result;\ninteger index;\ninteger i;\n\n// Create table from registers\nfor i = 0 to regs - 1\n    table<128*i+127:128*i> = V[n];\n    n = (n + 1) MOD 32;\n\nresult = if is_tbl then Zeros() else V[d];\nfor i = 0 to elements - 1\n    index = UInt(Elem[indices, i, 8]);\n    if index < 16 * regs then\n        Elem[result, i, 8] = Elem[table, index, 8];\n\nV[d] = result;"]),
     Right
       (Page "TRN1_advsimd" []
          [(Class "TRN1_asimdperm_only" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/permute/transpose"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [I, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "TRN1_asimdperm_only" []
                 "TRN1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/vector/permute/transpose"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;"])]
          [Ps "aarch64/instrs/vector/transfer/vector/permute/transpose"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger p;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];\n\nV[d] = result;"]),
     Right
       (Page "TRN2_advsimd" []
          [(Class "TRN2_asimdperm_only" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/permute/transpose"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [I, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "TRN2_asimdperm_only" []
                 "TRN2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/vector/permute/transpose"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;"])]
          [Ps "aarch64/instrs/vector/transfer/vector/permute/transpose"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger p;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];\n\nV[d] = result;"]),
     Right
       (Page "UABA_advsimd" []
          [(Class "UABA_asimdsame_only" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, I, I]),
                  Block (Just "ac") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UABA_asimdsame_only" []
                 "UABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"]),
     Right
       (Page "UABAL_advsimd" []
          [(Class "UABAL_asimddiff_L" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UABAL_asimddiff_L" []
                 "UABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"]),
     Right
       (Page "UABD_advsimd" []
          [(Class "UABD_asimdsame_only" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, I, I]),
                  Block (Just "ac") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UABD_asimdsame_only" []
                 "UABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/diff"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;"]),
     Right
       (Page "UABDL_advsimd" []
          [(Class "UABDL_asimddiff_L" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UABDL_asimddiff_L" []
                 "UABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/diff"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;"]),
     Right
       (Page "UADALP_advsimd" []
          [(Class "UADALP_asimdmisc_P" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [I, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UADALP_asimdmisc_P" [] "UADALP  <Vd>.<Ta>, <Vn>.<Tb>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "4H" [[O], [O, O]] Nothing,
                           TableRow "8H" [[I], [O, O]] Nothing,
                           TableRow "2S" [[O], [O, I]] Nothing,
                           TableRow "4S" [[I], [O, I]] Nothing,
                           TableRow "1D" [[O], [I, O]] Nothing,
                           TableRow "2D" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n\nV[d] = result;"]),
     Right
       (Page "UADDL_advsimd" []
          [(Class "UADDL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UADDL_asimddiff_L" []
                 "UADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "UADDLP_advsimd" []
          [(Class "UADDLP_asimdmisc_P" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block Nothing (BlockEq [O, O]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [I, O]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UADDLP_asimdmisc_P" [] "UADDLP  <Vd>.<Ta>, <Vn>.<Tb>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "4H" [[O], [O, O]] Nothing,
                           TableRow "8H" [[I], [O, O]] Nothing,
                           TableRow "2S" [[O], [O, I]] Nothing,
                           TableRow "4S" [[I], [O, I]] Nothing,
                           TableRow "1D" [[O], [I, O]] Nothing,
                           TableRow "2D" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/add/pairwise"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n\nV[d] = result;"]),
     Right
       (Page "UADDLV_advsimd" []
          [(Class "UADDLV_asimdall_only" Nothing
              (Diagram "aarch64/instrs/vector/reduce/add-long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UADDLV_asimdall_only" [] "UADDLV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "H" [[O, O]] Nothing, TableRow "S" [[O, I]] Nothing,
                           TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "RESERVED" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/add-long" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/reduce/add-long" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger sum;\n\nsum = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    sum = sum + Int(Elem[operand, e, esize], unsigned);\n\nV[d] = sum<2*esize-1:0>;"]),
     Right
       (Page "UADDW_advsimd" []
          [(Class "UADDW_asimddiff_W" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UADDW_asimddiff_W" []
                 "UADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "UCVTF_float_fix" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/fix"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "rmode") (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I]),
                  Block (Just "scale") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UCVTF_H32_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "UCVTF  <Hd>, <Wn>, #<fbits>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "UCVTF_S32_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "UCVTF  <Sd>, <Wn>, #<fbits>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "UCVTF_D32_float2fix"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "UCVTF  <Dd>, <Wn>, #<fbits>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "UCVTF_H64_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "UCVTF  <Hd>, <Xn>, #<fbits>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "UCVTF_S64_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "UCVTF  <Sd>, <Xn>, #<fbits>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing],
               Encoding "UCVTF_D64_float2fix"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "UCVTF  <Dd>, <Xn>, #<fbits>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing,
                  Symbol "<fbits>" "scale" Nothing]],
            [Ps "aarch64/instrs/float/convert/fix" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\n\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\n\ncase opcode<2:1>:rmode of\n    when '00 11'        // FCVTZ\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/fix" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;"]),
     Right
       (Page "UCVTF_float_int" []
          [(Class "float" Nothing
              (Diagram "aarch64/instrs/float/convert/int"
                 [Block (Just "sf") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "type") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "rmode") (BlockEq [O, O]),
                  Block (Just "opcode") (BlockEq [O, I, I]),
                  Block Nothing (BlockEq [O, O, O, O, O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UCVTF_H32_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [I, I])]
                 "UCVTF  <Hd>, <Wn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "UCVTF_S32_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, O])]
                 "UCVTF  <Sd>, <Wn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "UCVTF_D32_float2int"
                 [("sf", BlockEq [O]), ("type", BlockEq [O, I])]
                 "UCVTF  <Dd>, <Wn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Wn>" "Rn" Nothing],
               Encoding "UCVTF_H64_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [I, I])]
                 "UCVTF  <Hd>, <Xn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing],
               Encoding "UCVTF_S64_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, O])]
                 "UCVTF  <Sd>, <Xn>"
                 [Symbol "<Sd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing],
               Encoding "UCVTF_D64_float2int"
                 [("sf", BlockEq [I]), ("type", BlockEq [O, I])]
                 "UCVTF  <Dd>, <Xn>"
                 [Symbol "<Dd>" "Rd" Nothing, Symbol "<Xn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/float/convert/int" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\n\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n\ncase opcode<2:1>:rmode of\n    when '00 xx'        // FCVT[NPMZ][US]\n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '01 00'        // [US]CVTF\n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '10 00'        // FCVTA[US]\n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '11 00'        // FMOV\n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '11 01'        // FMOV D[1]\n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; // size of D[1] is 64\n    when '11 11'       // FJCVTZS\n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();"])]
          [Ps "aarch64/instrs/float/convert/int" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\n\nbits(fltsize) fltval;\nbits(intsize) intval;\n\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);"]),
     Right
       (Page "UCVTF_advsimd_fix" []
          [(Class "UCVTF_asisdshf_C" Nothing
              (Diagram "aarch64/instrs/vector/shift/conv/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UCVTF_asisdshf_C" [] "UCVTF  <V><d>, <V><n>, #<fbits>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, X]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<fbits>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, X]] Nothing,
                           TableRow "(32-Uint(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/conv/int/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);"]),
           (Class "UCVTF_asimdshf_C" Nothing
              (Diagram "aarch64/instrs/vector/shift/conv/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UCVTF_asimdshf_C" []
                 "UCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "RESERVED" [[X], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<fbits>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "RESERVED" [[O, O, O, I]] Nothing,
                           TableRow "(32-Uint(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/conv/int/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);"])]
          [Ps "aarch64/instrs/vector/shift/conv/int/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "UCVTF_advsimd_int" []
          [(Class "UCVTF_asisdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UCVTF_asisdmiscfp16_R" [] "UCVTF  <Hd>, <Hn>"
                 [Symbol "<Hd>" "Rd" Nothing, Symbol "<Hn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/sisd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');"]),
           (Class "UCVTF_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/int/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UCVTF_asisdmisc_R" [] "UCVTF  <V><d>, <V><n>"
                 [Symbol "<V>" "sz"
                    (Just
                       (Table ["sz"]
                          [TableRow "S" [[O]] Nothing, TableRow "D" [[I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/conv/int/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');"]),
           (Class "UCVTF_asimdmiscfp16_R" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "a") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I, I, I, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UCVTF_asimdmiscfp16_R" [] "UCVTF  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "4H" [[O]] Nothing, TableRow "8H" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/simd"
               (Just PsDecode)
               "if !HaveFP16Ext() then UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"]),
           (Class "UCVTF_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/float/conv/int/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [O]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UCVTF_asimdmisc_R" [] "UCVTF  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[O], [I]] Nothing,
                           TableRow "2D" [[I], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/float/conv/int/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nFPRounding rounding = FPRoundingMode(FPCR);\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);\n\nV[d] = result;"]),
     Right
       (Page "UDOT_advsimd_elt" []
          [(Class "UDOT_asimdelem_D" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/arithmetic/binary/element/dotp"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, I, I, O]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UDOT_asimdelem_D" []
                 "UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vm>" "M:Rm" Nothing, Symbol "<index>" "H:L" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/dotp"
               (Just PsDecode)
               "if !HaveDOTPExt() then UNDEFINED;\nif size  != '10' then ReservedValue();\nboolean signed = (U=='0');\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\ninteger index = UInt(H:L);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/dotp"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(datasize) result = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3\n        if signed then  \n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        res = res + element1 * element2; \n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nV[d] = result;"]),
     Right
       (Page "UDOT_advsimd_vec" []
          [(Class "UDOT_asimdsame2_D" (Just (ArchName "ARMv8.2"))
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/dotp"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "opcode") (BlockEq [O, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UDOT_asimdsame2_D" []
                 "UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "2S" [[O]] Nothing, TableRow "4S" [[I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "8B" [[O]] Nothing, TableRow "16B" [[I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/dotp"
               (Just PsDecode)
               "if !HaveDOTPExt() then UNDEFINED;\nif size!= '10' then ReservedValue();\nboolean signed = (U=='0');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/dotp"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nresult = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3 \n        if signed then\n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        res = res + element1 * element2; \n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nV[d] = result;"]),
     Right
       (Page "UHADD_advsimd" []
          [(Class "UHADD_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/truncating"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UHADD_asimdsame_only" []
                 "UHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/truncating"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/truncating"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    Elem[result, e, esize] = sum<esize:1>;\n\nV[d] = result;"]),
     Right
       (Page "UHSUB_advsimd" []
          [(Class "UHSUB_asimdsame_only" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/uniform/sub/int"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UHSUB_asimdsame_only" []
                 "UHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/int"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/sub/int"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    Elem[result, e, esize] = diff<esize:1>;\n\nV[d] = result;"]),
     Right
       (Page "UMAX_advsimd" []
          [(Class "UMAX_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMAX_asimdsame_only" []
                 "UMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "UMAXP_advsimd" []
          [(Class "UMAXP_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O, I, O]),
                  Block (Just "o1") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMAXP_asimdsame_only" []
                 "UMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "UMAXV_advsimd" []
          [(Class "UMAXV_asimdall_only" Nothing
              (Diagram "aarch64/instrs/vector/reduce/int-max"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [I, O, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMAXV_asimdall_only" [] "UMAXV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "RESERVED" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/int-max" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');"])]
          [Ps "aarch64/instrs/vector/reduce/int-max" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"]),
     Right
       (Page "UMIN_advsimd" []
          [(Class "UMIN_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMIN_asimdsame_only" []
                 "UMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "UMINP_advsimd" []
          [(Class "UMINP_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O, I, O]),
                  Block (Just "o1") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMINP_asimdsame_only" []
                 "UMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "UMINV_advsimd" []
          [(Class "UMINV_asimdall_only" Nothing
              (Diagram "aarch64/instrs/vector/reduce/int-max"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, I, O, O, O]),
                  Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [I, O, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMINV_asimdall_only" [] "UMINV  <V><d>, <Vn>.<T>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "RESERVED" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/reduce/int-max" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean min = (op == '1');"])]
          [Ps "aarch64/instrs/vector/reduce/int-max" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;"]),
     Right
       (Page "UMLAL_advsimd_elt" []
          [(Class "UMLAL_asimdelem_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [O]),
                  Block Nothing (BlockEq [I, O]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMLAL_asimdelem_L" []
                 "UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"]),
     Right
       (Page "UMLAL_advsimd_vec" []
          [(Class "UMLAL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]), Block (Just "o1") (BlockEq [O]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMLAL_asimddiff_L" []
                 "UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"]),
     Right
       (Page "UMLSL_advsimd_elt" []
          [(Class "UMLSL_asimdelem_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "o2") (BlockEq [I]),
                  Block Nothing (BlockEq [I, O]), Block (Just "H") (BlockEq [X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMLSL_asimdelem_L" []
                 "UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n\nV[d] = result;"]),
     Right
       (Page "UMLSL_advsimd_vec" []
          [(Class "UMLSL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [I, O]), Block (Just "o1") (BlockEq [I]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMLSL_asimddiff_L" []
                 "UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;"]),
     Right
       (Page "UMOV_advsimd" ["MOV_UMOV_advsimd"]
          [(Class "advsimd" Nothing
              (Diagram "aarch64/instrs/vector/transfer/integer/move/unsigned"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O, O, O, O]),
                  Block (Just "imm5") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]),
                  Block (Just "imm4<3:2>") (BlockEq [O, I]),
                  Block (Just "imm4<1>") (BlockEq [I]),
                  Block (Just "imm4<0>") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMOV_asimdins_W_w" [("Q", BlockEq [O])]
                 "UMOV  <Wd>, <Vn>.<Ts>[<index>]"
                 [Symbol "<Wd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ts>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, X, O, O, O]] Nothing,
                           TableRow "B" [[X, X, X, X, I]] Nothing,
                           TableRow "H" [[X, X, X, I, O]] Nothing,
                           TableRow "S" [[X, X, I, O, O]] Nothing])),
                  Symbol "<index>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, X, O, O, O]] Nothing,
                           TableRow "imm5<4:1>" [[X, X, X, X, I]] Nothing,
                           TableRow "imm5<4:2>" [[X, X, X, I, O]] Nothing,
                           TableRow "imm5<4:3>" [[X, X, I, O, O]] Nothing]))],
               Encoding "UMOV_asimdins_X_x"
                 [("Q", BlockEq [I]), ("imm5", BlockEq [X, I, O, O, O])]
                 "UMOV  <Xd>, <Vn>.<Ts>[<index>]"
                 [Symbol "<Xd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ts>" "imm5"
                    (Just
                       (Table ["imm5"]
                          [TableRow "RESERVED" [[X, O, O, O, O]] Nothing,
                           TableRow "RESERVED" [[X, X, X, X, I]] Nothing,
                           TableRow "RESERVED" [[X, X, X, I, O]] Nothing,
                           TableRow "RESERVED" [[X, X, I, O, O]] Nothing,
                           TableRow "D" [[X, I, O, O, O]] Nothing])),
                  Symbol "<index>" "imm5" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/integer/move/unsigned"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger size;\ncase Q:imm5 of\n    when '0xxxx1' size = 0;     // UMOV Wd, Vn.B\n    when '0xxx10' size = 1;     // UMOV Wd, Vn.H\n    when '0xx100' size = 2;     // UMOV Wd, Vn.S\n    when '1x1000' size = 3;     // UMOV Xd, Vn.D\n    otherwise     UnallocatedEncoding();\n\ninteger idxdsize = if imm5<4> == '1' then 128 else 64;\ninteger index = UInt(imm5<4:size+1>);\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 64 else 32;"])]
          [Ps "aarch64/instrs/vector/transfer/integer/move/unsigned"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\n\nX[d] = ZeroExtend(Elem[operand, index, esize], datasize);"]),
     Right
       (Page "UMULL_advsimd_elt" []
          [(Class "UMULL_asimdelem_L" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/binary/element/mul/long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block (Just "L") (BlockEq [X]), Block (Just "M") (BlockEq [X]),
                  Block (Just "Rm") (BlockEq [X, X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, O]),
                  Block (Just "H") (BlockEq [X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMULL_asimdelem_L" []
                 "UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "4S" [[O, I]] Nothing, TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "RESERVED" [[X], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "size:M:Rm"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "0:Rm" [[O, I]] Nothing, TableRow "M:Rm" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Ts>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H" [[O, I]] Nothing, TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<index>" "size:L:H:M"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, O]] Nothing,
                           TableRow "H:L:M" [[O, I]] Nothing, TableRow "H:L" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/long"
               (Just PsDecode)
               "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\n\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/element/mul/long"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\n\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = product;\n\nV[d] = result;"]),
     Right
       (Page "UMULL_advsimd_vec" []
          [(Class "UMULL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/mul/product"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode<3>") (BlockEq [I]),
                  Block (Just "opcode<2>") (BlockEq [I]),
                  Block (Just "opcode<1>") (BlockEq [O]),
                  Block (Just "opcode<0>") (BlockEq [O]),
                  Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UMULL_asimddiff_L" []
                 "UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/product"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/disparate/mul/product"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "UQADD_advsimd" []
          [(Class "UQADD_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQADD_asisdsame_only" [] "UQADD  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');"]),
           (Class "UQADD_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQADD_asimdsame_only" []
                 "UQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "UQRSHL_advsimd" []
          [(Class "UQRSHL_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [I]),
                  Block (Just "S") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQRSHL_asisdsame_only" []
                 "UQRSHL  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();"]),
           (Class "UQRSHL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [I]),
                  Block (Just "S") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQRSHL_asimdsame_only" []
                 "UQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "UQRSHRN_advsimd" []
          [(Class "UQRSHRN_asisdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, I]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQRSHRN_asisdshf_N" []
                 "UQRSHRN  <Vb><d>, <Va><n>, #<shift>"
                 [Symbol "<Vb>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "B" [[O, O, O, I]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Va>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "H" [[O, O, O, I]] Nothing,
                           TableRow "S" [[O, O, I, X]] Nothing,
                           TableRow "D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');"]),
           (Class "UQRSHRN_asimdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/uniform/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, I]),
                  Block (Just "op") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQRSHRN_asimdshf_N" []
                 "UQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[X], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "8H" [[O, O, O, I]] Nothing,
                           TableRow "4S" [[O, O, I, X]] Nothing,
                           TableRow "2D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"]),
     Right
       (Page "UQSHL_advsimd_imm" []
          [(Class "UQSHL_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/left-sat/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQSHL_asisdshf_R" [] "UQSHL  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "B" [[O, O, O, I]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "(UInt(immh:immb)-8)" [[O, O, O, I]] Nothing,
                           TableRow "(UInt(immh:immb)-16)" [[O, O, I, X]] Nothing,
                           TableRow "(UInt(immh:immb)-32)" [[O, I, X, X]] Nothing,
                           TableRow "(UInt(immh:immb)-64)" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left-sat/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;"]),
           (Class "UQSHL_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/left-sat/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, I, I]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQSHL_asimdshf_R" []
                 "UQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(UInt(immh:immb)-8)" [[O, O, O, I]] Nothing,
                           TableRow "(UInt(immh:immb)-16)" [[O, O, I, X]] Nothing,
                           TableRow "(UInt(immh:immb)-32)" [[O, I, X, X]] Nothing,
                           TableRow "(UInt(immh:immb)-64)" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left-sat/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;\n\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;"])]
          [Ps "aarch64/instrs/vector/shift/left-sat/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "UQSHL_advsimd_reg" []
          [(Class "UQSHL_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [O]),
                  Block (Just "S") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQSHL_asisdsame_only" [] "UQSHL  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();"]),
           (Class "UQSHL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [O]),
                  Block (Just "S") (BlockEq [I]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQSHL_asimdsame_only" []
                 "UQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "UQSHRN_advsimd" []
          [(Class "UQSHRN_asisdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, I]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQSHRN_asisdshf_N" []
                 "UQSHRN  <Vb><d>, <Va><n>, #<shift>"
                 [Symbol "<Vb>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "B" [[O, O, O, I]] Nothing,
                           TableRow "H" [[O, O, I, X]] Nothing,
                           TableRow "S" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Va>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "H" [[O, O, O, I]] Nothing,
                           TableRow "S" [[O, O, I, X]] Nothing,
                           TableRow "D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, O, O, O]] Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');"]),
           (Class "UQSHRN_asimdshf_N" Nothing
              (Diagram "aarch64/instrs/vector/shift/right-narrow/uniform/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [I, O, O, I]),
                  Block (Just "op") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQSHRN_asimdshf_N" []
                 "UQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[X], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "8H" [[O, O, O, I]] Nothing,
                           TableRow "4S" [[O, O, I, X]] Nothing,
                           TableRow "2D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right-narrow/uniform/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"]),
     Right
       (Page "UQSUB_advsimd" []
          [(Class "UQSUB_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQSUB_asisdsame_only" [] "UQSUB  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');"]),
           (Class "UQSUB_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, I, O, I]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQSUB_asimdsame_only" []
                 "UQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;"]),
     Right
       (Page "UQXTN_advsimd" []
          [(Class "UQXTN_asisdmisc_N" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/extract/sat/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQXTN_asisdmisc_N" [] "UQXTN  <Vb><d>, <Va><n>"
                 [Symbol "<Vb>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing,
                  Symbol "<Va>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "H" [[O, O]] Nothing, TableRow "S" [[O, I]] Nothing,
                           TableRow "D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/extract/sat/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');"]),
           (Class "UQXTN_asimdmisc_N" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/extract/sat/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UQXTN_asimdmisc_N" [] "UQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/extract/sat/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/extract/sat/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;"]),
     Right
       (Page "URECPE_advsimd" []
          [(Class "URECPE_asimdmisc_R" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/special/recip/int"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "URECPE_asimdmisc_R" [] "URECPE  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[X], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/special/recip/int"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz == '1' then ReservedValue();\ninteger esize = 32;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/special/recip/int"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(32) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 32];\n    Elem[result, e, 32] = UnsignedRecipEstimate(element);\n\nV[d] = result;"]),
     Right
       (Page "URHADD_advsimd" []
          [(Class "URHADD_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/rounding"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "URHADD_asimdsame_only" []
                 "URHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/rounding"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/rounding"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;\n\nV[d] = result;"]),
     Right
       (Page "URSHL_advsimd" []
          [(Class "URSHL_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "URSHL_asisdsame_only" [] "URSHL  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();"]),
           (Class "URSHL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [I]),
                  Block (Just "S") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "URSHL_asimdsame_only" []
                 "URSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "URSHR_advsimd" []
          [(Class "URSHR_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block (Just "o0") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "URSHR_asisdshf_R" [] "URSHR  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"]),
           (Class "URSHR_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block (Just "o0") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "URSHR_asimdshf_R" []
                 "URSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "URSQRTE_advsimd" []
          [(Class "URSQRTE_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/int"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block Nothing (BlockEq [I]), Block (Just "sz") (BlockEq [X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, I, I, O, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "URSQRTE_asimdmisc_R" [] "URSQRTE  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "sz:Q"
                    (Just
                       (Table ["Q", "sz"]
                          [TableRow "2S" [[O], [O]] Nothing,
                           TableRow "4S" [[I], [O]] Nothing,
                           TableRow "RESERVED" [[X], [I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/int"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif sz == '1' then ReservedValue();\ninteger esize = 32;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/int"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(32) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 32];\n    Elem[result, e, 32] = UnsignedRSqrtEstimate(element);\n\nV[d] = result;"]),
     Right
       (Page "URSRA_advsimd" []
          [(Class "URSRA_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block (Just "o0") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "URSRA_asisdshf_R" [] "URSRA  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"]),
           (Class "URSRA_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block (Just "o0") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "URSRA_asimdshf_R" []
                 "URSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "USHL_advsimd" []
          [(Class "USHL_asisdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USHL_asisdsame_only" [] "USHL  <V><d>, <V><n>, <V><m>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "RESERVED" [[O, X]] Nothing,
                           TableRow "RESERVED" [[I, O]] Nothing,
                           TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<m>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();"]),
           (Class "USHL_asimdsame_only" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, I, O]), Block (Just "R") (BlockEq [O]),
                  Block (Just "S") (BlockEq [O]), Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USHL_asimdsame_only" []
                 "USHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "USHLL_advsimd" ["UXTL_USHLL_advsimd"]
          [(Class "USHLL_asimdshf_L" Nothing
              (Diagram "aarch64/instrs/vector/shift/left-long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block (Just "opcode") (BlockEq [I, O, I, O, O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USHLL_asimdshf_L" []
                 "USHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "8H" [[O, O, O, I]] Nothing,
                           TableRow "4S" [[O, O, I, X]] Nothing,
                           TableRow "2D" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[X], [I, X, X, X]] Nothing])),
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(UInt(immh:immb)-8)" [[O, O, O, I]] Nothing,
                           TableRow "(UInt(immh:immb)-16)" [[O, O, I, X]] Nothing,
                           TableRow "(UInt(immh:immb)-32)" [[O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/left-long" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\ninteger shift = UInt(immh:immb) - esize;\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/shift/left-long" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(datasize*2) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "USHR_advsimd" []
          [(Class "USHR_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block (Just "o0") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USHR_asisdshf_R" [] "USHR  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"]),
           (Class "USHR_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block (Just "o0") (BlockEq [O]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USHR_asimdshf_R" [] "USHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "USQADD_advsimd" []
          [(Class "USQADD_asisdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/add/saturating/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USQADD_asisdmisc_R" [] "USQADD  <V><d>, <V><n>"
                 [Symbol "<V>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "B" [[O, O]] Nothing, TableRow "H" [[O, I]] Nothing,
                           TableRow "S" [[I, O]] Nothing, TableRow "D" [[I, I]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/add/saturating/sisd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\n\nboolean unsigned = (U == '1');"]),
           (Class "USQADD_asimdmisc_R" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/unary/add/saturating/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [O, O, O, I, I]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USQADD_asimdmisc_R" [] "USQADD  <Vd>.<T>, <Vn>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/add/saturating/simd"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\nboolean unsigned = (U == '1');"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/add/saturating/sisd"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(datasize) operand2 = V[d];\ninteger op1;\ninteger op2;\nboolean sat;\n\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, e, esize], !unsigned);\n    op2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);\n    if sat then FPSR.QC = '1';\nV[d] = result;"]),
     Right
       (Page "USRA_advsimd" []
          [(Class "USRA_asisdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/sisd"
                 [Block Nothing (BlockEq [O, I]), Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block (Just "o0") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USRA_asisdshf_R" [] "USRA  <V><d>, <V><n>, #<shift>"
                 [Symbol "<V>" "immh"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "D" [[I, X, X, X]] Nothing])),
                  Symbol "<d>" "Rd" Nothing, Symbol "<n>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "RESERVED" [[O, X, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"]),
           (Class "USRA_asimdshf_R" Nothing
              (Diagram "aarch64/instrs/vector/shift/right/simd"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, I, O]),
                  Block (Just "immh") (BlockNeq [O, O, O, O]),
                  Block (Just "immb") (BlockEq [X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [O]),
                  Block (Just "o0") (BlockEq [I]), Block Nothing (BlockEq [O]),
                  Block Nothing (BlockEq [I]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USRA_asimdshf_R" [] "USRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "immh:Q"
                    (Just
                       (Table ["Q", "immh"]
                          [TableRow "SEE Advanced SIMD modified immediate"
                             [[X], [O, O, O, O]]
                             Nothing,
                           TableRow "8B" [[O], [O, O, O, I]] Nothing,
                           TableRow "16B" [[I], [O, O, O, I]] Nothing,
                           TableRow "4H" [[O], [O, O, I, X]] Nothing,
                           TableRow "8H" [[I], [O, O, I, X]] Nothing,
                           TableRow "2S" [[O], [O, I, X, X]] Nothing,
                           TableRow "4S" [[I], [O, I, X, X]] Nothing,
                           TableRow "RESERVED" [[O], [I, X, X, X]] Nothing,
                           TableRow "2D" [[I], [I, X, X, X]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<shift>" "immh:immb"
                    (Just
                       (Table ["immh"]
                          [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                             Nothing,
                           TableRow "(16-UInt(immh:immb))" [[O, O, O, I]] Nothing,
                           TableRow "(32-UInt(immh:immb))" [[O, O, I, X]] Nothing,
                           TableRow "(64-UInt(immh:immb))" [[O, I, X, X]] Nothing,
                           TableRow "(128-UInt(immh:immb))" [[I, X, X, X]] Nothing]))]],
            [Ps "aarch64/instrs/vector/shift/right/simd" (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');"])]
          [Ps "aarch64/instrs/vector/shift/right/sisd" (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "USUBL_advsimd" []
          [(Class "USUBL_asimddiff_L" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block Nothing (BlockEq [O]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USUBL_asimddiff_L" []
                 "USUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vm>" "Rm" Nothing]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"]),
     Right
       (Page "USUBW_advsimd" []
          [(Class "USUBW_asimddiff_W" Nothing
              (Diagram
                 "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [I]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O, O]), Block (Just "o1") (BlockEq [I]),
                  Block Nothing (BlockEq [I]), Block Nothing (BlockEq [O, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "USUBW_asimddiff_W" []
                 "USUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing]))]],
            [Ps
               "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');"])]
          [Ps
             "aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;"]),
     Left
       (AliasPage "UXTL_USHLL_advsimd" "USHLL_advsimd"
          (Class "USHLL_asimdshf_L" Nothing
             (Diagram "aarch64/instrs/vector/shift/left-long"
                [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                 Block (Just "U") (BlockEq [I]),
                 Block Nothing (BlockEq [O, I, I, I, I, O]),
                 Block (Just "immh") (BlockNeq [O, O, O, O]),
                 Block (Just "immb") (BlockEq [O, O, O]),
                 Block (Just "opcode") (BlockEq [I, O, I, O, O]),
                 Block Nothing (BlockEq [I]),
                 Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                 Block (Just "Rd") (BlockEq [X, X, X, X, X])])
             [Encoding "UXTL_USHLL_asimdshf_L" []
                "UXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"
                [Symbol "2" "Q"
                   (Just
                      (Table ["Q"]
                         [TableRow "[absent]" [[O]] Nothing,
                          TableRow "[present]" [[I]] Nothing])),
                 Symbol "<Vd>" "Rd" Nothing,
                 Symbol "<Ta>" "immh"
                   (Just
                      (Table ["immh"]
                         [TableRow "SEE Advanced SIMD modified immediate" [[O, O, O, O]]
                            Nothing,
                          TableRow "8H" [[O, O, O, I]] Nothing,
                          TableRow "4S" [[O, O, I, X]] Nothing,
                          TableRow "2D" [[O, I, X, X]] Nothing,
                          TableRow "RESERVED" [[I, X, X, X]] Nothing])),
                 Symbol "<Vn>" "Rn" Nothing,
                 Symbol "<Tb>" "immh:Q"
                   (Just
                      (Table ["Q", "immh"]
                         [TableRow "SEE Advanced SIMD modified immediate"
                            [[X], [O, O, O, O]]
                            Nothing,
                          TableRow "8B" [[O], [O, O, O, I]] Nothing,
                          TableRow "16B" [[I], [O, O, O, I]] Nothing,
                          TableRow "4H" [[O], [O, O, I, X]] Nothing,
                          TableRow "8H" [[I], [O, O, I, X]] Nothing,
                          TableRow "2S" [[O], [O, I, X, X]] Nothing,
                          TableRow "4S" [[I], [O, I, X, X]] Nothing,
                          TableRow "RESERVED" [[X], [I, X, X, X]] Nothing]))]])),
     Right
       (Page "UZP1_advsimd" []
          [(Class "UZP1_asimdperm_only" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/permute/unzip"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UZP1_asimdperm_only" []
                 "UZP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/vector/permute/unzip"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);"])]
          [Ps "aarch64/instrs/vector/transfer/vector/permute/unzip"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operandl = V[n];\nbits(datasize) operandh = V[m];\nbits(datasize) result;\ninteger e;\n\nbits(datasize*2) zipped = operandh:operandl;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];\n\nV[d] = result;"]),
     Right
       (Page "UZP2_advsimd" []
          [(Class "UZP2_asimdperm_only" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/permute/unzip"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [O, I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "UZP2_asimdperm_only" []
                 "UZP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/vector/permute/unzip"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);"])]
          [Ps "aarch64/instrs/vector/transfer/vector/permute/unzip"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operandl = V[n];\nbits(datasize) operandh = V[m];\nbits(datasize) result;\ninteger e;\n\nbits(datasize*2) zipped = operandh:operandl;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];\n\nV[d] = result;"]),
     Right
       (Page "XAR_advsimd" []
          [(Class "XAR_VVV2_crypto3_imm6" (Just (ArchName "ARMv8.2"))
              (Diagram "aarch64/instrs/vector/crypto/sha3/xar"
                 [Block Nothing (BlockEq [I, I, O, O, I, I, I, O, I, O, O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block (Just "imm6") (BlockEq [X, X, X, X, X, X]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "XAR_VVV2_crypto3_imm6" []
                 "XAR  <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>"
                 [Symbol "<Vd>" "Rd" Nothing, Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Vm>" "Rm" Nothing, Symbol "<imm6>" "imm6" Nothing]],
            [Ps "aarch64/instrs/vector/crypto/sha3/xar" (Just PsDecode)
               "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);"])]
          [Ps "aarch64/instrs/vector/crypto/sha3/xar" (Just PsExecute)
             "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) tmp;\ntmp = Vn EOR Vm; \nV[d] = ROR(tmp<127:64>, UInt(imm6)):ROR(tmp<63:0>, UInt(imm6));"]),
     Right
       (Page "XTN_advsimd" []
          [(Class "XTN_asimdmisc_N" Nothing
              (Diagram "aarch64/instrs/vector/arithmetic/unary/extract/nosat"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block (Just "U") (BlockEq [O]),
                  Block Nothing (BlockEq [O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]),
                  Block Nothing (BlockEq [I, O, O, O, O]),
                  Block (Just "opcode") (BlockEq [I, O, O, I, O]),
                  Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "XTN_asimdmisc_N" [] "XTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
                 [Symbol "2" "Q"
                    (Just
                       (Table ["Q"]
                          [TableRow "[absent]" [[O]] Nothing,
                           TableRow "[present]" [[I]] Nothing])),
                  Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<Tb>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[X], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing,
                  Symbol "<Ta>" "size"
                    (Just
                       (Table ["size"]
                          [TableRow "8H" [[O, O]] Nothing, TableRow "4S" [[O, I]] Nothing,
                           TableRow "2D" [[I, O]] Nothing,
                           TableRow "RESERVED" [[I, I]] Nothing]))]],
            [Ps "aarch64/instrs/vector/arithmetic/unary/extract/nosat"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\n\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;"])]
          [Ps "aarch64/instrs/vector/arithmetic/unary/extract/nosat"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    Elem[result, e, esize] = element<esize-1:0>;\nVpart[d, part] = result;"]),
     Right
       (Page "ZIP1_advsimd" []
          [(Class "ZIP1_asimdperm_only" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/permute/zip"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "op") (BlockEq [O]),
                  Block Nothing (BlockEq [I, I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ZIP1_asimdperm_only" []
                 "ZIP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/vector/permute/zip"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;"])]
          [Ps "aarch64/instrs/vector/transfer/vector/permute/zip"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger base = part * pairs;\ninteger p;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];\n\nV[d] = result;"]),
     Right
       (Page "ZIP2_advsimd" []
          [(Class "ZIP2_asimdperm_only" Nothing
              (Diagram "aarch64/instrs/vector/transfer/vector/permute/zip"
                 [Block Nothing (BlockEq [O]), Block (Just "Q") (BlockEq [X]),
                  Block Nothing (BlockEq [O, O, I, I, I, O]),
                  Block (Just "size") (BlockEq [X, X]), Block Nothing (BlockEq [O]),
                  Block (Just "Rm") (BlockEq [X, X, X, X, X]),
                  Block Nothing (BlockEq [O]), Block (Just "op") (BlockEq [I]),
                  Block Nothing (BlockEq [I, I]), Block Nothing (BlockEq [I, O]),
                  Block (Just "Rn") (BlockEq [X, X, X, X, X]),
                  Block (Just "Rd") (BlockEq [X, X, X, X, X])])
              [Encoding "ZIP2_asimdperm_only" []
                 "ZIP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
                 [Symbol "<Vd>" "Rd" Nothing,
                  Symbol "<T>" "size:Q"
                    (Just
                       (Table ["Q", "size"]
                          [TableRow "8B" [[O], [O, O]] Nothing,
                           TableRow "16B" [[I], [O, O]] Nothing,
                           TableRow "4H" [[O], [O, I]] Nothing,
                           TableRow "8H" [[I], [O, I]] Nothing,
                           TableRow "2S" [[O], [I, O]] Nothing,
                           TableRow "4S" [[I], [I, O]] Nothing,
                           TableRow "RESERVED" [[O], [I, I]] Nothing,
                           TableRow "2D" [[I], [I, I]] Nothing])),
                  Symbol "<Vn>" "Rn" Nothing, Symbol "<Vm>" "Rm" Nothing]],
            [Ps "aarch64/instrs/vector/transfer/vector/permute/zip"
               (Just PsDecode)
               "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;"])]
          [Ps "aarch64/instrs/vector/transfer/vector/permute/zip"
             (Just PsExecute)
             "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger base = part * pairs;\ninteger p;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];\n\nV[d] = result;"])]